"""
Bivariate Bicycle code can be implemented using *polynomial quotient ring
formalism*. The set of monomials ``\\{x^i y^j \\mid 0 \\leq i < \\ell, 0 \\leq j < m}``
forms a basis for the matrix algebra generated by ``x`` and ``y``, establishing a
[bijection](https://en.wikipedia.org/wiki/Bijection) between these monomials and the
resulting ``(\\ell m) \\times (\\ell m)`` matrices. This correspondence allows us to
work equivalently with either the polynomial or matrix formulation [wang2024coprime](@cite).
Here, we use the polynomial quotient ring formalism.

#### Examples

Here is the `[[54, 8, 6]]` from Table 1 [wang2024coprime](@cite)

```jldoctest
julia> using Oscar; using QuantumClifford.ECC;

julia> l=3; m=9;

julia> R, (x, y) = polynomial_ring(GF(2), [:x, :y]);

julia> I = ideal(R, [x^l-1, y^m-1]);

julia> S, _ = quo(R, I);

julia> A = S(1   + y^2 + y^4);

julia> B = S(y^3 + x   + x^2);

julia> c = BivariateBicycleCode(l, m, A, B);

julia> code_n(c), code_k(c)
(54, 8)
```

Here is the `[[72, 12, 6]]` from Table 3 of [bravyi2024high](@cite)

```jldoctest
julia> using Oscar; using QuantumClifford.ECC;

julia> l=6; m=6;

julia> R, (x, y) = polynomial_ring(GF(2), [:x, :y]);

julia> I = ideal(R, [x^l-1, y^m-1]);

julia> S, _ = quo(R, I);

julia> A = S(x^3 + y + y^2);

julia> B = S(y^3 + x + x^2);

julia> c = BivariateBicycleCode(l, m, A, B);

julia> code_n(c), code_k(c)
(72, 12)
```

Here is the `[[756, 16, ≤ 34]]` from Table 3 of [bravyi2024high](@cite)

```jldoctest
julia> using Oscar; using QuantumClifford.ECC;

julia> l=21; m=18;

julia> R, (x, y) = polynomial_ring(GF(2), [:x, :y]);

julia> I = ideal(R, [x^l-1, y^m-1]);

julia> S, _ = quo(R, I);

julia> A = S(x^3 + y^10 + y^17);

julia> B = S(y^5 + x^3  + x^19);

julia> c = BivariateBicycleCode(l, m, A, B);

julia> code_n(c), code_k(c)
(756, 16)
```

Here is the `[[128, 14, 12]]` from Table 1 [eberhardt2024logical](@cite)

```jldoctest
julia> using Oscar; using QuantumClifford.ECC;

julia> l=8; m=8;

julia> R, (x, y) = polynomial_ring(GF(2), [:x, :y]);

julia> I = ideal(R, [x^l-1, y^m-1]);

julia> S, _ = quo(R, I);

julia> A = S(x^2 + y + y^3 + y^4);

julia> B = S(y^2 + x + x^3 + x^4);

julia> c = BivariateBicycleCode(l, m, A, B);

julia> code_n(c), code_k(c)
(128, 14)
```
"""
struct BivariateBicycleCode <: AbstractCSSCode
    """Order of the first abelian group in ``\\mathbb{F}_2[\\mathbb{Z}_\\ell \\times \\mathbb{Z}_m]``"""
    ℓ::Int
    """Order of the second abelian group in ``\\mathbb{F}_2[\\mathbb{Z}_\\ell \\times \\mathbb{Z}_m]``"""
    m::Int
    """First bivariate polynomial in quotient ring ``\\frac{\\mathbb{F}_2[x, y]}{\\langle x^\\ell-1, y^m-1 \\rangle}``"""
    c::MPolyQuoRingElem
    """Second bivariate polynomial in quotient ring ``\\frac{\\mathbb{F}_2[x, y]}{\\langle x^\\ell-1, y^m-1 \\rangle}``"""
    d::MPolyQuoRingElem
    
    function BivariateBicycleCode(ℓ::Int, m::Int, c::MPolyQuoRingElem, d::MPolyQuoRingElem)
        ℓ > 0 || throw(ArgumentError("ℓ must be positive"))
        m > 0 || throw(ArgumentError("m must be positive"))
        parent(c) == parent(d) || throw(ArgumentError("Polynomials must be in the same quotient ring"))
        Q = parent(c)
        R = base_ring(Q)
        base_ring(R) == GF(2) || throw(ArgumentError("Base ring must be GF(2)"))
        nvars(R) == 2 || throw(ArgumentError("Must be bivariate polynomials"))
        new(ℓ, m, c, d)
    end
end

function _poly_to_coeff_mat(poly::MPolyQuoRingElem, ℓ::Int, m::Int)
    mat = zeros(Int, ℓ, m)
    poly_lift = lift(poly)
    for term in terms(poly_lift)
        coeffᵥₐₗ = coeff(term, 1)
        coeffᵢₙₜ = iszero(coeffᵥₐₗ) ? 0 : 1
        monom = monomial(term, 1)
        exps = exponent_vector(monom, 1)
        i = length(exps) >= 1 ? exps[1] : 0
        j = length(exps) >= 2 ? exps[2] : 0
        i = mod(i, ℓ)
        j = mod(j, m)
        if i < ℓ && j < m
            mat[i+1, j+1] = coeffᵢₙₜ
        end
    end
    return mat
end

function _bivariate_circulant(coeff_mat::Matrix{Int})
    ℓ, m = size(coeff_mat)
    n = ℓ*m
    circ_mat = zeros(Int, n, n)
    for i₁ in 0:ℓ-1, j₁ in 0:m-1
        row_idx = i₁*m+j₁+1
        for i₂ in 0:ℓ-1, j₂ in 0:m-1
            i_res = mod(i₁ + i₂, ℓ)
            j_res = mod(j₁ + j₂, m)
            col_idx = i_res*m + j_res + 1
            circ_mat[row_idx, col_idx] += coeff_mat[i₂+1, j₂+1]
        end
    end
    return circ_mat
end

function parity_matrix_xz(c::BivariateBicycleCode)
    A_coeff = _poly_to_coeff_mat(c.c, c.ℓ, c.m)
    B_coeff = _poly_to_coeff_mat(c.d, c.ℓ, c.m)
    A = _bivariate_circulant(A_coeff)
    B = _bivariate_circulant(B_coeff)
    hx, hz = hcat(A, B), hcat(transpose(B), transpose(A))
    return hx, hz
end

parity_matrix_x(c::BivariateBicycleCode) = parity_matrix_xz(c)[1]

parity_matrix_z(c::BivariateBicycleCode) = parity_matrix_xz(c)[2]

code_n(c::BivariateBicycleCode) = 2*c.ℓ*c.m

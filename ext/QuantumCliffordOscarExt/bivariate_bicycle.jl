"""
Bivariate Bicycle code using *polynomial quotient ring formalism*: The set of
monomials ``\\{x^i y^j \\mid 0 \\leq i < \\ell, 0 \\leq j < m}`` forms a basis
for the matrix algebra generated by ``x`` and ``y``, establishing a [bijection](https://en.wikipedia.org/wiki/Bijection)
between these monomials and the resulting ``(\\ell m) \\times (\\ell m)`` matrices.
This correspondence allows us to work equivalently with either the polynomial or
matrix formulation [wang2024coprime](@cite).
"""
struct BivariateBicycleCode <: AbstractCSSCode
    """Order of the first abelian group in ``\\mathbb{F}_2[\\mathbb{Z}_\\ell \\times \\mathbb{Z}_m]``"""
    ℓ::Int
    """Order of the second abelian group in ``\\mathbb{F}_2[\\mathbb{Z}_\\ell \\times \\mathbb{Z}_m]``"""
    m::Int
    """First bivariate polynomial in quotient ring ``\\frac{\\mathbb{F}_2[x, y]}{\\langle x^\\ell-1, y^m-1 \\rangle}``"""
    c::MPolyQuoRingElem
    """Second bivariate polynomial in quotient ring ``\\frac{\\mathbb{F}_2[x, y]}{\\langle x^\\ell-1, y^m-1 \\rangle}``"""
    d::MPolyQuoRingElem
    
    function BivariateBicycleCode(ℓ::Int, m::Int, c::MPolyQuoRingElem, d::MPolyQuoRingElem)
        ℓ > 0 || throw(ArgumentError("ℓ must be positive"))
        m > 0 || throw(ArgumentError("m must be positive"))
        parent(c) == parent(d) || throw(ArgumentError("Polynomials must be in the same quotient ring"))
        Q = parent(c)
        R = base_ring(Q)
        base_ring(R) == GF(2) || throw(ArgumentError("Base ring must be GF(2)"))
        nvars(R) == 2 || throw(ArgumentError("Must be bivariate polynomials"))
        new(ℓ, m, c, d)
    end
end

function _poly_to_coeff_mat(poly::MPolyQuoRingElem, ℓ::Int, m::Int)
    mat = zeros(Int, ℓ, m)
    poly_lift = lift(poly)
    for term in terms(poly_lift)
        coeffᵥₐₗ = coeff(term, 1)
        coeffᵢₙₜ = iszero(coeffᵥₐₗ) ? 0 : 1
        monom = monomial(term, 1)
        exps = exponent_vector(monom, 1)
        i = length(exps) >= 1 ? exps[1] : 0
        j = length(exps) >= 2 ? exps[2] : 0
        i = mod(i, ℓ)
        j = mod(j, m)
        if i < ℓ && j < m
            mat[i+1, j+1] = coeffᵢₙₜ
        end
    end
    return mat
end

function _bivariate_circulant(coeff_mat::Matrix{Int})
    ℓ, m = size(coeff_mat)
    n = ℓ*m
    circ_mat = zeros(Int, n, n)
    for i₁ in 0:ℓ-1, j₁ in 0:m-1
        row_idx = i₁*m+j₁+1
        for i₂ in 0:ℓ-1, j₂ in 0:m-1
            i_res = mod(i₁ + i₂, ℓ)
            j_res = mod(j₁ + j₂, m)
            col_idx = i_res*m + j_res + 1
            circ_mat[row_idx, col_idx] += coeff_mat[i₂+1, j₂+1]
        end
    end
    return circ_mat
end

function parity_matrix_xz(c::BivariateBicycleCode)
    A_coeff = _poly_to_coeff_mat(c.c, c.ℓ, c.m)
    B_coeff = _poly_to_coeff_mat(c.d, c.ℓ, c.m)
    A = _bivariate_circulant(A_coeff)
    B = _bivariate_circulant(B_coeff)
    hx, hz = hcat(A, B), hcat(transpose(B), transpose(A))
    return hx, hz
end

parity_matrix_x(c::BivariateBicycleCode) = parity_matrix_xz(c)[1]

parity_matrix_z(c::BivariateBicycleCode) = parity_matrix_xz(c)[2]

code_n(c::BivariateBicycleCode) = 2*c.ℓ*c.m

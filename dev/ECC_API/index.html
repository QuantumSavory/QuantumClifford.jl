<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · QuantumClifford.jl</title><meta name="title" content="API · QuantumClifford.jl"/><meta property="og:title" content="API · QuantumClifford.jl"/><meta property="twitter:title" content="API · QuantumClifford.jl"/><meta name="description" content="Documentation for QuantumClifford.jl."/><meta property="og:description" content="Documentation for QuantumClifford.jl."/><meta property="twitter:description" content="Documentation for QuantumClifford.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumClifford.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">QuantumClifford.jl</a></li><li><span class="tocitem">Stabilizer Tableau Algebra</span><ul><li><a class="tocitem" href="../stab-algebra-manual/">Manual</a></li><li><a class="tocitem" href="../canonicalization/">Canonicalization</a></li><li><a class="tocitem" href="../mixed/">Mixed States</a></li><li><a class="tocitem" href="../graphs/">Graph States</a></li><li><a class="tocitem" href="../datastructures/">Datastructure Choice</a></li><li><a class="tocitem" href="../commonstates/">Useful States</a></li></ul></li><li><span class="tocitem">Noisy Circuits</span><ul><li><a class="tocitem" href="../noisycircuits/">Simulation of Noisy Circuits</a></li><li><a class="tocitem" href="../noisycircuits_mc/">Monte Carlo</a></li><li><a class="tocitem" href="../noisycircuits_perturb/">Perturbative Expansions</a></li><li><a class="tocitem" href="../ecc_example_sim/">ECC example</a></li><li><a class="tocitem" href="../noisycircuits_ops/">Circuit Operations</a></li><li><a class="tocitem" href="../noisycircuits_API/">API</a></li></ul></li><li><span class="tocitem">ECC compendium</span><ul><li><a class="tocitem" href="../ECC_evaluating/">Evaluating codes and decoders</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Implemented-in-an-extension-requiring-Hecke.jl"><span>Implemented in an extension requiring <code>Hecke.jl</code></span></a></li><li><a class="tocitem" href="#Implemented-in-an-extension-requiring-Oscar.jl"><span>Implemented in an extension requiring <code>Oscar.jl</code></span></a></li><li><a class="tocitem" href="#Implemented-in-an-extension-requiring-JuMP.jl"><span>Implemented in an extension requiring <code>JuMP.jl</code></span></a></li></ul></li></ul></li><li><a class="tocitem" href="../allops/">All Gates</a></li><li><a class="tocitem" href="../plotting/">Visualizations</a></li><li><a class="tocitem" href="../API/">API</a></li><li><a class="tocitem" href="../tutandpub/">Tutorials and Publications</a></li><li><a class="tocitem" href="../references/">Suggested Readings &amp; References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ECC compendium</a></li><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumSavory/QuantumClifford.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/master/docs/src/ECC_API.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Full-ECC-API-(autogenerated)"><a class="docs-heading-anchor" href="#Full-ECC-API-(autogenerated)">Full ECC API (autogenerated)</a><a id="Full-ECC-API-(autogenerated)-1"></a><a class="docs-heading-anchor-permalink" href="#Full-ECC-API-(autogenerated)" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.CircuitCode" href="#QuantumClifford.ECC.CircuitCode"><code>QuantumClifford.ECC.CircuitCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>CircuitCode</code> is defined by a given encoding circuit <code>circ</code>.</p><ul><li><code>n</code>: qubit number</li><li><code>circ</code>: the encoding circuit</li><li><code>encode_qubits</code>: the qubits to be encoded</li></ul><p>See also: <a href="#QuantumClifford.ECC.random_all_to_all_circuit_code"><code>random_all_to_all_circuit_code</code></a>, <a href="#QuantumClifford.ECC.random_brickwork_circuit_code"><code>random_brickwork_circuit_code</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/codes/random_circuit.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.CommutationCheckECCSetup" href="#QuantumClifford.ECC.CommutationCheckECCSetup"><code>QuantumClifford.ECC.CommutationCheckECCSetup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Configuration for ECC evaluator that does not simulate any ECC circuits, rather it simply checks the commutation of the parity check and the Pauli error.</p><p>This is much faster than any other simulation method, but it is incapable of noisy-circuit simulations and thus useless for fault-tolerance studies.</p><p>See also: <a href="#QuantumClifford.ECC.NaiveSyndromeECCSetup"><code>NaiveSyndromeECCSetup</code></a>, <a href="#QuantumClifford.ECC.ShorSyndromeECCSetup"><code>ShorSyndromeECCSetup</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/decoder_pipeline.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.Concat" href="#QuantumClifford.ECC.Concat"><code>QuantumClifford.ECC.Concat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Concat(c₁, c₂)</code> is a code concatenation of two quantum codes (<a href="../references/#knill1996concatenated">Knill and Laflamme, 1996</a>).</p><p>The inner code c₁ and the outer code c₂. The construction is the following: replace each qubit in code c₂ with logical qubits encoded by code c₁. The resulting code will have <code>n = n₁ × n₂</code> qubits and <code>k = k₁ × k₂</code> logical qubits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/codes/concat.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.DistanceMIPAlgorithm" href="#QuantumClifford.ECC.DistanceMIPAlgorithm"><code>QuantumClifford.ECC.DistanceMIPAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DistanceMIPAlgorithm &lt;: QECCore.AbstractDistanceAlg</code></pre><p>A Mixed Integer Programming (MIP) method for computing the code distance of CSS stabilizer codes by finding the minimum-weight non-trivial logical <a href="../API/#QuantumClifford.PauliOperator"><code>PauliOperator</code></a> (either <code>X</code>-type or <code>Z</code>-type). Used with <a href="#QECCore.distance-Tuple{QECCore.AbstractECC, QuantumClifford.ECC.DistanceMIPAlgorithm}"><code>distance</code></a> to select MIP as the method of finding the distance of a code.</p><div class="admonition is-info" id="Note-c7dd4d4a058d44a4"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c7dd4d4a058d44a4" title="Permalink"></a></header><div class="admonition-body"><ul><li>Requires a <code>JuMP</code>-compatible MIP solver (e.g., <code>HiGHS</code>, <code>SCIP</code>).</li><li>For some stabilizer CSS codes, the <code>X</code>-distance and <code>Z</code>-distance are equal.</li></ul></div></div><ul><li><p><code>logical_qubit</code>: index of the logical qubit to compute code distance for (nothing means compute for all logical qubits)</p></li><li><p><code>logical_operator_type</code>: type of logical operator to consider (:X or :Z, defaults to :minXZ).</p></li><li><p><code>solver</code>: <code>JuMP</code>-compatible MIP solver (e.g., <code>HiGHS</code>, <code>SCIP</code>)</p></li><li><p><code>opt_summary</code>: when <code>true</code> (default=<code>false</code>), prints the MIP solver&#39;s solution summary</p></li><li><p><code>time_limit</code>: time limit (in seconds) for the MIP solver&#39;s execution (default=60.0)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/ECC.jl#L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.NaiveSyndromeECCSetup" href="#QuantumClifford.ECC.NaiveSyndromeECCSetup"><code>QuantumClifford.ECC.NaiveSyndromeECCSetup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Configuration for ECC evaluator that runs the simplest syndrome measurement circuit.</p><p>The circuit is being simulated (as opposed to doing only a quick commutation check). This circuit would give poor performance if there is non-zero gate noise.</p><p>See also: <a href="#QuantumClifford.ECC.CommutationCheckECCSetup"><code>CommutationCheckECCSetup</code></a>, <a href="#QuantumClifford.ECC.ShorSyndromeECCSetup"><code>ShorSyndromeECCSetup</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/decoder_pipeline.jl#L46-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.ShorSyndromeECCSetup" href="#QuantumClifford.ECC.ShorSyndromeECCSetup"><code>QuantumClifford.ECC.ShorSyndromeECCSetup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Configuration for ECC evaluators that simulate the Shor-style syndrome measurement (without a flag qubit).</p><p>The simulated circuit includes:</p><ul><li>perfect noiseless encoding (encoding and its fault tolerance are not being studied here)</li><li>one round of &quot;memory noise&quot; after the encoding but before the syndrome measurement</li><li>perfect preparation of entangled ancillary qubits</li><li>noisy Shor-style syndrome measurement (only two-qubit gate noise)</li><li>noiseless &quot;logical state measurement&quot; (providing the comparison data when evaluating the decoder)</li></ul><p>See also: <a href="#QuantumClifford.ECC.CommutationCheckECCSetup"><code>CommutationCheckECCSetup</code></a>, <a href="#QuantumClifford.ECC.NaiveSyndromeECCSetup"><code>NaiveSyndromeECCSetup</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/decoder_pipeline.jl#L62-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.TableDecoder" href="#QuantumClifford.ECC.TableDecoder"><code>QuantumClifford.ECC.TableDecoder</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A simple look-up table decoder for error correcting codes.</p><p>The lookup table contains only weight=1 errors, thus it is small, but at best it provides only for distance=3 decoding.</p><p>The size of the lookup table would grow exponentially quickly for higher distances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/decoder_pipeline.jl#L210-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.code_k-Tuple{Stabilizer}" href="#QECCore.code_k-Tuple{Stabilizer}"><code>QECCore.code_k</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The number of logical qubits in a code.</p><p>Note that when redundant rows exist in the parity check matrix, the number of logical qubits <code>code_k(c)</code> will be greater than <code>code_n(c) - code_s(c)</code>, where the difference equals the redundancy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/ECC.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.parity_matrix_x-Tuple{QECCore.AbstractECC}" href="#QECCore.parity_matrix_x-Tuple{QECCore.AbstractECC}"><code>QECCore.parity_matrix_x</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parity check boolean matrix of a code (only the X entries in the tableau, i.e. the checks for Z errors).</p><p>Only CSS codes have this method.</p><p>See also: <a href="#QuantumClifford.ECC.parity_checks"><code>parity_checks</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/ECC.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.parity_matrix_z-Tuple{QECCore.AbstractECC}" href="#QECCore.parity_matrix_z-Tuple{QECCore.AbstractECC}"><code>QECCore.parity_matrix_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parity check boolean matrix of a code (only the Z entries in the tableau, i.e. the checks for X errors).</p><p>Only CSS codes have this method.</p><p>See also: <a href="#QuantumClifford.ECC.parity_checks"><code>parity_checks</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/ECC.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.BeliefPropDecoder-Tuple" href="#QuantumClifford.ECC.BeliefPropDecoder-Tuple"><code>QuantumClifford.ECC.BeliefPropDecoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A simple Belief Propagation decoder built around tools from <code>LDPCDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/decoder_pipeline.jl#L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.BitFlipDecoder-Tuple" href="#QuantumClifford.ECC.BitFlipDecoder-Tuple"><code>QuantumClifford.ECC.BitFlipDecoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>An Iterative Bitflip decoder built around tools from <code>LDPCDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/decoder_pipeline.jl#L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.DDimensionalSurfaceCode-Tuple" href="#QuantumClifford.ECC.DDimensionalSurfaceCode-Tuple"><code>QuantumClifford.ECC.DDimensionalSurfaceCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>D-Dimensional Surface codes ((<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>), (<a href="../references/#Zeng_2019">Zeng and Pryadko, 2019</a>))</p><p>Implemented as a package extension with <code>Oscar</code>. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/codes/d_dimensional_codes.jl#L4-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.DDimensionalToricCode-Tuple" href="#QuantumClifford.ECC.DDimensionalToricCode-Tuple"><code>QuantumClifford.ECC.DDimensionalToricCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>D-Dimensional Toric codes ((<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>), (<a href="../references/#Zeng_2019">Zeng and Pryadko, 2019</a>))</p><p>Implemented as a package extension with <code>Oscar</code>. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/codes/d_dimensional_codes.jl#L15-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.ExtendedGeneralizedBicycleCode-Tuple" href="#QuantumClifford.ECC.ExtendedGeneralizedBicycleCode-Tuple"><code>QuantumClifford.ECC.ExtendedGeneralizedBicycleCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Extended Generalized Bicycle codes ((<a href="../references/#koukoulekidis2024smallquantumcodesalgebraic">Koukoulekidis <em>et al.</em>, 2024</a>))</p><p>Implemented as a package extension with Hecke. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/codes/qeccs_using_hecke.jl#L64-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.GeneralizedBicycleCode-Tuple" href="#QuantumClifford.ECC.GeneralizedBicycleCode-Tuple"><code>QuantumClifford.ECC.GeneralizedBicycleCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Generalized Bicycle codes ((<a href="../references/#koukoulekidis2024smallquantumcodesalgebraic">Koukoulekidis <em>et al.</em>, 2024</a>))</p><p>Implemented as a package extension with Hecke. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/codes/qeccs_using_hecke.jl#L53-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.GeneralizedHyperGraphProductCode-Tuple" href="#QuantumClifford.ECC.GeneralizedHyperGraphProductCode-Tuple"><code>QuantumClifford.ECC.GeneralizedHyperGraphProductCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Generalized Hypergraph Product codes (<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>) Implemented as a package extension with Hecke. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/codes/qeccs_using_hecke.jl#L43-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.LPCode-Tuple" href="#QuantumClifford.ECC.LPCode-Tuple"><code>QuantumClifford.ECC.LPCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Lifted product codes ((<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>), (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>))</p><p>Implemented as a package extension with Hecke. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/codes/qeccs_using_hecke.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.LaCross-Tuple" href="#QuantumClifford.ECC.LaCross-Tuple"><code>QuantumClifford.ECC.LaCross</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>La-cross codes ((<a href="../references/#pecorari2025high">Pecorari <em>et al.</em>, 2025</a>)) Implemented as a package extension with Hecke. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/codes/qeccs_using_hecke.jl#L33-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.LiftedCode-Tuple" href="#QuantumClifford.ECC.LiftedCode-Tuple"><code>QuantumClifford.ECC.LiftedCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Classical codes lifted over a group algebra, used for lifted product code construction ((<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>), (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>))</p><p>Implemented as a package extension with Hecke. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/codes/classical/lifted.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.PyBeliefPropDecoder-Tuple" href="#QuantumClifford.ECC.PyBeliefPropDecoder-Tuple"><code>QuantumClifford.ECC.PyBeliefPropDecoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A Belief Propagation decoder built around tools from the python package <code>ldpc</code> available from the julia package <code>PyQDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/decoder_pipeline.jl#L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.PyBeliefPropOSDecoder-Tuple" href="#QuantumClifford.ECC.PyBeliefPropOSDecoder-Tuple"><code>QuantumClifford.ECC.PyBeliefPropOSDecoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A Belief Propagation decoder with ordered statistics decoding, built around tools from the python package <code>ldpc</code> available from the julia package <code>PyQDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/decoder_pipeline.jl#L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.PyMatchingDecoder-Tuple" href="#QuantumClifford.ECC.PyMatchingDecoder-Tuple"><code>QuantumClifford.ECC.PyMatchingDecoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A perfect matching decoder built around tools from the python package <code>pymatching</code> available from the julia package <code>PyQDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/decoder_pipeline.jl#L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.bicycle_codes" href="#QuantumClifford.ECC.bicycle_codes"><code>QuantumClifford.ECC.bicycle_codes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Hecke. Check the docs for the <a href="http://qc.quantumsavory.org/stable/ECC_API/#Implemented-in-an-extension-requiring-Hecke.jl">Hecke extension</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/codes/qeccs_using_hecke.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.boundary_maps" href="#QuantumClifford.ECC.boundary_maps"><code>QuantumClifford.ECC.boundary_maps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with <code>Oscar</code>. Check the docs for the <a href="http://qc.quantumsavory.org/stable/ECC_API/#Implemented-in-an-extension-requiring-Oscar.jl">Oscar extension</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/codes/d_dimensional_codes.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, QuantumClifford.ECC.AbstractECCSetup, Int64}" href="#QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, QuantumClifford.ECC.AbstractECCSetup, Int64}"><code>QuantumClifford.ECC.evaluate_decoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Evaluate the performance of a given decoder (e.g. <a href="#QuantumClifford.ECC.TableDecoder"><code>TableDecoder</code></a>) and a given style of running an ECC code (e.g. <a href="#QuantumClifford.ECC.ShorSyndromeECCSetup"><code>ShorSyndromeECCSetup</code></a>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/decoder_pipeline.jl#L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, Vararg{Any, 5}}" href="#QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, Vararg{Any, 5}}"><code>QuantumClifford.ECC.evaluate_decoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Evaluate the performance of an error-correcting circuit.</p><p>This method requires you give the circuit that performs both syndrome measurements and (probably noiseless) logical state measurements. The faults matrix that translates an error vector into corresponding logical errors is necessary as well.</p><p>This is a relatively barebones method that assumes the user prepares necessary circuits, etc. It is a method that is used internally by more user-frienly methods providing automatic conversion of codes and noise models to the necessary noisy circuits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/decoder_pipeline.jl#L154-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.faults_matrix-Tuple{Stabilizer}" href="#QuantumClifford.ECC.faults_matrix-Tuple{Stabilizer}"><code>QuantumClifford.ECC.faults_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Error-to-logical-observable map (a.k.a. fault matrix) of a code.</p><p>For a code with n physical qubits and k logical qubits this function returns a 2k × 2n binary matrix O such that <code>O[i,j]</code> is true if the logical observable of index <code>i</code> is flipped by the single physical qubit error of index <code>j</code>. Indexing is such that:</p><ul><li><code>O[1:k,:]</code> is the error-to-logical-X-observable map (logical X observable, i.e. triggered by logical Z errors)</li><li><code>O[k+1:2k,:]</code> is the error-to-logical-Z-observable map</li><li><code>O[:,1:n]</code> is the X-physical-error-to-logical-observable map</li><li><code>O[n+1:2n,:]</code> is the Z-physical-error-to-logical-observable map</li></ul><p>E.g. for <code>k=1</code>, <code>n=10</code>, then if <code>O[2,5]</code> is true, then the logical Z observable is flipped by a X₅ error; and if <code>O[1,12]</code> is true, then the logical X observable is flipped by a Z₂ error.</p><p>Of note is that there is a lot of freedom in choosing the logical operations! A logical operator multiplied by a stabilizer operator is still a logical operator. Similarly there is a different fault matrix for each choice of logical operators. But once the logical operators are picked, the fault matrix is fixed.</p><p>Below we show an example that uses the Shor code. While it is not the smallest code, it is a convenient choice to showcase the importance of the fault matrix when dealing with degenerate codes where a correction operation and an error do not need to be the same.</p><p>First, consider a single-qubit error, potential correction operations, and their effect on the Shor code:</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford.ECC: faults_matrix, Shor9

julia&gt; state = MixedDestabilizer(Shor9())
𝒟ℯ𝓈𝓉𝒶𝒷━━━━━
+ Z________
+ ___Z_____
+ _X_______
+ __X______
+ ____X____
+ _____X___
+ ______X__
+ _______X_
𝒳ₗ━━━━━━━━━
+ ______XXX
𝒮𝓉𝒶𝒷━━━━━━━
+ XXX___XXX
+ ___XXXXXX
+ ZZ_______
+ Z_Z______
+ ___ZZ____
+ ___Z_Z___
+ ______Z_Z
+ _______ZZ
𝒵ₗ━━━━━━━━━
+ Z__Z____Z

julia&gt; err_Z₁ = single_z(9,1) # the error we will simulate
+ Z________

julia&gt; cor_Z₂ = single_z(9,2) # the correction operation we will perform
+ _Z_______

julia&gt; err_Z₁ * state # observe that one of the syndrome bits is now flipped
𝒟ℯ𝓈𝓉𝒶𝒷━━━━━
+ Z________
+ ___Z_____
+ _X_______
+ __X______
+ ____X____
+ _____X___
+ ______X__
+ _______X_
𝒳ₗ━━━━━━━━━
+ ______XXX
𝒮𝓉𝒶𝒷━━━━━━━
- XXX___XXX
+ ___XXXXXX
+ ZZ_______
+ Z_Z______
+ ___ZZ____
+ ___Z_Z___
+ ______Z_Z
+ _______ZZ
𝒵ₗ━━━━━━━━━
+ Z__Z____Z

julia&gt; cor_Z₂ * err_Z₁ * state # we are back to a good code state
𝒟ℯ𝓈𝓉𝒶𝒷━━━━━
+ Z________
+ ___Z_____
- _X_______
+ __X______
+ ____X____
+ _____X___
+ ______X__
+ _______X_
𝒳ₗ━━━━━━━━━
+ ______XXX
𝒮𝓉𝒶𝒷━━━━━━━
+ XXX___XXX
+ ___XXXXXX
+ ZZ_______
+ Z_Z______
+ ___ZZ____
+ ___Z_Z___
+ ______Z_Z
+ _______ZZ
𝒵ₗ━━━━━━━━━
+ Z__Z____Z

julia&gt; bad_Z₆Z₉ = single_z(9,6) * single_z(9,9) # a different &quot;correction&quot; operation
+ _____Z__Z

julia&gt; bad_Z₆Z₉ * err_Z₁ * state # the syndrome is trivial, but now we have a logical error
𝒟ℯ𝓈𝓉𝒶𝒷━━━━━
+ Z________
+ ___Z_____
+ _X_______
+ __X______
+ ____X____
- _____X___
+ ______X__
+ _______X_
𝒳ₗ━━━━━━━━━
- ______XXX
𝒮𝓉𝒶𝒷━━━━━━━
+ XXX___XXX
+ ___XXXXXX
+ ZZ_______
+ Z_Z______
+ ___ZZ____
+ ___Z_Z___
+ ______Z_Z
+ _______ZZ
𝒵ₗ━━━━━━━━━
+ Z__Z____Z</code></pre><p>The success of <code>cor_Z₂</code> and the failure of <code>bad_Z₆Z₉</code> can be immediately seen through the fault matrix, as the wrong &quot;correction&quot; does not result in the same logical flips ad the error:</p><pre><code class="language-julia-repl hljs">julia&gt; O = faults_matrix(Shor9())
2×18 BitMatrix:
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1
 1  0  0  1  0  0  0  0  1  0  0  0  0  0  0  0  0  0

julia&gt; O * stab_to_gf2(err_Z₁)
2-element Vector{Int64}:
 0
 0

julia&gt; O * stab_to_gf2(cor_Z₂)
2-element Vector{Int64}:
 0
 0

julia&gt; O * stab_to_gf2(bad_Z₆Z₉)
2-element Vector{Int64}:
 1
 0</code></pre><p>While its use in this situation is rather contrived, the fault matrix is incredibly useful when running large scale simulations in which we want a separate fast error sampling process, (e.g. with Pauli frames) and a syndrome decoding process, without coupling between them. We just gather all our syndrome measurement <strong>and logical observables</strong> from the Pauli frame simulations, and then use them with the fault matrix in the syndrome decoding simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/ECC.jl#L169-L337">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.generalized_bicycle_codes" href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>QuantumClifford.ECC.generalized_bicycle_codes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Hecke. Check the docs for the <a href="http://qc.quantumsavory.org/stable/ECC_API/#Implemented-in-an-extension-requiring-Hecke.jl">Hecke extension</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/codes/qeccs_using_hecke.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.haah_cubic_codes" href="#QuantumClifford.ECC.haah_cubic_codes"><code>QuantumClifford.ECC.haah_cubic_codes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Hecke. Check the docs for the <a href="http://qc.quantumsavory.org/stable/ECC_API/#Implemented-in-an-extension-requiring-Hecke.jl">Hecke extension</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/codes/qeccs_using_hecke.jl#L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.honeycomb_color_codes" href="#QuantumClifford.ECC.honeycomb_color_codes"><code>QuantumClifford.ECC.honeycomb_color_codes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Hecke.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/codes/qeccs_using_hecke.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.iscss-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:QECCore.AbstractECC" href="#QuantumClifford.ECC.iscss-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:QECCore.AbstractECC"><code>QuantumClifford.ECC.iscss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Check if the code is CSS.</p><p>Return <code>nothing</code> if unknown from the type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/ECC.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.isdegenerate" href="#QuantumClifford.ECC.isdegenerate"><code>QuantumClifford.ECC.isdegenerate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Check if the code is degenerate with respect to a given set of error or with respect to all &quot;up to d physical-qubit&quot; errors (defaulting to d=1).</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford.ECC

julia&gt; isdegenerate(Shor9(), [single_z(9,1), single_z(9,2)])
true

julia&gt; isdegenerate(Shor9(), [single_z(9,1), single_x(9,1)])
false

julia&gt; isdegenerate(Steane7(), 1)
false

julia&gt; isdegenerate(Steane7(), 2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/ECC.jl#L356">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.naive_encoding_circuit-Tuple{Any}" href="#QuantumClifford.ECC.naive_encoding_circuit-Tuple{Any}"><code>QuantumClifford.ECC.naive_encoding_circuit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Encoding physical qubits into a larger logical code.</p><p>The initial physical qubits to be encoded have to be at indices <code>n-k+1:n</code>.</p><div class="admonition is-info" id="Encoding-circuits-are-not-fault-tolerant-b464ac5e2ecb3c3c"><header class="admonition-header">Encoding circuits are not fault-tolerant<a class="admonition-anchor" href="#Encoding-circuits-are-not-fault-tolerant-b464ac5e2ecb3c3c" title="Permalink"></a></header><div class="admonition-body"><p>Encoding circuits are not fault-tolerant, and thus should not be used in practice. Instead, you should measure the stabilizers of the code and the logical observables, thus projecting into the code space (which can be fault-tolerant).</p></div></div><p>The canonicalization operation performed on the code may permute the qubits (see <a href="../API/#QuantumClifford.canonicalize_gott!-Tuple{Stabilizer}"><code>canonicalize_gott!</code></a>). That permutation is corrected for with SWAP gates by default (controlled by the <code>undoperm</code> keyword argument).</p><p>Based on (<a href="../references/#cleve1997efficient">Cleve and Gottesman, 1997</a>) and (<a href="../references/#gottesman1997stabilizer">Gottesman, 1997</a>), however it seems the published algorithm has some errors. Consult the erratum, as well as the more recent (<a href="../references/#grassl2002algorithmic">Grassl, 2002</a>) and (<a href="../references/#grassl2011variations">Grassl, 2011</a>), and be aware that this implementation also uses H instead of Z gates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/circuits.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.naive_syndrome_circuit" href="#QuantumClifford.ECC.naive_syndrome_circuit"><code>QuantumClifford.ECC.naive_syndrome_circuit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Generate the non-fault-tolerant stabilizer measurement cicuit for a given code instance or parity check tableau.</p><p>Use the <code>ancillary_index</code> and <code>bit_index</code> arguments to offset where the corresponding part the circuit starts.</p><p>Returns the circuit, the number of ancillary qubits that were added, and a list of bit indices that will store the measurement results.</p><p>See also: <a href="#QuantumClifford.ECC.shor_syndrome_circuit"><code>shor_syndrome_circuit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/circuits.jl#L85-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.parity_checks" href="#QuantumClifford.ECC.parity_checks"><code>QuantumClifford.ECC.parity_checks</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parity check tableau of a code.</p><p>See also: <a href="#QECCore.parity_matrix_x-Tuple{QECCore.AbstractECC}"><code>parity_matrix_x</code></a> and <a href="#QECCore.parity_matrix_z-Tuple{QECCore.AbstractECC}"><code>parity_matrix_z</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/ECC.jl#L49-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.random_all_to_all_circuit_code" href="#QuantumClifford.ECC.random_all_to_all_circuit_code"><code>QuantumClifford.ECC.random_all_to_all_circuit_code</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Random all-to-all Clifford circuit code (<a href="../references/#brown2013short">Brown and Fawzi, Jul 2013</a>).</p><p>The code of <code>n</code> qubits is generated by an all-to-all random Clifford circuit of <code>ngates</code> gates that encodes a subset of qubits <code>encode_qubits</code> into logical qubits.</p><p>Because of the random picking, the size of <code>encode_qubits</code> is the only thing that matters for the code, referred to as <code>k</code>.</p><p>See also: <a href="../API/#QuantumClifford.random_all_to_all_clifford_circuit-Tuple{Random.AbstractRNG, Int64, Int64}"><code>random_all_to_all_clifford_circuit</code></a>, <a href="#QuantumClifford.ECC.CircuitCode"><code>CircuitCode</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/codes/random_circuit.jl#L34-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.random_brickwork_circuit_code" href="#QuantumClifford.ECC.random_brickwork_circuit_code"><code>QuantumClifford.ECC.random_brickwork_circuit_code</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Random brickwork Clifford circuit code (<a href="../references/#brown2013short">Brown and Fawzi, Jul 2013</a>).</p><p>The code is generated by a brickwork random Clifford circuit of <code>nlayers</code> layers that encodes a subset of qubits <code>encode_qubits</code> into logical qubits.</p><p>See also: <a href="../API/#QuantumClifford.random_brickwork_clifford_circuit-Tuple{Random.AbstractRNG, NTuple{N, Int64} where N, Int64}"><code>random_brickwork_clifford_circuit</code></a>, <a href="#QuantumClifford.ECC.CircuitCode"><code>CircuitCode</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/codes/random_circuit.jl#L62-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.shor_syndrome_circuit" href="#QuantumClifford.ECC.shor_syndrome_circuit"><code>QuantumClifford.ECC.shor_syndrome_circuit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Generate the Shor fault-tolerant stabilizer measurement cicuit for a given code instance or parity check tableau.</p><p>Use the <code>ancillary_index</code> and <code>bit_index</code> arguments to offset where the corresponding part the circuit starts. Ancillary qubits</p><p>Returns:</p><ul><li>The ancillary cat state preparation circuit.</li><li>The Shor syndrome measurement circuit.</li><li>The number of ancillary qubits that were added.</li><li>The list of bit indices that store the final measurement results.</li></ul><p>See also: <a href="#QuantumClifford.ECC.naive_syndrome_circuit"><code>naive_syndrome_circuit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/circuits.jl#L140-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.two_block_group_algebra_codes" href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>QuantumClifford.ECC.two_block_group_algebra_codes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Hecke. Check the docs for the <a href="http://qc.quantumsavory.org/stable/ECC_API/#Implemented-in-an-extension-requiring-Hecke.jl">Hecke extension</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/codes/qeccs_using_hecke.jl#L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.twobga_from_direct_product" href="#QuantumClifford.ECC.twobga_from_direct_product"><code>QuantumClifford.ECC.twobga_from_direct_product</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Oscar. Check the docs for the <a href="http://qc.quantumsavory.org/stable/ECC_API/#Implemented-in-an-extension-requiring-Oscar.jl">Oscar extension</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/codes/qeccs_using_hecke.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.twobga_from_fp_group" href="#QuantumClifford.ECC.twobga_from_fp_group"><code>QuantumClifford.ECC.twobga_from_fp_group</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Oscar. Check the docs for the <a href="http://qc.quantumsavory.org/stable/ECC_API/#Implemented-in-an-extension-requiring-Oscar.jl">Oscar extension</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/src/ecc/codes/qeccs_using_hecke.jl#L27">source</a></section></article><h2 id="Implemented-in-an-extension-requiring-Hecke.jl"><a class="docs-heading-anchor" href="#Implemented-in-an-extension-requiring-Hecke.jl">Implemented in an extension requiring <code>Hecke.jl</code></a><a id="Implemented-in-an-extension-requiring-Hecke.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Implemented-in-an-extension-requiring-Hecke.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordHeckeExt.ExtendedGeneralizedBicycleCode" href="#QuantumCliffordHeckeExt.ExtendedGeneralizedBicycleCode"><code>QuantumCliffordHeckeExt.ExtendedGeneralizedBicycleCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ExtendedGeneralizedBicycleCode &lt;: QECCore.AbstractCSSCode</code></pre><p>The extended generalized bicycle code is a family of quantum LDPC codes generated through <em>algebraic extension</em> of a base <a href="#QuantumCliffordHeckeExt.GeneralizedBicycleCode"><code>GeneralizedBicycleCode</code></a>. Starting with initial generating polynomials <span>$a(x), b(x) \in \mathbb{F}_2^{\langle\ell\rangle}$</span>, the extended GB codes are constructed by polynomial multiplication, where for each extension step <span>$m$</span>, an extension polynomial </p><p class="math-container">\[\begin{aligned}
p^{(m)}(x) \in \mathbb{F}_2^{\langle\kappa_m\ell\rangle}
\end{aligned}\]</p><p>is selected to produce extended polynomials:</p><p class="math-container">\[\begin{aligned}
a^{(m)}(x) &amp;= p^{(m)}(x)a(x), \\
b^{(m)}(x) &amp;= p^{(m)}(x)b(x)
\end{aligned}\]</p><p>These extended polynomials are then used to form <span>$\kappa_m\ell \times \kappa_m\ell$</span> circulant matrices <span>$A_m$</span> and <span>$B_m$</span>, which are combined into a parity-check matrix <span>$H_m$</span> with block structure:</p><p class="math-container">\[\begin{aligned}
H_m = \begin{pmatrix} 
A_m|B_m &amp; 0 \\ 
0 &amp; B_m^\top|A_m^\top 
\end{aligned}\]</p><p>while maintaining dimensions:</p><p class="math-container">\[\begin{aligned}
k_m = 2\deg\left(\gcd\left(a^{(m)}, b^{(m)}, x^{\kappa_m\ell}-1\right)\right)
\end{aligned}\]</p><p>that are always bounded below by the base code dimension <code>k</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: polynomial_ring, GF, one, gen; using QuantumClifford.ECC;

julia&gt; R, x = polynomial_ring(GF(2), &quot;x&quot;);

julia&gt; l = 5;

julia&gt; a = 1 + x^4;

julia&gt; b = 1 + x + x^2 + x^4;

julia&gt; c = GeneralizedBicycleCode(a, b, l);

julia&gt; import HiGHS;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(10, 2, 3)

julia&gt; m, p = 4, one(R);

julia&gt; new_code = ExtendedGeneralizedBicycleCode(c, m, p);

julia&gt; code_n(new_code), code_k(new_code), distance(new_code, DistanceMIPAlgorithm(solver=HiGHS))
(40, 2, 5)

julia&gt; m, p = 4, 1 + x;

julia&gt; new_code = ExtendedGeneralizedBicycleCode(c, m, p);

julia&gt; code_n(new_code), code_k(new_code), distance(new_code, DistanceMIPAlgorithm(solver=HiGHS))
(40, 4, 5)</code></pre><div class="admonition is-info" id="Note-8ff62b182e95757d"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-8ff62b182e95757d" title="Permalink"></a></header><div class="admonition-body"><p>(<a href="../references/#koukoulekidis2024smallquantumcodesalgebraic">Koukoulekidis <em>et al.</em>, 2024</a>) establishes that <code>ℓ = 5</code> is the minimal lift size required to achieve quantum error-correcting codes with a minimum distance of <code>d ≥ 3</code>.</p></div></div><p><strong>Fields</strong></p><ul><li><p><code>base_code::QECCore.AbstractCSSCode</code>: The base generalized bicycle code to extend.</p></li><li><p><code>m::Int64</code>: The extension index (m ≥ 1)</p></li><li><p><code>p::Nemo.FqPolyRingElem</code>: The extension polynomial ∈ 𝔽₂[((m-1)ℓ +1)].</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/ext/QuantumCliffordHeckeExt/extended_generalized_bicycle.jl#L1-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordHeckeExt.GeneralizedBicycleCode" href="#QuantumCliffordHeckeExt.GeneralizedBicycleCode"><code>QuantumCliffordHeckeExt.GeneralizedBicycleCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GeneralizedBicycleCode &lt;: QECCore.AbstractCSSCode</code></pre><p>Generalized bicycle codes ((<a href="../references/#koukoulekidis2024smallquantumcodesalgebraic">Koukoulekidis <em>et al.</em>, 2024</a>))</p><p>A generalized bicycle quantum LDPC code constructed from two polynomials in <span>$\mathbb{F}_2[x]/(x^l - 1)$</span>.</p><p>Here is an example of a [[10, 2, 3]] GB code from the Appendix B of (<a href="../references/#koukoulekidis2024smallquantumcodesalgebraic">Koukoulekidis <em>et al.</em>, 2024</a>) with lift size of 5 build out of two polymonials in <span>$\mathbb{F}_2[x]/(x^l - 1)$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: polynomial_ring, GF; using QuantumClifford.ECC;

julia&gt; R, x = polynomial_ring(GF(2), &quot;x&quot;);

julia&gt; l = 5;

julia&gt; a = 1 + x^4;

julia&gt; b = 1 + x + x^2 + x^4;

julia&gt; c = GeneralizedBicycleCode(a, b, l);

julia&gt; import HiGHS;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(10, 2, 3)</code></pre><p>Here is an example of a [[12, 2, 3]] GB code from the Appendix B of (<a href="../references/#koukoulekidis2024smallquantumcodesalgebraic">Koukoulekidis <em>et al.</em>, 2024</a>) with lift size of 6 build out of two polymonials in <span>$\mathbb{F}_2[x]/(x^l - 1)$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: polynomial_ring, GF; using QuantumClifford.ECC;

julia&gt; R, x = polynomial_ring(GF(2), &quot;x&quot;);

julia&gt; l = 6;

julia&gt; a = 1 + x + x^2 + x^5;

julia&gt; b = 1 + x + x^3 + x^5;

julia&gt; c = GeneralizedBicycleCode(a, b, l);

julia&gt; import HiGHS;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(12, 2, 3)</code></pre><p>See also: <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a></p><p><strong>Fields</strong></p><ul><li><p><code>a::Nemo.FqPolyRingElem</code>: First generator polynomial in 𝔽₂[x]/(xˡ - 1).</p></li><li><p><code>b::Nemo.FqPolyRingElem</code>: Second generator polynomial in 𝔽₂[x]/(xˡ - 1).</p></li><li><p><code>l::Int64</code>: The lift size which corresponds to dimension of circulant matrices.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/ext/QuantumCliffordHeckeExt/generalized_bicycle.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordHeckeExt.GeneralizedHyperGraphProductCode" href="#QuantumCliffordHeckeExt.GeneralizedHyperGraphProductCode"><code>QuantumCliffordHeckeExt.GeneralizedHyperGraphProductCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GeneralizedHyperGraphProductCode &lt;: QECCore.AbstractCSSCode</code></pre><p>A Generalized Hypergraph Product (GHP) CSS code introduced in (<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>).</p><p>The GHP code is constructed from a matrix <span>$A \in M_{m \times n}(R)$</span>, where <span>$R \subseteq M_\ell(\mathbb{F}_2)$</span> is a ring of binary circulant matrices, and a binary matrix <span>$b \in M_\ell(\mathbb{F}_2)$</span> such that every element of <span>$R$</span> commutes with <span>$b$</span>. The code is defined by the block parity-check matrices:</p><p class="math-container">\[\begin{aligned}
    H_X = \begin{bmatrix} A &amp; b \cdot I_m \end{bmatrix}, \quad
    H_Z = \begin{bmatrix} b^T \cdot I_n &amp; A^* \end{bmatrix}
\end{aligned}\]</p><p>where <span>$A^*$</span> is the transpose of <span>$A$</span> with each entry polynomial-reversed modulo <span>$x^\ell - 1$</span>, and <span>$I_m, I_n$</span> are identity matrices over <span>$R$</span>.</p><p>Here is an example of <code>[[882, 24, 18 ≤ d ≤ 24]]</code> code from Appendix B of (<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: polynomial_ring, GF, quo, matrix; using QuantumClifford.ECC;

julia&gt; R, x = polynomial_ring(GF(2), :x);

julia&gt; l = 63; n = 7;

julia&gt; S, _ =  quo(R, x^l - 1);

julia&gt; A = matrix(S, n, n,
           [x^27  0     0     0     0     1     x^54
            x^54  x^27  0     0     0     0     1
            1     x^54  x^27  0     0     0     0
            0     1     x^54  x^27  0     0     0
            0     0     1     x^54  x^27  0     0
            0     0     0     1     x^54  x^27  0
            0     0     0     0     1     x^54  x^27]);

julia&gt; b = S(1 + x + x^6);

julia&gt; c = GeneralizedHyperGraphProductCode(A, b, l);

julia&gt; code_n(c), code_k(c)
(882, 24)</code></pre><p>Here is an example of <code>[[1270, 28, 16 ≤ d ≤ 46]]</code> code from Appendix B of (<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: polynomial_ring, GF, quo, matrix; using QuantumClifford.ECC;

julia&gt; R, x = polynomial_ring(GF(2), :x);

julia&gt; l = 127; n = 5;

julia&gt; S, _ =  quo(R, x^l - 1);

julia&gt; A = matrix(S, n, n,
           [1     0     x^51  x^52  0
            0     1     0     x^111 x^20
            1     0     x^98  0     x^122
            1     x^80  0     x^119 0 
            0     1     x^5   0     x^106]);

julia&gt; b = S(1 + x + x^7);

julia&gt; c = GeneralizedHyperGraphProductCode(A, b, l);

julia&gt; code_n(c), code_k(c)
(1270, 28)</code></pre><p><strong>Fields</strong></p><ul><li><p><code>A::AbstractAlgebra.Generic.MatSpaceElem{AbstractAlgebra.Generic.EuclideanRingResidueRingElem{Nemo.FqPolyRingElem}}</code>: The matrix <span>$A \in M_{n \times n}(R)$</span>, where <span>$R = \mathbb{F}_2[x]/(x^\ell - 1)$</span>. Each entry in <code>A</code> represents a polynomial modulo <span>$x^\ell - 1$</span>, defining a circulant block.</p></li><li><p><code>b::AbstractAlgebra.Generic.EuclideanRingResidueRingElem{Nemo.FqPolyRingElem}</code>: The polynomial <span>$b(x) \in R$</span>, generating a binary circulant matrix that commutes with all elements of <code>R</code>.</p></li><li><p><code>l::Int64</code>: The number of rows and columns in each binary circulant block.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/ext/QuantumCliffordHeckeExt/generalized_hypergraph_product.jl#L1-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordHeckeExt.LPCode" href="#QuantumCliffordHeckeExt.LPCode"><code>QuantumCliffordHeckeExt.LPCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LPCode &lt;: QECCore.AbstractECC</code></pre><p>Lifted product codes ((<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>), (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>))</p><p>A lifted product code is defined by the hypergraph product of a base matrices <code>A</code> and the conjugate of another base matrix <code>B&#39;</code>. Here, the hypergraph product is taken over a group algebra, of which the base matrices are consisting.</p><p>The binary parity check matrices are obtained by applying <code>A_repr</code> and <code>B_repr</code> representation maps to each element of the base matrices. These linear transformations convert group algebra elements to their matrix representations while preserving the CSS orthogonality condition.</p><p><strong>Mathematical Framework</strong></p><p>Given classical parity-check matrices:</p><ul><li><p><span>$A \in \mathbb{F}_q^{m_a \times n_a}$</span></p></li><li><p><span>$B \in \mathbb{F}_q^{m_b \times n_b}$</span></p></li></ul><p>The lifted product construction produces quantum CSS codes with parity-check matrices:</p><p class="math-container">\[\begin{aligned}
    H_X &amp;= [A \otimes I_{m_b}, -I_{m_a} \otimes B] \\
    H_Z &amp;= [I_{n_a} \otimes B^*, A^* \otimes I_{n_b}]
\end{aligned}\]</p><p><strong>Commutative Group Algebra</strong></p><p>When <code>R</code> is <em>commutative</em>, a single representation suffices since all elements naturally commute. Here <span>$\rho(a) = \lambda(a)$</span> for all <span>$a \in R$</span>.</p><p><strong>Non-Commutative Group Algebra</strong></p><p>When <code>R</code> is <em>non-commutative</em>, distinct representations are essential:</p><ul><li><p><code>A_repr</code> implements the right regular representation: <span>$\rho(a)x = xa$</span></p></li><li><p><code>B_repr</code> implements the left regular representation: <span>$\lambda(b)x = bx$</span></p></li></ul><p>These ensure the critical commutation relation:</p><p class="math-container">\[\begin{aligned}
    \rho(a)\lambda(b) = \lambda(b)\rho(a)
\end{aligned}\]</p><p>which follows from the <em>associative</em> property:</p><p class="math-container">\[\begin{aligned}
    \rho(a)\lambda(b)(x) = b(xa) = (bx)a = \lambda(b)\rho(a)(x)
\end{aligned}\]</p><p><strong>Constructors</strong></p><p>Multiple constructors are available:</p><ol><li><p>Two base matrices of group algebra elements.</p></li><li><p>Two lifted codes, whose base matrices are for quantum code construction.</p></li><li><p>Two base matrices of group elements, where each group element will be considered as a group algebra element by assigning a unit coefficient.</p></li><li><p>Two base matrices of integers, where each integer represent the shift of a cyclic permutation. The order of the cyclic permutation should be specified.</p></li></ol><p>Below is a list of all constructors:</p><pre><code class="language-julia hljs">LPCode(A, B; GA, A_repr, B_repr, repr)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/0c696665bf6899e9eef2735f06c173528d07f4fa//ext/QuantumCliffordHeckeExt/lifted_product.jl#L158"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted_product.jl:158</code></a>.</p><pre><code class="language-julia hljs">LPCode(c₁, c₂; GA, A_repr, B_repr, repr)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/0c696665bf6899e9eef2735f06c173528d07f4fa//ext/QuantumCliffordHeckeExt/lifted_product.jl#L175"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted_product.jl:175</code></a>.</p><pre><code class="language-julia hljs">LPCode(A, B; GA)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/0c696665bf6899e9eef2735f06c173528d07f4fa//ext/QuantumCliffordHeckeExt/lifted_product.jl#L195"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted_product.jl:195</code></a>.</p><pre><code class="language-julia hljs">LPCode(group_elem_array1, group_elem_array2; GA)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/0c696665bf6899e9eef2735f06c173528d07f4fa//ext/QuantumCliffordHeckeExt/lifted_product.jl#L203"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted_product.jl:203</code></a>.</p><pre><code class="language-julia hljs">LPCode(shift_array1, shift_array2, l; GA)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/0c696665bf6899e9eef2735f06c173528d07f4fa//ext/QuantumCliffordHeckeExt/lifted_product.jl#L211"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted_product.jl:211</code></a>.</p><p><strong>Examples</strong></p><p>A [[882, 24, d ≤ 24]] code from Appendix B of (<a href="../references/#roffe2023bias">Roffe <em>et al.</em>, 2023</a>). We use the 1st constructor to generate the code and check its length and dimension. During the construction, we do arithmetic operations to get the group algebra elements in base matrices <code>A</code> and <code>B</code>. Here <code>x</code> is the generator of the group algebra, i.e., offset-1 cyclic permutation, and <code>GA(1)</code> is the unit element.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; import LinearAlgebra: diagind; using QuantumClifford.ECC;

julia&gt; l = 63; GA = group_algebra(GF(2), abelian_group(l)); x = gens(GA)[];

julia&gt; A = zeros(GA, 7, 7);

julia&gt; A[diagind(A)] .= x^27;

julia&gt; A[diagind(A, -1)] .= x^54;

julia&gt; A[diagind(A, 6)] .= x^54;

julia&gt; A[diagind(A, -2)] .= GA(1);

julia&gt; A[diagind(A, 5)] .= GA(1);

julia&gt; B = reshape([1 + x + x^6], (1, 1));

julia&gt; c1 = LPCode(A, B);

julia&gt; code_n(c1), code_k(c1)
(882, 24)</code></pre><p>A [[175, 19, d ≤ 10]] code from Eq. (18) in Appendix A of (<a href="../references/#raveendran2022finite">Raveendran <em>et al.</em>, 2022</a>), following the 4th constructor.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke; using QuantumClifford.ECC;

julia&gt; base_matrix = [0 0 0 0; 0 1 2 5; 0 6 3 1]; l = 7;

julia&gt; c2 = LPCode(base_matrix, l .- base_matrix&#39;, l);

julia&gt; code_n(c2), code_k(c2)
(175, 19)</code></pre><p><strong>Code subfamilies and convenience constructors for them</strong></p><ul><li>When the base matrices of the <code>LPCode</code> are 1×1, the code is called a two-block group-algebra code <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>.</li><li>When the base matrices of the <code>LPCode</code> are 1×1 and their elements are sums of cyclic permutations, the code is called a generalized bicycle code <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>.</li><li>When the two matrices are adjoint to each other, the code is called a bicycle code <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>.</li></ul><p><strong>The representation function</strong></p><p>We use the default representation function <code>Hecke.representation_matrix</code> to convert a <code>GF(2)</code>-group algebra element to a binary matrix. The default representation, provided by <code>Hecke</code>, is the permutation representation.</p><p>We also accept a custom representation function as detailed in <a href="#QuantumCliffordHeckeExt.LiftedCode"><code>LiftedCode</code></a>.</p><p>See also: <a href="#QuantumCliffordHeckeExt.LiftedCode"><code>LiftedCode</code></a>, <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.haah_cubic_codes"><code>haah_cubic_codes</code></a>.</p><p>All fields:</p><ul><li><p><code>A::Union{LinearAlgebra.Adjoint{&lt;:Hecke.GroupAlgebraElem, &lt;:Matrix{&lt;:Hecke.GroupAlgebraElem}}, Matrix{&lt;:Hecke.GroupAlgebraElem}}</code>: the first base matrix of the code, whose elements are in a group algebra.</p></li><li><p><code>B::Union{LinearAlgebra.Adjoint{&lt;:Hecke.GroupAlgebraElem, &lt;:Matrix{&lt;:Hecke.GroupAlgebraElem}}, Matrix{&lt;:Hecke.GroupAlgebraElem}}</code>: the second base matrix of the code, whose elements are in the same group algebra as <code>A</code>.</p></li><li><p><code>GA::Hecke.GroupAlgebra</code>: the group algebra for which elements in <code>A</code> and <code>B</code> are from.</p></li><li><p><code>A_repr::Function</code>: a function that converts a group algebra element to a binary matrix for <code>A</code>; default to be the right regular representation for <code>GF(2)</code>-algebra.</p></li><li><p><code>B_repr::Function</code>: a function that converts a group algebra element to a binary matrix for B; default to be the left regular representation for <code>GF(2)</code>-algebra.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/ext/QuantumCliffordHeckeExt/lifted_product.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordHeckeExt.LaCross" href="#QuantumCliffordHeckeExt.LaCross"><code>QuantumCliffordHeckeExt.LaCross</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LaCross &lt;: QECCore.AbstractCSSCode</code></pre><p>The <strong>La-cross</strong> code is a quantum LDPC code constructed using the hypergraph product of two classical seed LDPC codes. It is characterized by its parity check matrix <code>H</code>, which is derived from <strong>circulant</strong> matrices with <em>specific</em> properties. These codes were introduced in (<a href="../references/#pecorari2025high">Pecorari <em>et al.</em>, 2025</a>).</p><p>The La-cross code has two families, distinguished by their boundary conditions:</p><ul><li><strong>Periodic</strong> boundary (<code>full_rank = false</code>):</li></ul><p class="math-container">\[\begin{aligned}
\left[\left[2n^2, 2k^2, d \right]\right]
\end{aligned}\]</p><ul><li><strong>Open</strong> boundary (<code>full_rank = true</code>): </li></ul><p class="math-container">\[\begin{aligned}
\left[\left[(n - k)^2 + n^2, k^2, d \right]\right]
\end{aligned}\]</p><div class="admonition is-info" id="Note-53d8e7ea10d62145"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-53d8e7ea10d62145" title="Permalink"></a></header><div class="admonition-body"><p>When <code>H</code> is square and circulant (<code>full_rank=false</code>), classical checks connect opposite endpoints of the <code>length-n</code> classical code and give rise to a quantum code with stabilizers connecting opposite array boundaries, i.e. with <strong>periodic boundary conditions</strong>. On the contrary, <strong>rectangular</strong> parity-check matrices in <span>$\mathbb{F}_2^{(n−k)×n}$</span> give rise to a quantum code with stabilizers stretching up to the array extent, i.e. with <strong>open boundary conditions</strong>.</p></div></div><p><strong>Cyclic Codes and Circulant Matrices</strong></p><p>A <strong>cyclic code</strong> is a linear code in which codewords remain valid under cyclic shifts. A <strong>circulant matrix</strong> is a square matrix where each row is a cyclic shift of the first row. When the parity-check matrix <code>H</code> is circulant, the code is fully determined by its first row:</p><p class="math-container">\[\begin{aligned}
H = \text{circ}(c_0, c_1, \dots, c_k, 0, \dots, 0) \in \mathbb{F}_2^{n \times n}.
\end{aligned}\]</p><p>The elements <span>$c_i$</span> (for <span>$i = 0, 1, \dots, k$</span>) correspond to the coefficients of a <span>$degree-k$</span> polynomial:</p><p class="math-container">\[\begin{aligned}
h(x) = 1 + \sum_{i=1}^{k} c_i x^i \in \mathbb{F}_2[x]/(x^n - 1).
\end{aligned}\]</p><p>This establishes a mapping between <span>$\mathbb{F}_2^n$</span> and the quotient ring <span>$\mathbb{F}_2[x]/(x^n - 1)$</span>, where cyclic shifts in <span>$\mathbb{F}_2^n$</span> correspond to multiplications by <code>x</code> in the polynomial ring. Since multiplication by <code>x</code> preserves the ideal structure of <span>$\mathbb{F}_2[x]/(x^n - 1)$</span>, cyclic codes correspond to ideals in this ring. These ideals are in one-to-one correspondence with unitary <span>$mod-2$</span> divisors of <span>$x^n - 1$</span> with a leading coefficient of 1. Consequently, the fundamental building blocks of cyclic codes correspond to the factorization of <span>$x^n - 1$</span>.</p><div class="admonition is-info" id="Note-8129c2ecc6b7952c"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-8129c2ecc6b7952c" title="Permalink"></a></header><div class="admonition-body"><p>For <code>k = 1</code>, the generator polynomial <span>$h(x) = 1 + x$</span> defines the <strong>repetition code</strong>.</p></div></div><p><strong>Polynomial Representation</strong></p><p>The first row of a circulant matrix <span>$H = \text{circ}(c_0, c_1, c_2, \dots, c_{n-1})$</span> can be mapped to the coefficients of a polynomial <span>$h(x)$</span>. For instance, if the first row is <span>$[1, 1, 0, 1]$</span>, the polynomial is: <span>$h(x) = 1 + x + x^3$</span>. This polynomial-based representation aids in the analysis and design of cyclic codes. For our implementation of La-cross codes, we leverage <code>Hecke.polynomial_ring</code> to work directly with polynomial rings rather than manipulating coefficient arrays explicitly.</p><div class="admonition is-info" id="Note-de2b566ba6c895d"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-de2b566ba6c895d" title="Permalink"></a></header><div class="admonition-body"><p>The <strong>next-to-next-to-nearest neighbor</strong> connectivity implies the use of a <em>degree-3</em> seed polynomial <span>$h(x) = 1 + x + x^2 + x^3$</span> in the ring <span>$\mathbb{F}_2[x]/(x^n - 1)$</span> for a specific code length <code>n</code>. Additionally, the condition of low stabilizer weight requires the polynomial <span>$1 + x + x^3$</span>.</p></div></div><p><strong>[[2n², 2k², d]] La-cross Code</strong></p><p>Here is <code>[[98, 18, 4]]</code> La-cross code from with <span>$h(x) = 1 + x + x^3$</span>, <code>n = 7</code>, and <code>k = 3</code> from Appendix A of (<a href="../references/#pecorari2025high">Pecorari <em>et al.</em>, 2025</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford; using QuantumClifford.ECC; # hide

julia&gt; import Hecke: GF, polynomial_ring;

julia&gt; n = 7; k = 3; F = GF(2);

julia&gt; R, x = polynomial_ring(F, &quot;x&quot;);

julia&gt; h = 1 + x + x^k;

julia&gt; c = LaCross(n, h, false);

julia&gt; import HiGHS;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(98, 18, 4)</code></pre><p><strong>[[(n - k)² + n², k², d]] La-cross Code</strong></p><p>Here is <code>[[65, 9, 4]]</code> La-cross code from with <span>$h(x) = 1 + x + x^3$</span>, <code>n = 7</code>, <code>k = 3</code> and full rank seed <em>rectangular</em> circulant matrix from Appendix A of (<a href="../references/#pecorari2025high">Pecorari <em>et al.</em>, 2025</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; c = LaCross(n, h, true);

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(65, 9, 4)</code></pre><p>Here is <code>[[400, 16, 8]]</code> La-cross code from with <span>$h(x) = 1 + x + x^4$</span>, <code>n = 16</code>, <code>k = 4</code> from (<a href="../references/#pecorari2025high">Pecorari <em>et al.</em>, 2025</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; n = 16; k = 4;

julia&gt; R, x = polynomial_ring(F, &quot;x&quot;);

julia&gt; h = 1 + x + x^k;

julia&gt; full_rank = true;

julia&gt; c = LaCross(n, h, full_rank);

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(400, 16, 8)</code></pre><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/lacross">entry for this family</a>.</p><p><strong>Fields</strong></p><ul><li><p><code>n::Int64</code>: The block length of the classical seed code.</p></li><li><p><code>h::Nemo.FqPolyRingElem</code>: The seed vector is represented with a degree-<code>n</code> polynomial of the form <span>$h(x) = \sum_{i=0}^{n-1} c_i x^i$</span>.</p></li><li><p><code>full_rank::Bool</code>: A flag indicating whether to use the full-rank rectangular matrix (<code>true</code>) or the original circulant matrix (<code>false</code>).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/ext/QuantumCliffordHeckeExt/lacross.jl#L1-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordHeckeExt.LiftedCode" href="#QuantumCliffordHeckeExt.LiftedCode"><code>QuantumCliffordHeckeExt.LiftedCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LiftedCode &lt;: QECCore.AbstractCECC</code></pre><p>Classical codes lifted over a group algebra, used for lifted product code construction ((<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>), (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>))</p><p>The parity-check matrix is constructed by applying <code>repr</code> to each element of <code>A</code>, which is mathematically a linear map from a group algebra element to a binary matrix. The size of the parity check matrix will enlarged with each element of <code>A</code> being inflated into a matrix. The procedure is called a lift (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>).</p><p><strong>Constructors</strong></p><p>A lifted code can be constructed via the following approaches:</p><ol><li><p>A matrix of group algebra elements.</p></li><li><p>A matrix of group elements, where a group element will be considered as a group algebra element by assigning a unit coefficient.</p></li><li><p>A matrix of integers, where each integer represent the shift of a cyclic permutation. The order of the cyclic permutation should be specified.</p></li></ol><p>The default <code>GA</code> is the group algebra of <code>A[1, 1]</code>, the default representation <code>repr</code> is the permutation representation.</p><p>Below is a list of all constructors:</p><pre><code class="language-julia hljs">LiftedCode(A; GA, repr)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/0c696665bf6899e9eef2735f06c173528d07f4fa//ext/QuantumCliffordHeckeExt/lifted.jl#L58"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted.jl:58</code></a>.</p><pre><code class="language-julia hljs">LiftedCode(A; GA)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/0c696665bf6899e9eef2735f06c173528d07f4fa//ext/QuantumCliffordHeckeExt/lifted.jl#L68"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted.jl:68</code></a>.</p><pre><code class="language-julia hljs">LiftedCode(group_elem_array; GA, repr)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/0c696665bf6899e9eef2735f06c173528d07f4fa//ext/QuantumCliffordHeckeExt/lifted.jl#L74"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted.jl:74</code></a>.</p><pre><code class="language-julia hljs">LiftedCode(shift_array, l; GA, repr)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/0c696665bf6899e9eef2735f06c173528d07f4fa//ext/QuantumCliffordHeckeExt/lifted.jl#L87"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted.jl:87</code></a>.</p><p><strong>The representation function <code>repr</code></strong></p><p>We use the default representation function <code>Hecke.representation_matrix</code> to convert a <code>GF(2)</code>-group algebra element to a binary matrix. The default representation, provided by <code>Hecke</code>, is the permutation representation.</p><p>We also accept a custom representation function (the <code>repr</code> field of the constructor). Whatever the representation, the matrix elements need to be convertible to Integers (e.g. permit <code>lift(ZZ, ...)</code>). Such a customization would be useful to reduce the number of bits required by the code construction.</p><p>For example, if we use a D4 group for lifting, our default representation will be <code>8×8</code> permutation matrices, where 8 is the group&#39;s order. However, we can find a <code>4×4</code> matrix representation for the group, e.g. by using the typical <a href="https://en.wikipedia.org/wiki/Dihedral_group"><code>2×2</code> representation</a> and converting it into binary representation by replacing &quot;1&quot; with the Pauli I, and &quot;-1&quot; with the Pauli X matrix.</p><p>See also: <a href="#QuantumClifford.ECC.LPCode-Tuple"><code>QuantumClifford.ECC.LPCode</code></a>.</p><p>All fields:</p><ul><li><p><code>A::Union{LinearAlgebra.Adjoint{&lt;:Hecke.GroupAlgebraElem, &lt;:Matrix{&lt;:Hecke.GroupAlgebraElem}}, Matrix{&lt;:Hecke.GroupAlgebraElem}}</code>: the base matrix of the code, whose elements are in a group algebra.</p></li><li><p><code>GA::Hecke.GroupAlgebra</code>: the group algebra for which elements in <code>A</code> are from.</p></li><li><p><code>repr::Function</code>: a function that converts a group algebra element to a binary matrix; default to be the permutation representation for GF(2)-algebra.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/ext/QuantumCliffordHeckeExt/lifted.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.bicycle_codes-Tuple{Array{Int64}, Int64}" href="#QuantumClifford.ECC.bicycle_codes-Tuple{Array{Int64}, Int64}"><code>QuantumClifford.ECC.bicycle_codes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bicycle_codes(a_shifts::Array{Int64}, l::Int64) -&gt; Any
</code></pre><p>Bicycle codes are a special case of generalized bicycle codes, where <code>a</code> and <code>b</code> are conjugate to each other. The order of the cyclic group is <code>l</code>, and the shifts <code>a_shifts</code> and <code>b_shifts</code> are reverse to each other. Thus you need to provide only the <code>a_shifts</code> and the rest of the conversions and conjugations are taken care of.</p><p>See also: <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.haah_cubic_codes"><code>haah_cubic_codes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/ext/QuantumCliffordHeckeExt/lifted_product.jl#L446">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.generalized_bicycle_codes-Tuple{Array{Int64}, Array{Int64}, Int64}" href="#QuantumClifford.ECC.generalized_bicycle_codes-Tuple{Array{Int64}, Array{Int64}, Int64}"><code>QuantumClifford.ECC.generalized_bicycle_codes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generalized_bicycle_codes(
    a_shifts::Array{Int64},
    b_shifts::Array{Int64},
    l::Int64
) -&gt; Any
</code></pre><p>Generalized bicycle codes, which are a special case of <em>abelian</em> 2GBA codes (and therefore of lifted product codes). Here the group is chosen as the cyclic group of order <code>l</code>, and the base matrices <code>a</code> and <code>b</code> are the sum of the group algebra elements corresponding to the shifts <code>a_shifts</code> and <code>b_shifts</code>.</p><p>Behind the scenes, the shifts are converted to the corresponding group algebra elements and piped to <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>.</p><p>See also: <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>.</p><p><strong>Examples</strong></p><p>A [[254, 28, 14 ≤ d ≤ 20]] code from (A1) in Appendix B of (<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke; using QuantumClifford.ECC

julia&gt; c = generalized_bicycle_codes([0, 15, 20, 28, 66], [0, 58, 59, 100, 121], 127);

julia&gt; code_n(c), code_k(c)
(254, 28)</code></pre><p>An [[70, 8, 10]] <em>abelian</em> 2BGA code from Table 1 of (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>), with cyclic group of order <code>l = 35</code>, illustrates that <em>abelian</em> 2BGA codes can be viewed as GB codes.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke; using QuantumClifford.ECC

julia&gt; l = 35;

julia&gt; c1 = generalized_bicycle_codes([0, 15, 16, 18], [0, 1, 24, 27], l);

julia&gt; code_n(c1), code_k(c1)
(70, 8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/ext/QuantumCliffordHeckeExt/lifted_product.jl#L401">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.haah_cubic_codes-Tuple{Array{Int64}, Array{Int64}, Int64}" href="#QuantumClifford.ECC.haah_cubic_codes-Tuple{Array{Int64}, Array{Int64}, Int64}"><code>QuantumClifford.ECC.haah_cubic_codes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">haah_cubic_codes(
    a_shifts::Array{Int64},
    b_shifts::Array{Int64},
    l::Int64
) -&gt; Any
</code></pre><p>Haah’s cubic codes (<a href="../references/#haah2011local">Haah, 2011</a>) can be viewed as generalized bicycle (GB) codes with the group <code>G = Cₗ × Cₗ × Cₗ</code>, where <code>l</code> denotes the lattice size. In particular, a GB code with the group <code>G = ℤ₃ˣ³</code> corresponds to a cubic code.</p><p>Behind the scenes, this function is just a simple shortcut for preparing the group <code>G</code>, before piping the arguments to <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>.</p><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/haah_cubic">entry for this family</a>.</p><p>See also: <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke; using QuantumClifford.ECC;

julia&gt; c = haah_cubic_codes([0, 15, 20, 28, 66], [0, 58, 59, 100, 121], 6);

julia&gt; code_n(c), code_k(c)
(432, 8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/ext/QuantumCliffordHeckeExt/lifted_product.jl#L462">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.haah_cubic_codes-Tuple{Int64}" href="#QuantumClifford.ECC.haah_cubic_codes-Tuple{Int64}"><code>QuantumClifford.ECC.haah_cubic_codes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Haah’s cubic code is defined as <span>$\text{LP}(1 + x + y + z, 1 + xy + xz + yz)$</span> where <span>$\text{LP}$</span> is the lifted product code, and <code>x</code>, <code>y</code>, <code>z</code> are elements of the ring <span>$R = \mathbb{F}_2[x, y, z] / (x^L - 1, y^L - 1, z^L - 1)$</span>. Here <span>$\mathbb{F}_2$</span> is the finite field of order <code>2</code> and <code>L</code> is the lattice size. The ring <span>$R$</span> is the group algebra <span>$\mathbb{F}_qG$</span> of a finite group <code>G</code>, where <span>$G = (C_L)^3$</span> and <span>$C_L$</span> is the cyclic group of order <code>L</code>. This method of Haah&#39;s cubic code construction is outlined in Appendix B of (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>).</p><p>Here is an example of a <code>[[1024, 30, 13 ≤ d ≤ 32]]</code> Haah&#39;s cubic code from Appendix B, code D of (<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>) on the <code>8 × 8 × 8</code> Lattice.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke; using QuantumClifford.ECC;

julia&gt; l = 8;

julia&gt; c = haah_cubic_codes(l);

julia&gt; code_n(c), code_k(c)
(1024, 30)</code></pre><p>See also: <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.honeycomb_color_codes"><code>honeycomb_color_codes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/ext/QuantumCliffordHeckeExt/lifted_product.jl#L494-L519">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.honeycomb_color_codes-Tuple{Int64, Int64}" href="#QuantumClifford.ECC.honeycomb_color_codes-Tuple{Int64, Int64}"><code>QuantumClifford.ECC.honeycomb_color_codes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The honeycomb color codes (<a href="../references/#eberhardt2024logical">Eberhardt and Steffan, 2024</a>) are exactly the Bivariate Bicycle (BB) codes defined by the polynomials <code>c = 1 + x + xy</code> and <code>d = 1 + y + xy</code>, provided that both <code>ℓ</code> and <code>m</code> are divisible by three. This <code>6.6.6</code> code is an example of BB code, as it represents a special case.</p><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/triangular_color">entry for this family</a>.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke; using QuantumClifford.ECC;

julia&gt; ℓ = 9; m = 6;

julia&gt; c = honeycomb_color_codes(ℓ, m);

julia&gt; code_n(c), code_k(c)
(108, 4)</code></pre><p>See also: <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.honeycomb_color_codes"><code>honeycomb_color_codes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/ext/QuantumCliffordHeckeExt/lifted_product.jl#L528-L549">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.two_block_group_algebra_codes-Tuple{Hecke.GroupAlgebraElem, Hecke.GroupAlgebraElem}" href="#QuantumClifford.ECC.two_block_group_algebra_codes-Tuple{Hecke.GroupAlgebraElem, Hecke.GroupAlgebraElem}"><code>QuantumClifford.ECC.two_block_group_algebra_codes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">two_block_group_algebra_codes(
    a::Hecke.GroupAlgebraElem,
    b::Hecke.GroupAlgebraElem
) -&gt; Any
</code></pre><p>Two-block group algebra (2BGA) codes, which are a special case of lifted product codes from two group algebra elements <code>a</code> and <code>b</code>, used as <code>1×1</code> base matrices. To build them, you pick a group and specific generators for that group, then you pick two polynomials made of the group generators, and then, behind the scenes, these two polynomials <code>a</code> and <code>b</code> are piped to the lifted product code constructor as the elements of <code>1×1</code> matrices.</p><p>See also: <a href="#QuantumCliffordHeckeExt.LPCode"><code>LPCode</code></a>, <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.haah_cubic_codes"><code>haah_cubic_codes</code></a>, <a href="#QuantumClifford.ECC.honeycomb_color_codes"><code>honeycomb_color_codes</code></a>.</p><p><strong>Examples of 2BGA code subfamilies</strong></p><p><strong><code>C₄ x C₂</code></strong></p><p>Here is an example of a [[56, 28, 2]] 2BGA code from Table 2 of (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>) build out of polymonials of generators of the direct product <code>C₄ × C₂</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; using QuantumClifford.ECC;

julia&gt; GA = group_algebra(GF(2), abelian_group([14,2]));

julia&gt; x, s = gens(GA);

julia&gt; A = 1 + x^7;

julia&gt; B = 1 + x^7 + s + x^8 + s*x^7 + x;

julia&gt; c = two_block_group_algebra_codes(A,B);

julia&gt; import HiGHS;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(56, 28, 2)</code></pre><p><strong>Bivariate Bicycle codes</strong></p><p>Bivariate Bicycle codes are a class of Abelian 2BGA codes formed by the direct product of two cyclic groups <code>ℤₗ × ℤₘ</code>. The parameters <code>l</code> and <code>m</code> represent the orders of the first and second cyclic groups, respectively.</p><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/qcga">entry for this family</a>.</p><p>A [[756, 16, ≤ 34]] code from Table 3 of (<a href="../references/#bravyi2024high">Bravyi <em>et al.</em>, 2024</a>):</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; using QuantumClifford.ECC;

julia&gt; l=21; m=18;

julia&gt; GA = group_algebra(GF(2), abelian_group([l, m]));

julia&gt; x, y = gens(GA);

julia&gt; A = x^3 + y^10 + y^17;

julia&gt; B = y^5 + x^3  + x^19;

julia&gt; c = two_block_group_algebra_codes(A,B);

julia&gt; code_n(c), code_k(c)
(756, 16)</code></pre><p><strong>Multivariate Bicycle code</strong></p><p>The group algebra of the qubit multivariate bicycle (MB) code with r variables is <code>𝔽₂[𝐺ᵣ]</code>, where <code>𝐺ᵣ = ℤ/l₁ × ℤ/l₂ × ... × ℤ/lᵣ</code>.</p><p>A [[48, 4, 6]] Weight-6 TB-QLDPC code from Appendix A Table 2 of (<a href="../references/#voss2024multivariatebicyclecodes">Voss <em>et al.</em>, 2024</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; using QuantumClifford.ECC;

julia&gt; l=4; m=6;

julia&gt; GA = group_algebra(GF(2), abelian_group([l, m]));

julia&gt; x, y = gens(GA);

julia&gt; z = x*y;

julia&gt; A = x^3 + y^5;

julia&gt; B = x + z^5 + y^5 + y^2;

julia&gt; c = two_block_group_algebra_codes(A, B);

julia&gt; import HiGHS

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(48, 4, 6)</code></pre><p><strong>Coprime Bivariate Bicycle code</strong></p><p>The coprime bivariate bicycle (BB) codes are defined by two polynomials <code>𝑎(𝑥,𝑦)</code> and <code>𝑏(𝑥,𝑦)</code>, where <code>𝑙</code> and <code>𝑚</code> are coprime, and can be expressed as univariate polynomials <code>𝑎(𝜋)</code> and <code>𝑏(𝜋)</code>, with generator <code>𝜋 = 𝑥𝑦</code>. They can be viewed as a special case of Lifted Product construction based on abelian group <code>ℤₗ x ℤₘ</code> where <code>ℤⱼ</code> cyclic group of order <code>j</code>.</p><p>[[108, 12, 6]] coprime-bivariate bicycle (BB) code from Table 2 of (<a href="../references/#wang2024coprime">Wang and Mueller, 2024</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; using QuantumClifford.ECC;

julia&gt; l=2; m=27;

julia&gt; GA = group_algebra(GF(2), abelian_group([l*m]));

julia&gt; 𝜋 = gens(GA)[1];

julia&gt; A = 𝜋^2 + 𝜋^5  + 𝜋^44;

julia&gt; B = 𝜋^8 + 𝜋^14 + 𝜋^47;

julia&gt; c = two_block_group_algebra_codes(A, B);

julia&gt; import HiGHS

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(108, 12, 6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/ext/QuantumCliffordHeckeExt/lifted_product.jl#L269">source</a></section></article><h2 id="Implemented-in-an-extension-requiring-Oscar.jl"><a class="docs-heading-anchor" href="#Implemented-in-an-extension-requiring-Oscar.jl">Implemented in an extension requiring <code>Oscar.jl</code></a><a id="Implemented-in-an-extension-requiring-Oscar.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Implemented-in-an-extension-requiring-Oscar.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordOscarExt.DDimensionalSurfaceCode" href="#QuantumCliffordOscarExt.DDimensionalSurfaceCode"><code>QuantumCliffordOscarExt.DDimensionalSurfaceCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DDimensionalSurfaceCode &lt;: QuantumCliffordOscarExt.DDimensionalCode</code></pre><p>Constructs the <code>D</code>-dimensional surface code using <a href="https://en.wikipedia.org/wiki/Chain_complex">chain complexes</a> and <span>$\mathbb{F}_2$</span>-<a href="https://en.wikipedia.org/wiki/Homology_(mathematics)">homology</a>.</p><p><strong>Homological Algebra Foundations of Quantum Error Correction</strong></p><p>The theory of chain complexes over <span>$\mathbb{F}_2$</span> provides a unified framework for understanding error-correcting codes, where classical <span>$[n, k, d]$</span> codes correspond to <code>2</code>-term complexes and quantum CSS codes arise naturally as <code>3</code>-term complexes satisfying the commutativity condition <span>$H_Z^T H_X = 0$</span>. The homological framework reveals that:</p><ul><li>Quantum CSS codes arise from chain complexes where boundary operators correspond to parity checks.</li><li>Logical operators correspond to homology classes.</li><li>Higher-dimensional codes can be constructed through products of complexes.</li></ul><p><strong>Chain Complex Structure</strong></p><p>A <strong>chain complex</strong> <span>$C$</span> of length <span>$n$</span> is a sequence of finite-dimensional vector spaces <span>$C_j$</span> over <span>$\mathbb{F}_2$</span> connected by boundary operators that are linear transformations <span>$\partial_j \colon C_j \to C_{j-1}$</span>:</p><p class="math-container">\[\begin{aligned}
C : \{0\} \longrightarrow C_n \xrightarrow{\partial_n} C_{n-1} \xrightarrow{\partial_{n-1}} \cdots \xrightarrow{\partial_2} C_1 \xrightarrow{\partial_1} C_0 \longrightarrow \{0\}
\end{aligned}\]</p><p>with boundary operators satisfying <span>$\partial_i \circ \partial_{i+1} = 0$</span> (equivalently, <span>$\text{im}\, \partial_{j+1} \subseteq \ker \partial_j)$</span>.We define:</p><ul><li><strong>i-chains</strong>: Elements of <span>$C_i$</span></li><li><strong>i-cycles</strong>: <span>$Z_i(C) := \ker \partial_i$</span></li><li><strong>i-boundaries</strong>: <span>$B_i(C) := \mathrm{im} \partial_{i+1}$</span></li><li><strong>i-th homology</strong>: <span>$H_i(C) := Z_i(C)/B_i(C)$</span></li></ul><p><strong>Cohomology of the Dual Complex</strong></p><p>Given a chain complex <span>$C$</span> with boundary operators <span>$\partial_j$</span>, its <strong>cochain complex</strong> <span>$\widetilde{C}$</span> is the <em>dual</em> sequence with coboundary maps <span>$\delta^i = \partial_{i+1}^T$</span>:</p><p class="math-container">\[\begin{aligned}
\widetilde{C} : \{0\} \longleftarrow C_0^* \xleftarrow{\partial_1^T} C_1^* \xleftarrow{\partial_2^T} \cdots \xleftarrow{\partial_n^T} C_n^* \longleftarrow \{0\}
\end{aligned}\]</p><p>where</p><ul><li><strong>i-cocycles</strong>: <span>$Z^i(\widetilde{C}) := \ker \partial_{i+1}^T$</span></li><li><strong>i-coboundaries</strong>: <span>$B^i(\widetilde{C}) := \mathrm{im} \partial_i^T$</span></li><li><strong>i-th cohomology</strong>: <span>$H^i(\widetilde{C}) := Z^i(\widetilde{C})/B^i(\widetilde{C})$</span></li></ul><div class="admonition is-info" id="Note-3c01cf920dde9e4e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-3c01cf920dde9e4e" title="Permalink"></a></header><div class="admonition-body"><p>The cohomology group <span>$H^i(\widetilde{C}) = H(\partial_{i+1}^T, \partial_i^T)$</span> has the same rank as the homology group <span>$H_i(C)$</span> and corresponds to <span>$X$</span>-type logical operators in the CSS code <span>$CSS(\partial_i, \partial_{i+1}^T)$</span>, while <span>$H_i(C)$</span> corresponds to <span>$Z$</span>-type operators. </p></div></div><p><strong>Classical Codes via Chain Complexes and <span>$\mathbb{F_2}$</span> Homology</strong></p><p>An <span>$[n,k,d]$</span> classical code corresponds to a <code>2</code>-term complex:</p><p class="math-container">\[\begin{aligned}
\{0\} \longrightarrow C_1 \xrightarrow{\partial_1 = H} C_0 \longrightarrow \{0\}
\end{aligned}\]</p><p>where</p><ul><li><span>$C_1 = \mathbb{F}_2^n$</span> (codeword space)</li><li><span>$C_0 = \mathbb{F}_2^{n-k}$</span> (syndrome space)</li><li><span>$H$</span> is the parity check matrix</li></ul><p><strong>Quantum CSS Codes via Chain Complexes and <span>$\mathbb{F_2}$</span> Homology</strong></p><p>Quantum CSS codes extend this to <code>3</code>-term complexes:</p><p class="math-container">\[\begin{aligned}
\{0\} \longrightarrow C_2 \xrightarrow{\partial_2 = H_Z^T} C_1 \xrightarrow{\partial_1 = H_X} C_0 \longrightarrow \{0\}
\end{aligned}\]</p><p>where</p><ul><li><span>$C_1 = \mathbb{F}_2^n$</span> (physical qubits)</li><li><span>$C_2 = \mathbb{F}_2^{m_Z}$</span> (<code>Z</code>-stabilizers)</li><li><span>$C_0 = \mathbb{F}_2^{m_X}$</span> (<code>X</code>-stabilizers)</li></ul><p>with the condition <span>$\partial_1 \partial_2 = H_Z^TH_X = 0$</span> ensuring that CSS orthogonality is satisfied.</p><p>For any chain complex, selecting two consecutive boundary operators defines a valid CSS code. When qubits are identified with the space <span>$C_i$</span>, the code parameters are:</p><ul><li>number of physical qubits: <span>$n = \dim C_i$</span></li><li>number of logical qubits: <span>$k = \dim H_i(C) = \dim H^i(C)$</span></li><li>code distance: <span>$d = \min\{\text{wt}(v) | v \in (H_i(C) \cup H^i(C))\backslash\{0\}\}$</span></li></ul><div class="admonition is-info" id="Note-ca96f98a47dc6e01"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ca96f98a47dc6e01" title="Permalink"></a></header><div class="admonition-body"><p>Quantum error-correcting codes, which are represented as <code>3</code>-term chain complexes, can be constructed by applying the homological or hypergraph product to two <code>2</code>-term chain complexes.</p></div></div><p>For a detailed explanation, see the ECC Zoo&#39;s writeup on the  <a href="https://errorcorrectionzoo.org/c/qubit_css#defterm-Qubit_20XCSS-to-homology_20Xcorrespondence">CSS-to-homology correspondence</a>.</p><p><strong>D-dimensional Surface Code ((<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>), (<a href="../references/#Zeng_2019">Zeng and Pryadko, 2019</a>))</strong></p><p>We provide an explicit construction of the <code>D</code>-dimensional surface code within the framework of chain complexes and homology over <span>$\mathbb{F_2}$</span>.</p><p>The quantum code is obtained by applying the homological product (or hypergraph product) to two <code>2</code>-term chain complexes. Our construction relies on taking the hypergraph product of these complexes.</p><p><strong>Double Complex</strong></p><p>Given chain complexes <code>C</code> and <code>D</code>, we construct a <a href="https://en.wikipedia.org/wiki/Double_complex">double complex</a> derived from the tensor product of two <code>2</code>-term chain complexes:</p><p class="math-container">\[\begin{aligned}
C \boxtimes D \quad \text{with} \quad \partial_i^v = \partial_i^C \otimes I_{D_i} \quad \text{and} \quad \partial_i^h = I_{C_i} \otimes \partial_i^D
\end{aligned}\]</p><p><strong>Total Complex</strong></p><p>The total complex is derived from a double complex by taking the direct sum of vector spaces and boundary maps that share the same dimension:</p><p class="math-container">\[\begin{aligned}
\text{Tot}(C \boxtimes D)_i = \bigoplus_{i=j+k} C_j \otimes D_k = E_i
\end{aligned}\]</p><p>with boundary maps:</p><p class="math-container">\[\begin{aligned}
\partial_i^E = \bigoplus_{i=j+k} \partial_j^v \oplus \partial_k^h
\end{aligned}\]</p><p>The resulting chain complex, called the tensor product of <span>$C$</span> and <span>$D$</span>, <span>$C ⊗ D$</span>, enables the construction of a CSS code when selecting any three consecutive terms in its sequence.</p><p><strong>Subfamilies</strong></p><p><strong>[[L² + (L − 1)², 1, L]] 2D Surface Code</strong></p><p>The <code>2D</code> surface code is constructed using the hypergraph product of two repetition codes.Thus, we obtain a new <code>3</code>-term chain complex:</p><p class="math-container">\[\begin{aligned}
E_2 \xrightarrow{\partial_2^E} E_1 \xrightarrow{\partial_1^E} E_0
\end{aligned}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; D = 2; L = 2;

julia&gt; c = DDimensionalSurfaceCode(D, L);

julia&gt; code = parity_checks(c)
+ X_X_X
+ _X_XX
+ ZZ__Z
+ __ZZZ

julia&gt; import HiGHS; import JuMP;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(5, 1, 2)</code></pre><p>When <code>L = 4</code>, we get <code>[[25,1, 4]]</code> <code>2D</code> surface code from (<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; D = 2; L = 4;

julia&gt; c = DDimensionalSurfaceCode(D, L);

julia&gt; code = parity_checks(c)
+ X___X___________X________
+ _X___X__________XX_______
+ __X___X__________XX______
+ ___X___X__________X______
+ ____X___X__________X_____
+ _____X___X_________XX____
+ ______X___X_________XX___
+ _______X___X_________X___
+ ________X___X_________X__
+ _________X___X________XX_
+ __________X___X________XX
+ ___________X___X________X
+ ZZ______________Z________
+ _ZZ______________Z_______
+ __ZZ______________Z______
+ ____ZZ__________Z__Z_____
+ _____ZZ__________Z__Z____
+ ______ZZ__________Z__Z___
+ ________ZZ_________Z__Z__
+ _________ZZ_________Z__Z_
+ __________ZZ_________Z__Z
+ ____________ZZ________Z__
+ _____________ZZ________Z_
+ ______________ZZ________Z

julia&gt; import HiGHS; import JuMP;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(25, 1, 4)</code></pre><p><strong>Chain Complex</strong></p><p>The construction is as follows:</p><p class="math-container">\[\begin{aligned}
C = \left( C_1 \xrightarrow{\partial} C_0 \right) \quad \text{and} \quad D = \left( D_1 \xrightarrow{\partial^T} D_0 \right)
\end{aligned}\]</p><p>where <span>$\partial$</span> is the <span>$(L-1) \times L$</span> parity check matrix:</p><p class="math-container">\[\begin{aligned}
H = \begin{pmatrix}
1 &amp; 1 &amp; &amp; \\
 &amp; 1 &amp; \ddots &amp; \\
 &amp; &amp; \ddots &amp; 1 \\
 &amp; &amp; &amp; 1
\end{pmatrix}
\end{aligned}\]</p><p><strong>[[L³ + 2L(L − 1)², 1, min(L, L²)]] 3D Surface Code</strong></p><p>The <code>3D</code> surface code is obtained by taking the hypergraph product of a <code>2D</code> surface code with a repetition code. Thus, we obtain a new <code>4</code>-term chain complex:</p><p class="math-container">\[\begin{aligned}
F_3 \xrightarrow{\partial_3^F} F_2 \xrightarrow{\partial_2^F} F_1 \xrightarrow{\partial_1^F} F_0
\end{aligned}\]</p><p><strong>Metachecks</strong></p><ul><li><strong>Z-type</strong> metachecks: <span>$M_Z^T = \partial_3^F$</span></li></ul><p><strong>Example</strong></p><p>Here is an example of <code>[[12, 1, 2]]</code> <code>3D</code> Surface code with <code>L = 2</code> from (<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; D = 3; L = 2;

julia&gt; c = DDimensionalSurfaceCode(D, L);

julia&gt; code = parity_checks(c)
+ XX__X_____X_
+ __XXX______X
+ _____XX__XX_
+ _______XXX_X
+ Z_Z_Z_______
+ _Z_ZZ_______
+ _____Z_Z_Z__
+ ______Z_ZZ__
+ Z____Z____Z_
+ _Z____Z___Z_
+ __Z____Z___Z
+ ___Z____Z__Z
+ ____Z____ZZZ

julia&gt; code_n(c), code_k(c)
(12, 1)</code></pre><div class="admonition is-info" id="Note-94c7314feaf01b9a"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-94c7314feaf01b9a" title="Permalink"></a></header><div class="admonition-body"><p>For the <code>3D</code> surface code, there is an asymmetry between the <code>Z</code>- and <code>X</code>-bases (<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>). Specifically, the <code>Z</code>-distance (<span>$d_Z$</span>) is <code>4</code>, whereas the <code>X</code>-distance (<span>$d_X$</span>) is <code>2</code>. As a result, the code has the parameters <code>[[12, 1, 2]]</code>.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; import HiGHS; import JuMP;

julia&gt; dz = distance(c, DistanceMIPAlgorithm(solver=HiGHS, logical_operator_type=:Z))
4

julia&gt; dx = distance(c, DistanceMIPAlgorithm(solver=HiGHS, logical_operator_type=:X))
2</code></pre><p><strong>[[6L⁴ − 12L³ + 10L² − 4L + 1, 1, L²]] 4D Surface Code</strong></p><p>The <code>4D</code> surface code is constructed by taking the hypergraph product of a <code>3D</code> surface code with a repetition code.  Thus, we obtain a new <code>5</code>-term chain complex:</p><p class="math-container">\[\begin{aligned}
G_4 \xrightarrow{\partial_4^G} G_3 \xrightarrow{\partial_3^G} G_2 \xrightarrow{\partial_2^G} G_1 \xrightarrow{\partial_1^G} G_0
\end{aligned}\]</p><p><strong>[[33, 1, 4]]</strong></p><p>Here is an example of <code>[[33, 1, 4]]</code> <code>4D</code> Surface code with <code>L = 2</code> from (<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; D = 4; L = 2;

julia&gt; c = DDimensionalSurfaceCode(D, L);

julia&gt; import HiGHS; import JuMP;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(33, 1, 4)</code></pre><p><strong>Metachecks</strong></p><p>Both X and Z-type metachecks available:</p><ul><li><span>$M_Z^T = \partial_4^G$</span></li><li><span>$M_X = \partial_1^G$</span></li></ul><p>To obtain surface codes of greater dimensionality, we alternate between <code>C</code> and <code>D</code> and then form a product with the chain complex representing the <code>DDimensionalSurfaceCode</code> (<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>).</p><div class="admonition is-info" id="Note-193447362def1bcd"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-193447362def1bcd" title="Permalink"></a></header><div class="admonition-body"><p>The procedure described above for the <code>DDimensionalSurfaceCode</code> can alternatively be performed using an <code>L × L</code> repetition code and only the chain complex <code>C</code>. In this case, the result would be the <code>DDimensionalToricCode</code>.</p></div></div><p>See also: <a href="#QuantumCliffordOscarExt.DDimensionalToricCode"><code>DDimensionalToricCode</code></a></p><p><strong>Fields</strong></p><ul><li><p><code>D::Int64</code>: Dimension of the Surface code (must be ≥ 2).</p></li><li><p><code>L::Int64</code>: Size parameter determining the <code>D</code>-dimensional Surface code family, constructed via hypergraph product of <code>(L - 1) × L</code> repetition code chain complexes.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/ext/QuantumCliffordOscarExt/d_dimensional_codes.jl#L38-L392">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordOscarExt.DDimensionalToricCode" href="#QuantumCliffordOscarExt.DDimensionalToricCode"><code>QuantumCliffordOscarExt.DDimensionalToricCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DDimensionalToricCode &lt;: QuantumCliffordOscarExt.DDimensionalCode</code></pre><p><strong>D-dimensional Toric Code ((<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>), (<a href="../references/#Zeng_2019">Zeng and Pryadko, 2019</a>))</strong></p><p>The <code>D</code>-dimensional toric code is obtained by taking the <strong>iterated tensor product</strong> of a single chain complex:</p><p class="math-container">\[\begin{aligned}
C = \left( \mathbb{F}_2^L \xrightarrow{H} \mathbb{F}_2^L \right)
\end{aligned}\]</p><p>where <code>H</code> is the <span>$L \times L$</span> parity check matrix of the repetition code. The total complex is built by taking the tensor product <span>$C^{\otimes D}$</span> and forming the associated total complex via direct sums.</p><div class="admonition is-info" id="Note-4954fe07e16013c7"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4954fe07e16013c7" title="Permalink"></a></header><div class="admonition-body"><p>D-dimensional toric code construction differs from the surface code as we use the full <span>$L \times L$</span> repetition code (rather than <span>$(L-1) \times L$</span>). The tensor products with identical complexes (rather than alternating complexes) are used.</p></div></div><p><strong>Subfamilies</strong></p><p><strong>[[2L², 2, L]] 2D Toric Code</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; D = 2; L = 2;

julia&gt; c = DDimensionalToricCode(D, L);

julia&gt; code = parity_checks(c)
+ X_X_XX__
+ _X_XXX__
+ X_X___XX
+ _X_X__XX
+ ZZ__Z_Z_
+ ZZ___Z_Z
+ __ZZZ_Z_
+ __ZZ_Z_Z

julia&gt; import HiGHS; import JuMP;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(8, 2, 2)</code></pre><p><strong>[[3L³, 3, min(L, L²)]] 3D Toric Code</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; D = 3; L = 2;

julia&gt; c = DDimensionalToricCode(D, L);

julia&gt; import HiGHS; import JuMP;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(24, 3, 2)</code></pre><p><strong>[[6L⁴, 6, L²]] 4D Toric Code</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; D = 4; L = 2;

julia&gt; c = DDimensionalToricCode(D, L);

julia&gt; import HiGHS; import JuMP;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(96, 6, 4)</code></pre><p>See also: <a href="#QuantumCliffordOscarExt.DDimensionalSurfaceCode"><code>DDimensionalSurfaceCode</code></a></p><p><strong>Fields</strong></p><ul><li><p><code>D::Int64</code>: Dimension of the Toric code (must be ≥ 2).</p></li><li><p><code>L::Int64</code>: Size parameter determining the <code>D</code>-dimensional Toric code family, constructed via hypergraph product of <code>L × L</code> repetition code chain complexes.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/ext/QuantumCliffordOscarExt/d_dimensional_codes.jl#L446-L528">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.boundary_maps-Tuple{QuantumCliffordOscarExt.DDimensionalSurfaceCode}" href="#QuantumClifford.ECC.boundary_maps-Tuple{QuantumCliffordOscarExt.DDimensionalSurfaceCode}"><code>QuantumClifford.ECC.boundary_maps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns all boundary maps of the chain complex, including both <em>parity check</em> and <em>metacheck</em> matrices.</p><p>Here are the boundary maps of <code>[[12, 1, 2]]</code> <code>3D</code> Surface code with <code>L = 2</code> from (<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QECCore;

julia&gt; using QuantumClifford.ECC: DDimensionalSurfaceCode, boundary_maps, metacheck_matrix_z;

julia&gt; D = 3; L = 2;

julia&gt; c = DDimensionalSurfaceCode(D, L);

julia&gt; Mz, Hz, Hx = boundary_maps(c);</code></pre><p>The parity check matrices of <code>[[12, 1, 2]]</code> <code>3D</code> Surface code are</p><pre><code class="language-julia-repl hljs">julia&gt; Hx
4×12 Matrix{Int64}:
 1  1  0  0  1  0  0  0  0  0  1  0
 0  0  1  1  1  0  0  0  0  0  0  1
 0  0  0  0  0  1  1  0  0  1  1  0
 0  0  0  0  0  0  0  1  1  1  0  1</code></pre><div class="admonition is-info" id="Note-90f36e89c3a2e8f9"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-90f36e89c3a2e8f9" title="Permalink"></a></header><div class="admonition-body"><p>For <code>3D</code> and higher-dimensional codes, <code>Oscar</code> returns <code>Z</code>-type parity check matrix as transpose (<span>$H_Z^T$</span>). We transpose it to convert it back to <span>$H_Z$</span>. See <code>B3</code>, page <code>11</code> of (<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>).</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; Hz&#39;
9×12 adjoint(::Matrix{Int64}) with eltype Int64:
 1  0  1  0  1  0  0  0  0  0  0  0
 0  1  0  1  1  0  0  0  0  0  0  0
 0  0  0  0  0  1  0  1  0  1  0  0
 0  0  0  0  0  0  1  0  1  1  0  0
 1  0  0  0  0  1  0  0  0  0  1  0
 0  1  0  0  0  0  1  0  0  0  1  0
 0  0  1  0  0  0  0  1  0  0  0  1
 0  0  0  1  0  0  0  0  1  0  0  1
 0  0  0  0  1  0  0  0  0  1  1  1</code></pre><p>Along with the <code>Z</code>- and <code>X</code>-type parity check matrices, we have a metacheck matrix specifically for the <code>Z</code>-type checks. The classical code derived from this metacheck matrix has a distance of <code>d = 2</code> meaning it can identify (but not correct) a single error in the <code>Z</code>-type syndrome measurements. See page <code>12</code> of (<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>) for details.</p><pre><code class="language-julia-repl hljs">julia&gt; Mz&#39;
2×9 adjoint(::Matrix{Int64}) with eltype Int64:
 1  0  1  0  1  0  1  0  1
 0  1  0  1  0  1  0  1  1</code></pre><p>We can use <code>metacheck_matrix_z</code> directly instead of using <code>boundary_maps</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; metacheck_matrix_z(c)
2×9 Matrix{Int64}:
 1  0  1  0  1  0  1  0  1
 0  1  0  1  0  1  0  1  1</code></pre><p><strong>Metachecks in CSS Codes</strong></p><p>The parity-check matrices <span>$M_Z$</span> and <span>$M_X$</span> are called <em>metachecks</em> in CSS codes. These matrices emerge from the constraints imposed by boundary maps, which satisfy the condition <span>$\partial_{i+1} \partial_i = 0$</span>. This guarantees that:</p><p class="math-container">\[\begin{aligned}
M_Z H_Z = 0 \quad \text{and} \quad M_X H_X = 0,
\end{aligned}\]</p><p>meaning that:</p><ul><li>Valid <span>$Z$</span>-type syndromes must be in <span>$\ker M_Z$</span></li><li>Valid <span>$X$</span>-type syndromes must be in <span>$\ker M_X$</span></li></ul><p>When measurement errors occur, they distort the syndrome vector <span>$\mathbf{s}$</span>, generating a detectable <em>metasyndrome</em>. By examining <span>$\mathbf{m}$</span>, we can identify and correct errors in <span>$\mathbf{s}$</span> before proceeding with standard decoding. This technique is called <em>syndrome repair decoding</em> (<a href="../references/#Higgott_2023">Higgott and Breuckmann, 2023</a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/ext/QuantumCliffordOscarExt/d_dimensional_codes.jl#L643">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.twobga_from_direct_product-Tuple{Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}}, Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}}, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}" href="#QuantumClifford.ECC.twobga_from_direct_product-Tuple{Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}}, Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}}, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}"><code>QuantumClifford.ECC.twobga_from_direct_product</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">twobga_from_direct_product(
    a_elts::Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}},
    b_elts::Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}},
    F2G::Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}
) -&gt; Any
</code></pre><p>Constructing two block group algebra codes by specifying the direct product to be used. See also the more general <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>.</p><p>Two block group algebra codes are constructed by choosing a group (and specific generators), then choosing two polynomials made out of these generators, then piping these two polynomials as the elements of <code>1×1</code> matrices to the lifted product code constructors.</p><p>The Hecke library, for which we already have an extension, provides for a fairly easy way to construct such polynomials for many abelian and small groups. See <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a> for those capabilities.</p><p>However, more esoteric groups can be specified as the direct product of other groups. To support arbitrary direct products we use Oscar, which builds upon Hecke. Oscar supports the <strong>direct product</strong> operation between two or more arbitrary <strong>general</strong> groups, including non-abelian groups such as <code>alternating_group</code>, <code>dihedral_group</code>, <code>symmetric_group</code>, and even arbitrary finitely presented groups (e.g., <code>free_group</code>). This capability is not available in <code>Hecke.jl</code>. The 2BGA codes discovered in (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>) rely on direct products of two or more <em>general</em> groups, which necessitate the use of <code>Oscar.direct_product</code>.</p><p>This particular function is nothing more than a simple wrapper that takes care of argument conversions. Of note, the polynomials here are given as lists of monomials.</p><p>Of course, if you are comfortable with Oscar, you can use <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a> directly.</p><p>See also: <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.twobga_from_fp_group"><code>twobga_from_fp_group</code></a></p><p><strong>Examples</strong></p><p>The [[56, 28, 2]] abelian 2BGA code from Appendix C, Table II in (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>) can be constructed using the direct product of two cyclic groups. Specifically, the group <code>C₂₈</code> of order <code>l = 28</code> can be represented as <code>C₁₄ × C₂</code>, where the first group has order <code>m = 14</code> and the second group has order <code>n = 2</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; import Oscar: cyclic_group, small_group_identification, describe, order

julia&gt; import Hecke: gens, quo, group_algebra, GF, one, direct_product, sub

julia&gt; using QuantumClifford, QuantumClifford.ECC

julia&gt; m = 14; n = 2;

julia&gt; C₁₄ = cyclic_group(m);

julia&gt; C₂ = cyclic_group(n);

julia&gt; G = direct_product(C₁₄, C₂);

julia&gt; GA = group_algebra(GF(2), G);

julia&gt; x, s = gens(GA)[1], gens(GA)[3];

julia&gt; a = [one(GA), x^7];

julia&gt; b = [one(GA), x^7, s, x^8, s * x^7, x];

julia&gt; c = twobga_from_direct_product(a, b, GA);

julia&gt; order(G)
28

julia&gt; code_n(c), code_k(c)
(56, 28)

julia&gt; describe(G), small_group_identification(G)
(&quot;C14 x C2&quot;, (28, 4))</code></pre><div class="admonition is-danger" id="Danger-b4691122f7d248bb"><header class="admonition-header">Danger<a class="admonition-anchor" href="#Danger-b4691122f7d248bb" title="Permalink"></a></header><div class="admonition-body"><p>When using the direct product, there isn&#39;t necessarily a unique set of generators. It is essential to verify that Oscar is providing you with the generators you expect, e.g. for a cycling group that you have the presentation <code>Cₘ = ⟨x, s | xᵐ = s² = xsx⁻¹s⁻¹ = 1⟩</code>. For situations where the generators provided by Oscar are not the ones you want, you can also use <a href="#QuantumClifford.ECC.twobga_from_fp_group"><code>twobga_from_fp_group</code></a> where you specify the group presentation directly.</p></div></div><p>As a verification that you have the correct generators, <code>Oscar.sub</code> can be used to determine if <code>H</code> is a subgroup of <code>G</code> and to confirm that both <code>C₁₄</code> and <code>C₂</code> are subgroups of <code>C₂₈</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; order(gens(G)[1])
14

julia&gt; order(gens(G)[3])
2

julia&gt; x^14 == s^2 == x * s * x^-1 * s^-1
true

julia&gt; H, _  = sub(G, [gens(G)[1], gens(G)[3]]);

julia&gt; H == G
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/ext/QuantumCliffordOscarExt/direct_product.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.twobga_from_fp_group-Tuple{Vector{Oscar.FPGroupElem}, Vector{Oscar.FPGroupElem}, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.FPGroup, Oscar.FPGroupElem}}" href="#QuantumClifford.ECC.twobga_from_fp_group-Tuple{Vector{Oscar.FPGroupElem}, Vector{Oscar.FPGroupElem}, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.FPGroup, Oscar.FPGroupElem}}"><code>QuantumClifford.ECC.twobga_from_fp_group</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">twobga_from_fp_group(
    a_elts::Vector{Oscar.FPGroupElem},
    b_elts::Vector{Oscar.FPGroupElem},
    F2G::Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.FPGroup, Oscar.FPGroupElem}
) -&gt; Any
</code></pre><p>Constructing two block group algebra codes by specifying the group presentation.</p><p>Two block group algebra codes are constructed by choosing a group (and specific generators), then choosing two polynomials made out of these generators, then piping these two polynomials as the elements of <code>1×1</code> matrices to the lifted product code constructors.</p><p>The Hecke library, for which we already have an extension, provides for a fairly easy way to construct such polynomials for many abelian and small groups. See <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a> for those capabilities.</p><p>However, more esoteric groups are usually specified by a group presentation <code>⟨S | R⟩</code>, where <code>S</code> is a set of generators and <code>R</code> is the relations those generators obey. To support arbitrary group presentations we use Oscar, which builds upon Hecke. We use <code>Oscar.free_group</code> and <code>quo</code> in order to first prepare the free group generated by <code>S</code>, and then the group obeying also the relations <code>R</code>, i.e. the <code>⟨S | R⟩</code> <a href="https://en.wikipedia.org/wiki/Presentation_of_a_group">presentation</a>.</p><p>After that point we proceed as usual, creating two polynomials of generators and piping them to <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>.</p><p>This particular function is nothing more than a simple wrapper that takes care of argument conversions. Of note, the polynomials here are given as lists of monomials.</p><p>Of course, if you are comfortable with Oscar, you can use <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a> directly.</p><p>See also: <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.twobga_from_direct_product"><code>twobga_from_direct_product</code></a></p><p><strong>Examples</strong></p><p>The [[96, 12, 10]] 2BGA code from Table I in (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>) has the group presentation <code>⟨r, s | s⁶ = r⁸ = r⁻¹srs = 1⟩</code> (the group <code>C₂ × (C₃ ⋉ C₈)</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; import Oscar: free_group, small_group_identification, describe, order

julia&gt; import Hecke: gens, quo, group_algebra, GF, one

julia&gt; using QuantumClifford, QuantumClifford.ECC

julia&gt; F = free_group([&quot;r&quot;, &quot;s&quot;]);

julia&gt; r, s = gens(F); # generators

julia&gt; G, = quo(F, [s^6, r^8, r^(-1) * s * r * s]);  # relations

julia&gt; GA = group_algebra(GF(2), G);

julia&gt; r, s = gens(G);

julia&gt; a = [one(G), r, s^3 * r^2, s^2 * r^3];

julia&gt; b = [one(G), r, s^4 * r^6, s^5 * r^3];

julia&gt; c = twobga_from_fp_group(a, b, GA);

julia&gt; order(G)
48

julia&gt; code_n(c), code_k(c)
(96, 12)

julia&gt; describe(G), small_group_identification(G)
(&quot;C2 x (C3 : C8)&quot;, (48, 9))</code></pre><p><strong>Cyclic Groups</strong></p><p>Cyclic groups with specific group presentations, given by <code>Cₘ = ⟨x, s | xᵐ = s² = xsx⁻¹s⁻¹ = 1⟩</code>, where the order is <code>2m</code> as seen in Table II of (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>).</p><p>The [[56, 28, 2]] abelian 2BGA code from Appendix C, Table II in (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>) is constructed using the group presentation <code>⟨x, s | xs = sx, xᵐ = s² = 1⟩</code> (the cyclic group <code>C₂₈ = C₁₄ × C₂</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; m = 14;

julia&gt; F = free_group([&quot;x&quot;, &quot;s&quot;]);

julia&gt; x, s = gens(F); # generators

julia&gt; G, = quo(F, [x^m, s^2, x * s * x^-1 * s^-1]); # relations

julia&gt; GA = group_algebra(GF(2), G);

julia&gt; x, s = gens(G);

julia&gt; a = [one(G), x^7];

julia&gt; b = [one(G), x^7, s, x^8, s * x^7, x];

julia&gt; c = twobga_from_fp_group(a, b, GA);

julia&gt; order(G)
28

julia&gt; code_n(c), code_k(c)
(56, 28)

julia&gt; describe(G), small_group_identification(G)
(&quot;C14 x C2&quot;, (28, 4))</code></pre><p><strong>Dihedral Groups</strong></p><p>Dihedral (non-abelian) groups with group presentations given by <code>Dₘ = ⟨r, s | rᵐ = s² = (rs)² = 1⟩</code>, where the order is <code>2m</code>.</p><p>The [[24, 8, 3]] 2BGA code from Appendix C, Table III in (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>) is constructed by specifying a group presentation below (giving the group <code>D₆ = C₆ ⋉ C₂</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; m = 6;

julia&gt; F = free_group([&quot;r&quot;, &quot;s&quot;]);

julia&gt; r, s = gens(F); # generators

julia&gt; G, = quo(F, [r^m, s^2, (r*s)^2]); # relations

julia&gt; GA = group_algebra(GF(2), G);

julia&gt; r, s = gens(G);

julia&gt; a = [one(G), r^4];

julia&gt; b = [one(G), s*r^4, r^3, r^4, s*r^2, r];

julia&gt; c = twobga_from_fp_group(a, b, GA);

julia&gt; order(G)
12

julia&gt; code_n(c), code_k(c)
(24, 8)

julia&gt; describe(G), small_group_identification(G)
(&quot;D12&quot;, (12, 4))</code></pre><div class="admonition is-info" id="Note-9792205551ac43e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-9792205551ac43e" title="Permalink"></a></header><div class="admonition-body"><p>Notice how in all of these construction we are specifying a group presentation. We are explicitly <strong>not</strong> picking a group by name and getting its &quot;canonical&quot; generators, as we do not a priori know whether Oscar would give us the generating set we need (generating sets are not unique).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/ext/QuantumCliffordOscarExt/group_presentation.jl#L1">source</a></section></article><h2 id="Implemented-in-an-extension-requiring-JuMP.jl"><a class="docs-heading-anchor" href="#Implemented-in-an-extension-requiring-JuMP.jl">Implemented in an extension requiring <code>JuMP.jl</code></a><a id="Implemented-in-an-extension-requiring-JuMP.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Implemented-in-an-extension-requiring-JuMP.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.distance-Tuple{QECCore.AbstractECC, QuantumClifford.ECC.DistanceMIPAlgorithm}" href="#QECCore.distance-Tuple{QECCore.AbstractECC, QuantumClifford.ECC.DistanceMIPAlgorithm}"><code>QECCore.distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance(
    code::QECCore.AbstractECC,
    alg::QuantumClifford.ECC.DistanceMIPAlgorithm
) -&gt; Any
</code></pre><p>Compute the distance of a code using mixed integer programming. See <a href="#QuantumClifford.ECC.DistanceMIPAlgorithm"><code>QuantumClifford.ECC.DistanceMIPAlgorithm</code></a> for configuration options.</p><p>Specifically, it computes the minimum distance of a Calderbank-Shor-Steane code by solving two independent <strong>Mixed Integer Programs</strong> for X-type (<span>$d_X$</span>) and Z-type (<span>$d_Z$</span>) distances. The code distance is <span>$d = \min(d_X, d_Z)$</span>.</p><p><strong>Background on Minimum Distance</strong></p><p>For <em>classical</em> codes, the minimum distance, which measures a code&#39;s error-correcting capability, is equivalent to its minimum weight. This can be computed by generating all possible codewords from combinations of the generator matrix rows, calculating their weights, and finding the smallest. While accurate, this method takes exponential time. Vardy (<a href="../references/#vardy1997intractability">Vardy, 1997</a>) demonstrated that computing the minimum distance is <em>NP-hard</em>, and the corresponding decision problem is <em>NP-complete</em>, making polynomial-time algorithms unlikely.</p><p>For <em>quantum</em> codes, classical intuition does not always apply. The minimum distance is given by the minimum weight of a non-trivial logical operator. This is generally unrelated to the minimum distance of the corresponding stabilizer code when viewed as a classical, additive code. White and Grassl (<a href="../references/#white2006new">White and Grassl, 2006</a>) proposed mapping quantum codes to higher-dimensional classical linear codes. This mapping allows the minimum distance of the quantum additive code to be inferred from that of the classical linear code but increases parameters from <code>n</code> to <code>3n</code> and <code>d</code> to <code>2d</code>, adding complexity. Furthermore, once a minimal weight vector is identified, it is essential to verify whether it belongs to the Pauli group <code>𝒫ₙ</code> over <code>n</code> qubits (<a href="../references/#Sabo_2022smk">Sabo, 2022</a>).</p><div class="admonition is-info" id="Note-c371603342d50d66"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c371603342d50d66" title="Permalink"></a></header><div class="admonition-body"><p>The minimum distance problem for quantum codes is <em>NP-hard</em>, and this hardness extends to multiplicative and additive approximations, even when restricted to stabilizer or CSS codes, with the result established through a reduction from classical problems in the CWS framework using a 4-cycle free graph (<a href="../references/#kapshikar2023hardness">Kapshikar and Kundu, 2023</a>). Despite this, methods that improve on brute-force approaches are actively explored.</p></div></div><p>For a more in-depth background on minimum distance, see Chapter 3 of (<a href="../references/#Sabo_2022smk">Sabo, 2022</a>).</p><p><strong>Quantum Error Correction and Code Distance</strong></p><p>The foundation of quantum error correction lies in protecting logical quantum information from physical errors by encoding it across multiple qubits. A quantum code&#39;s performance is fundamentally characterized by its distance (<code>d</code>), which quantifies the code&#39;s ability to detect and correct errors. Practically, the distance represents the minimum number of physical qubit errors required to cause an undetectable logical error - one that corrupts encoded information while evading the code&#39;s error detection mechanisms.</p><p><strong>Fundamentals of Quantum Code Distance</strong></p><p>The distance <code>d</code> of a quantum error-correcting code represents its robustness against physical errors and is defined as (<a href="../references/#qubitguide">Ekert <em>et al.</em>, undated</a>):</p><p class="math-container">\[\begin{aligned}
d = \min_{P \in N(S)\setminus S} \mathrm{wt}(P)
\end{aligned}\]</p><p>where:</p><ul><li><span>$N(S)$</span> denotes the <a href="https://en.wikipedia.org/wiki/Centralizer_and_normalizer">normalizer</a> of the stabilizer group <code>S</code>.</li><li><span>$\mathrm{wt}(P)$</span> represents the weight of Pauli operator P.</li><li>The minimization is taken over all logical operators that are not stabilizers.</li></ul><p>The distance reveals the essential property that it equals the smallest number of qubits that must be affected to produce a logical error undetectable by stabilizer measurements. The normalizer condition <span>$P \in N(S)$</span> ensures the operator commutes with all stabilizers, while <span>$P \notin S$</span> guarantees it performs a non-trivial logical operation (<a href="../references/#qubitguide">Ekert <em>et al.</em>, undated</a>).</p><p><strong>Mixed Integer Programming</strong></p><p>We compute the minimum code distance for CSS (Calderbank-Shor-Steane) codes by solving MIPs. </p><p>The distance is computed separately for X-type (<span>$d_X$</span>) and Z-type (<span>$d_Z$</span>) logical operators, then combined to give the true code distance: <span>$d = \min(d_X, d_Z)$</span>.</p><p><strong>X-type and Z-type Distances</strong></p><p>The X-type distance (<span>$d_X$</span>) and Z-type distance (<span>$d_Z$</span>) are defined as the minimum number of errors required to implement a non-trivial logical operator of the opposite type, subject to the following constraints: </p><ul><li>For <span>$d_X$</span> (where <span>$U = X$</span>), the errors are Z-type (phase flips), and the constraints involve the X-stabilizer matrix <span>$\mathbf{H_X}$</span> and X-logical operators <span>$\mathbf{L_X}$</span>. The error vector is denoted as <span>$\mathbf{e}_Z$</span>.</li><li>For <span>$d_Z$</span> (where <span>$U = Z$</span>), the errors are X-type (bit flips), with constraints given by the Z-stabilizer matrix <span>$\mathbf{H_Z}$</span> and Z-logical operators <span>$\mathbf{L_Z}$</span>, and the error vector is <span>$\mathbf{e}_X$</span>.  </li></ul><p class="math-container">\[\begin{aligned}
\text{Minimize} \quad &amp; \sum_{i=1}^n e_{V,i} \quad \text{(Hamming weight of errors)} \\
\text{Subject to} \quad &amp; \mathbf{H_U} \cdot \mathbf{e}_V \equiv \mathbf{0} \pmod{2} \quad \text{(Commutes with U-stabilizers)} \\
                      &amp; \mathbf{L_U} \cdot \mathbf{e}_V \equiv 1 \pmod{2} \quad \text{(Anti-commutes with U-logical)} \\
                      &amp; e_{V,i} \in \{0,1\} \quad \text{(Binary error variables)}
\end{aligned}\]</p><p><strong>Example</strong></p><p>A <code>[[40, 8, 5]]</code> 2BGA code with the minimum distance of <code>5</code> from Table 2 of (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; import HiGHS; import JuMP;

julia&gt; using QuantumClifford, QuantumClifford.ECC

julia&gt; l = 10; m = 2;

julia&gt; GA = group_algebra(GF(2), abelian_group([l,m]));

julia&gt; x, s = gens(GA);

julia&gt; A = 1 + x^6;

julia&gt; B = 1 + x^5 + s + x^6 + x + s*x^2;

julia&gt; c = two_block_group_algebra_codes(A,B);

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(40, 8, 5)</code></pre><p>A <code>[[48, 6, 8]]</code> GB code with the minimum distance of <code>8</code> from (A3) in Appendix B of (<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; l = 24;

julia&gt; c1 = generalized_bicycle_codes([0, 2, 8, 15], [0, 2, 12, 17], l);

julia&gt; code_n(c1), code_k(c1), distance(c1, DistanceMIPAlgorithm(solver=HiGHS))
(48, 6, 8)</code></pre><p><strong>Applications</strong></p><p>Mixed-integer programming (MIP) is applied in quantum error correction, notably for decoding and minimum distance computation. Some applications are as follows:</p><ul><li><p>The first usecase of the MIP approach was the code capacity Most Likely Error (MLE) decoder for color codes introduced in (<a href="../references/#landahl2011color">Landahl <em>et al.</em>, 2011</a>).</p></li><li><p>For all quantum LDPC codes presented in (<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>), the lower and upper bounds on the minimum distance was obtained by reduction to a mixed integer linear program and using the GNU Linear Programming Kit ((<a href="../references/#makhorin2008glpk">Makhorin, 2008</a>)).</p></li><li><p>For all the Bivariate Bicycle (BB) codes presented in (<a href="../references/#bravyi2024high">Bravyi <em>et al.</em>, 2024</a>), the code distance was calculated using the mixed integer programming approach.</p></li><li><p>(<a href="../references/#lacroix2024scaling">Lacroix <em>et al.</em>, 2024</a>) developed a MLE decoder that finds the most likely chain of Pauli errors given the observed error syndrome by solving a mixed-integer program using <code>HiGHS</code> package ((<a href="../references/#huangfu2018parallelizing">Huangfu and Hall, 2018</a>)).</p></li><li><p>(<a href="../references/#cain2025correlateddecodinglogicalalgorithms">Cain <em>et al.</em>, 2025</a>) formulate maximum-likelihood decoding as a mixed-integer program maximizing <span>$\prod_{j=1}^M p_j^{E_j}(1-p_j)^{1-E_j}$</span> (where binary variables <span>$E_j \in {0,1}$</span> indicate error occurrence) subject to syndrome constraints, solved optimally via MIP solvers despite its NP-hard complexity.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/0c696665bf6899e9eef2735f06c173528d07f4fa/ext/QuantumCliffordJuMPExt/min_distance_mixed_integer_programming.jl#L1">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ECC_evaluating/">« Evaluating codes and decoders</a><a class="docs-footer-nextpage" href="../allops/">All Gates »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 15 August 2025 07:44">Friday 15 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · QuantumClifford.jl</title><meta name="title" content="API · QuantumClifford.jl"/><meta property="og:title" content="API · QuantumClifford.jl"/><meta property="twitter:title" content="API · QuantumClifford.jl"/><meta name="description" content="Documentation for QuantumClifford.jl."/><meta property="og:description" content="Documentation for QuantumClifford.jl."/><meta property="twitter:description" content="Documentation for QuantumClifford.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumClifford.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">QuantumClifford.jl</a></li><li><span class="tocitem">Stabilizer Tableau Algebra</span><ul><li><a class="tocitem" href="../stab-algebra-manual/">Manual</a></li><li><a class="tocitem" href="../canonicalization/">Canonicalization</a></li><li><a class="tocitem" href="../mixed/">Mixed States</a></li><li><a class="tocitem" href="../graphs/">Graph States</a></li><li><a class="tocitem" href="../datastructures/">Datastructure Choice</a></li><li><a class="tocitem" href="../commonstates/">Useful States</a></li></ul></li><li><span class="tocitem">Noisy Circuits</span><ul><li><a class="tocitem" href="../noisycircuits/">Simulation of Noisy Circuits</a></li><li><a class="tocitem" href="../noisycircuits_mc/">Monte Carlo</a></li><li><a class="tocitem" href="../noisycircuits_perturb/">Perturbative Expansions</a></li><li><a class="tocitem" href="../ecc_example_sim/">ECC example</a></li><li><a class="tocitem" href="../noisycircuits_ops/">Circuit Operations</a></li><li><a class="tocitem" href="../noisycircuits_API/">API</a></li></ul></li><li><span class="tocitem">ECC compendium</span><ul><li><a class="tocitem" href="../ECC_evaluating/">Evaluating codes and decoders</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul></li><li><a class="tocitem" href="../allops/">All Gates</a></li><li><a class="tocitem" href="../plotting/">Visualizations</a></li><li><a class="tocitem" href="../API/">API</a></li><li><a class="tocitem" href="../tutandpub/">Tutorials and Publications</a></li><li><a class="tocitem" href="../references/">Suggested Readings &amp; References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ECC compendium</a></li><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumSavory/QuantumClifford.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/master/docs/src/ECC_API.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Full-ECC-API-(autogenerated)"><a class="docs-heading-anchor" href="#Full-ECC-API-(autogenerated)">Full ECC API (autogenerated)</a><a id="Full-ECC-API-(autogenerated)-1"></a><a class="docs-heading-anchor-permalink" href="#Full-ECC-API-(autogenerated)" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.CSS" href="#QuantumClifford.ECC.CSS"><code>QuantumClifford.ECC.CSS</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An arbitrary CSS error correcting code defined by its X and Z checks.</p><pre><code class="language-julia-repl hljs">julia&gt; CSS([0 1 1 0; 1 1 0 0], [1 1 1 1]) |&gt; parity_checks
+ _XX_
+ XX__
+ ZZZZ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/codes/css.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.CircuitCode" href="#QuantumClifford.ECC.CircuitCode"><code>QuantumClifford.ECC.CircuitCode</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>CircuitCode</code> is defined by a given encoding circuit <code>circ</code>.</p><ul><li><code>n</code>: qubit number</li><li><code>circ</code>: the encoding circuit</li><li><code>encode_qubits</code>: the qubits to be encoded</li></ul><p>See also: <a href="#QuantumClifford.ECC.random_all_to_all_circuit_code"><code>random_all_to_all_circuit_code</code></a>, <a href="#QuantumClifford.ECC.random_brickwork_circuit_code"><code>random_brickwork_circuit_code</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/codes/random_circuit.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.Cleve8" href="#QuantumClifford.ECC.Cleve8"><code>QuantumClifford.ECC.Cleve8</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A pedagogical example of a quantum error correcting [8,3] code used in (<a href="../references/#cleve1997efficient">Cleve and Gottesman, 1997</a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/codes/clevecode.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.CommutationCheckECCSetup" href="#QuantumClifford.ECC.CommutationCheckECCSetup"><code>QuantumClifford.ECC.CommutationCheckECCSetup</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Configuration for ECC evaluator that does not simulate any ECC circuits, rather it simply checks the commutation of the parity check and the Pauli error.</p><p>This is much faster than any other simulation method, but it is incapable of noisy-circuit simulations and thus useless for fault-tolerance studies.</p><p>See also: <a href="#QuantumClifford.ECC.NaiveSyndromeECCSetup"><code>NaiveSyndromeECCSetup</code></a>, <a href="#QuantumClifford.ECC.ShorSyndromeECCSetup"><code>ShorSyndromeECCSetup</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/decoder_pipeline.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.Concat" href="#QuantumClifford.ECC.Concat"><code>QuantumClifford.ECC.Concat</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Concat(c₁, c₂)</code> is a code concatenation of two quantum codes (<a href="../references/#knill1996concatenated">Knill and Laflamme, 1996</a>).</p><p>The inner code c₁ and the outer code c₂. The construction is the following: replace each qubit in code c₂ with logical qubits encoded by code c₁. The resulting code will have <code>n = n₁ × n₂</code> qubits and <code>k = k₁ × k₂</code> logical qubits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/codes/concat.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.Gottesman" href="#QuantumClifford.ECC.Gottesman"><code>QuantumClifford.ECC.Gottesman</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The family of <code>[[2ʲ, 2ʲ - j - 2, 3]]</code> Gottesman codes, also known as quantum Hamming codes, as described in <a href="../references/#gottesman1997stabilizer">Gottesman&#39;s 1997 PhD thesis</a> and in (<a href="../references/#gottesman1996class">Gottesman, 1996</a>).</p><p>You might be interested in consulting (<a href="../references/#yu2013all">Yu <em>et al.</em>, 2013</a>) and (<a href="../references/#chao2018quantum">Chao and Reichardt, 2017</a>) as well.</p><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/quantum_hamming">entry for this family</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/codes/gottesman.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.NaiveSyndromeECCSetup" href="#QuantumClifford.ECC.NaiveSyndromeECCSetup"><code>QuantumClifford.ECC.NaiveSyndromeECCSetup</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Configuration for ECC evaluator that runs the simplest syndrome measurement circuit.</p><p>The circuit is being simulated (as opposed to doing only a quick commutation check). This circuit would give poor performance if there is non-zero gate noise.</p><p>See also: <a href="#QuantumClifford.ECC.CommutationCheckECCSetup"><code>CommutationCheckECCSetup</code></a>, <a href="#QuantumClifford.ECC.ShorSyndromeECCSetup"><code>ShorSyndromeECCSetup</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/decoder_pipeline.jl#L46-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.ShorSyndromeECCSetup" href="#QuantumClifford.ECC.ShorSyndromeECCSetup"><code>QuantumClifford.ECC.ShorSyndromeECCSetup</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Configuration for ECC evaluators that simulate the Shor-style syndrome measurement (without a flag qubit).</p><p>The simulated circuit includes:</p><ul><li>perfect noiseless encoding (encoding and its fault tolerance are not being studied here)</li><li>one round of &quot;memory noise&quot; after the encoding but before the syndrome measurement</li><li>perfect preparation of entangled ancillary qubits</li><li>noisy Shor-style syndrome measurement (only two-qubit gate noise)</li><li>noiseless &quot;logical state measurement&quot; (providing the comparison data when evaluating the decoder)</li></ul><p>See also: <a href="#QuantumClifford.ECC.CommutationCheckECCSetup"><code>CommutationCheckECCSetup</code></a>, <a href="#QuantumClifford.ECC.NaiveSyndromeECCSetup"><code>NaiveSyndromeECCSetup</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/decoder_pipeline.jl#L62-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.Surface" href="#QuantumClifford.ECC.Surface"><code>QuantumClifford.ECC.Surface</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The planar surface code refers to the code (<a href="../references/#kitaev2003fault">Kitaev, 2003</a>) in a 2D lattice with open boundaries.</p><p>Illustration of a 3×2 surface code, where qubits are located on the edges:</p><pre><code class="nohighlight hljs">|---1--(Z)--2---|---3---|
|  (X)  7       8       o
|---4---|---5---|---6---|
|       o       o       o
|       |       |       |</code></pre><p>The surface code has open boundary conditions, unlike the toric code. To this end, we remove qubits (denoted by &quot;o&quot;) and parity checks on the right and bottom sides.</p><p>Faces like <code>(1,4,7)</code> have X checks, and crosses like <code>(1,2,7)</code> have Z checks. Due to the removal of the bottom and right sides, we have some 3-qubit checks on the boundaries.</p><pre><code class="language-julia-repl hljs">julia&gt; parity_checks(Surface(3,2))
+ X__X__X_
+ _X__X_XX
+ __X__X_X
+ ZZ____Z_
+ _ZZ____Z
+ ___ZZ_Z_
+ ____ZZ_Z</code></pre><p>More information can be seen in (<a href="../references/#fowler2012surface">Fowler <em>et al.</em>, 2012</a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/codes/surface.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.TableDecoder" href="#QuantumClifford.ECC.TableDecoder"><code>QuantumClifford.ECC.TableDecoder</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A simple look-up table decoder for error correcting codes.</p><p>The lookup table contains only weight=1 errors, thus it is small, but at best it provides only for distance=3 decoding.</p><p>The size of the lookup table would grow exponentially quickly for higher distances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/decoder_pipeline.jl#L201-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.Toric" href="#QuantumClifford.ECC.Toric"><code>QuantumClifford.ECC.Toric</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The Toric code (<a href="../references/#kitaev2003fault">Kitaev, 2003</a>).</p><p>Illustration of a 2x2 toric code, where qubits are located on the edges:</p><pre><code class="nohighlight hljs">|--1-(Z)-2--|
| (X) 5     6
|--3--|--4--|
|     7     8
|     |     |</code></pre><p>It is important to note that the toric code has periodic boundary conditions, which means that the top and bottom sides are essentially glued together, as are the left and right sides.</p><p>Faces like <code>(1,3,5,6)</code> have X checks, and crosses like <code>(1,2,5,7)</code> have Z checks.</p><pre><code class="language-julia-repl hljs">julia&gt; parity_checks(Toric(2,2))
+ X_X_XX__
+ _X_XXX__
+ X_X___XX
+ ZZ__Z_Z_
+ ZZ___Z_Z
+ __ZZZ_Z_</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/codes/toric.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.BeliefPropDecoder-Tuple" href="#QuantumClifford.ECC.BeliefPropDecoder-Tuple"><code>QuantumClifford.ECC.BeliefPropDecoder</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A simple Belief Propagation decoder built around tools from <code>LDPCDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/decoder_pipeline.jl#L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.BitFlipDecoder-Tuple" href="#QuantumClifford.ECC.BitFlipDecoder-Tuple"><code>QuantumClifford.ECC.BitFlipDecoder</code></a> — <span class="docstring-category">Method</span></header><section><div><p>An Iterative Bitflip decoder built around tools from <code>LDPCDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/decoder_pipeline.jl#L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.PyBeliefPropDecoder-Tuple" href="#QuantumClifford.ECC.PyBeliefPropDecoder-Tuple"><code>QuantumClifford.ECC.PyBeliefPropDecoder</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A Belief Propagation decoder built around tools from the python package <code>ldpc</code> available from the julia package <code>PyQDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/decoder_pipeline.jl#L282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.PyBeliefPropOSDecoder-Tuple" href="#QuantumClifford.ECC.PyBeliefPropOSDecoder-Tuple"><code>QuantumClifford.ECC.PyBeliefPropOSDecoder</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A Belief Propagation decoder with ordered statistics decoding, built around tools from the python package <code>ldpc</code> available from the julia package <code>PyQDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/decoder_pipeline.jl#L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.PyMatchingDecoder-Tuple" href="#QuantumClifford.ECC.PyMatchingDecoder-Tuple"><code>QuantumClifford.ECC.PyMatchingDecoder</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A perfect matching decoder built around tools from the python package <code>pymatching</code> available from the julia package <code>PyQDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/decoder_pipeline.jl#L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.code_k-Tuple{Any}" href="#QuantumClifford.ECC.code_k-Tuple{Any}"><code>QuantumClifford.ECC.code_k</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The number of logical qubits in a code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/ECC.jl#L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.code_n" href="#QuantumClifford.ECC.code_n"><code>QuantumClifford.ECC.code_n</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The number of physical qubits in a code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/ECC.jl#L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.code_s" href="#QuantumClifford.ECC.code_s"><code>QuantumClifford.ECC.code_s</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The number of stabilizer checks in a code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/ECC.jl#L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.distance" href="#QuantumClifford.ECC.distance"><code>QuantumClifford.ECC.distance</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The distance of a code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/ECC.jl#L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, QuantumClifford.ECC.AbstractECCSetup, Int64}" href="#QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, QuantumClifford.ECC.AbstractECCSetup, Int64}"><code>QuantumClifford.ECC.evaluate_decoder</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate the performance of a given decoder (e.g. <a href="#QuantumClifford.ECC.TableDecoder"><code>TableDecoder</code></a>) and a given style of running an ECC code (e.g. <a href="#QuantumClifford.ECC.ShorSyndromeECCSetup"><code>ShorSyndromeECCSetup</code></a>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/decoder_pipeline.jl#L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, Vararg{Any, 5}}" href="#QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, Vararg{Any, 5}}"><code>QuantumClifford.ECC.evaluate_decoder</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate the performance of an error-correcting circuit.</p><p>This method requires you give the circuit that performs both syndrome measurements and (probably noiseless) logical state measurements. The faults matrix that translates an error vector into corresponding logical errors is necessary as well.</p><p>This is a relatively barebones method that assumes the user prepares necessary circuits, etc. It is a method that is used internally by more user-frienly methods providing automatic conversion of codes and noise models to the necessary noisy circuits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/decoder_pipeline.jl#L154-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.faults_matrix-Tuple{Stabilizer}" href="#QuantumClifford.ECC.faults_matrix-Tuple{Stabilizer}"><code>QuantumClifford.ECC.faults_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Error-to-logical-observable map (a.k.a. fault matrix) of a code.</p><p>For a code with n physical qubits and k logical qubits this function returns a 2k × 2n binary matrix O such that <code>O[i,j]</code> is true if the logical observable of index <code>i</code> is flipped by the single physical qubit error of index <code>j</code>. Indexing is such that:</p><ul><li><code>O[1:k,:]</code> is the error-to-logical-X-observable map (logical X observable, i.e. triggered by logical Z errors)</li><li><code>O[k+1:2k,:]</code> is the error-to-logical-Z-observable map</li><li><code>O[:,1:n]</code> is the X-physical-error-to-logical-observable map</li><li><code>O[n+1:2n,:]</code> is the Z-physical-error-to-logical-observable map</li></ul><p>E.g. for <code>k=1</code>, <code>n=10</code>, then if <code>O[2,5]</code> is true, then the logical Z observable is flipped by a X₅ error; and if <code>O[1,12]</code> is true, then the logical X observable is flipped by a Z₂ error.</p><p>Of note is that there is a lot of freedom in choosing the logical operations! A logical operator multiplied by a stabilizer operator is still a logical operator. Similarly there is a different fault matrix for each choice of logical operators. But once the logical operators are picked, the fault matrix is fixed.</p><p>Below we show an example that uses the Shor code. While it is not the smallest code, it is a convenient choice to showcase the importance of the fault matrix when dealing with degenerate codes where a correction operation and an error do not need to be the same.</p><p>First, consider a single-qubit error, potential correction operations, and their effect on the Shor code:</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford.ECC: faults_matrix, Shor9

julia&gt; state = MixedDestabilizer(Shor9())
𝒟ℯ𝓈𝓉𝒶𝒷━━━━━
+ Z________
+ ___Z_____
+ _X_______
+ __X______
+ ____X____
+ _____X___
+ ______X__
+ _______X_
𝒳ₗ━━━━━━━━━
+ ______XXX
𝒮𝓉𝒶𝒷━━━━━━━
+ XXX___XXX
+ ___XXXXXX
+ ZZ_______
+ Z_Z______
+ ___ZZ____
+ ___Z_Z___
+ ______Z_Z
+ _______ZZ
𝒵ₗ━━━━━━━━━
+ Z__Z____Z

julia&gt; err_Z₁ = single_z(9,1) # the error we will simulate
+ Z________

julia&gt; cor_Z₂ = single_z(9,2) # the correction operation we will perform
+ _Z_______

julia&gt; err_Z₁ * state # observe that one of the syndrome bits is now flipped
𝒟ℯ𝓈𝓉𝒶𝒷━━━━━
+ Z________
+ ___Z_____
+ _X_______
+ __X______
+ ____X____
+ _____X___
+ ______X__
+ _______X_
𝒳ₗ━━━━━━━━━
+ ______XXX
𝒮𝓉𝒶𝒷━━━━━━━
- XXX___XXX
+ ___XXXXXX
+ ZZ_______
+ Z_Z______
+ ___ZZ____
+ ___Z_Z___
+ ______Z_Z
+ _______ZZ
𝒵ₗ━━━━━━━━━
+ Z__Z____Z

julia&gt; cor_Z₂ * err_Z₁ * state # we are back to a good code state
𝒟ℯ𝓈𝓉𝒶𝒷━━━━━
+ Z________
+ ___Z_____
- _X_______
+ __X______
+ ____X____
+ _____X___
+ ______X__
+ _______X_
𝒳ₗ━━━━━━━━━
+ ______XXX
𝒮𝓉𝒶𝒷━━━━━━━
+ XXX___XXX
+ ___XXXXXX
+ ZZ_______
+ Z_Z______
+ ___ZZ____
+ ___Z_Z___
+ ______Z_Z
+ _______ZZ
𝒵ₗ━━━━━━━━━
+ Z__Z____Z

julia&gt; bad_Z₆Z₉ = single_z(9,6) * single_z(9,9) # a different &quot;correction&quot; operation
+ _____Z__Z

julia&gt; bad_Z₆Z₉ * err_Z₁ * state # the syndrome is trivial, but now we have a logical error
𝒟ℯ𝓈𝓉𝒶𝒷━━━━━
+ Z________
+ ___Z_____
+ _X_______
+ __X______
+ ____X____
- _____X___
+ ______X__
+ _______X_
𝒳ₗ━━━━━━━━━
- ______XXX
𝒮𝓉𝒶𝒷━━━━━━━
+ XXX___XXX
+ ___XXXXXX
+ ZZ_______
+ Z_Z______
+ ___ZZ____
+ ___Z_Z___
+ ______Z_Z
+ _______ZZ
𝒵ₗ━━━━━━━━━
+ Z__Z____Z</code></pre><p>The success of <code>cor_Z₂</code> and the failure of <code>bad_Z₆Z₉</code> can be immediately seen through the fault matrix, as the wrong &quot;correction&quot; does not result in the same logical flips ad the error:</p><pre><code class="language-julia-repl hljs">julia&gt; O = faults_matrix(Shor9())
2×18 BitMatrix:
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1
 1  0  0  1  0  0  0  0  1  0  0  0  0  0  0  0  0  0

julia&gt; O * stab_to_gf2(err_Z₁)
2-element Vector{Int64}:
 0
 0

julia&gt; O * stab_to_gf2(cor_Z₂)
2-element Vector{Int64}:
 0
 0

julia&gt; O * stab_to_gf2(bad_Z₆Z₉)
2-element Vector{Int64}:
 1
 0</code></pre><p>While its use in this situation is rather contrived, the fault matrix is incredibly useful when running large scale simulations in which we want a separate fast error sampling process, (e.g. with Pauli frames) and a syndrome decoding process, without coupling between them. We just gather all our syndrome measurement <strong>and logical observables</strong> from the Pauli frame simulations, and then use them with the fault matrix in the syndrome decoding simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/ECC.jl#L123-L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.iscss-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:QuantumClifford.ECC.AbstractECC" href="#QuantumClifford.ECC.iscss-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:QuantumClifford.ECC.AbstractECC"><code>QuantumClifford.ECC.iscss</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check if the code is CSS.</p><p>Return <code>nothing</code> if unknown from the type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/ECC.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.isdegenerate" href="#QuantumClifford.ECC.isdegenerate"><code>QuantumClifford.ECC.isdegenerate</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Check if the code is degenerate with respect to a given set of error or with respect to all &quot;up to d physical-qubit&quot; errors (defaulting to d=1).</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford.ECC

julia&gt; isdegenerate(Shor9(), [single_z(9,1), single_z(9,2)])
true

julia&gt; isdegenerate(Shor9(), [single_z(9,1), single_x(9,1)])
false

julia&gt; isdegenerate(Steane7(), 1)
false

julia&gt; isdegenerate(Steane7(), 2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/ECC.jl#L310">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.naive_encoding_circuit-Tuple{Any}" href="#QuantumClifford.ECC.naive_encoding_circuit-Tuple{Any}"><code>QuantumClifford.ECC.naive_encoding_circuit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Encoding physical qubits into a larger logical code.</p><p>The initial physical qubits to be encoded have to be at indices <code>n-k+1:n</code>.</p><div class="admonition is-info"><header class="admonition-header">Encoding circuits are not fault-tolerant</header><div class="admonition-body"><p>Encoding circuits are not fault-tolerant, and thus should not be used in practice. Instead, you should measure the stabilizers of the code and the logical observables, thus projecting into the code space (which can be fault-tolerant).</p></div></div><p>The canonicalization operation performed on the code may permute the qubits (see <a href="../API/#QuantumClifford.canonicalize_gott!-Tuple{Stabilizer}"><code>canonicalize_gott!</code></a>). That permutation is corrected for with SWAP gates by default (controlled by the <code>undoperm</code> keyword argument).</p><p>Based on (<a href="../references/#cleve1997efficient">Cleve and Gottesman, 1997</a>) and (<a href="../references/#gottesman1997stabilizer">Gottesman, 1997</a>), however it seems the published algorithm has some errors. Consult the erratum, as well as the more recent (<a href="../references/#grassl2002algorithmic">Grassl, 2002</a>) and (<a href="../references/#grassl2011variations">Grassl, 2011</a>), and be aware that this implementation also uses H instead of Z gates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/circuits.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.naive_syndrome_circuit" href="#QuantumClifford.ECC.naive_syndrome_circuit"><code>QuantumClifford.ECC.naive_syndrome_circuit</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Generate the non-fault-tolerant stabilizer measurement cicuit for a given code instance or parity check tableau.</p><p>Use the <code>ancillary_index</code> and <code>bit_index</code> arguments to offset where the corresponding part the circuit starts.</p><p>Returns the circuit, the number of ancillary qubits that were added, and a list of bit indices that will store the measurement results.</p><p>See also: <a href="#QuantumClifford.ECC.shor_syndrome_circuit"><code>shor_syndrome_circuit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/circuits.jl#L84-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.parity_checks" href="#QuantumClifford.ECC.parity_checks"><code>QuantumClifford.ECC.parity_checks</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Parity check tableau of a code.</p><p>See also: <a href="#QuantumClifford.ECC.parity_checks_x-Tuple{QuantumClifford.ECC.AbstractECC}"><code>parity_checks_x</code></a> and <a href="#QuantumClifford.ECC.parity_checks_z-Tuple{QuantumClifford.ECC.AbstractECC}"><code>parity_checks_z</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/ECC.jl#L30-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.parity_checks_x-Tuple{QuantumClifford.ECC.AbstractECC}" href="#QuantumClifford.ECC.parity_checks_x-Tuple{QuantumClifford.ECC.AbstractECC}"><code>QuantumClifford.ECC.parity_checks_x</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parity check boolean matrix of a code (only the X entries in the tableau, i.e. the checks for Z errors).</p><p>Only CSS codes have this method.</p><p>See also: <a href="#QuantumClifford.ECC.parity_checks"><code>parity_checks</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/ECC.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.parity_checks_z-Tuple{QuantumClifford.ECC.AbstractECC}" href="#QuantumClifford.ECC.parity_checks_z-Tuple{QuantumClifford.ECC.AbstractECC}"><code>QuantumClifford.ECC.parity_checks_z</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parity check boolean matrix of a code (only the Z entries in the tableau, i.e. the checks for X errors).</p><p>Only CSS codes have this method.</p><p>See also: <a href="#QuantumClifford.ECC.parity_checks"><code>parity_checks</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/ECC.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.random_all_to_all_circuit_code" href="#QuantumClifford.ECC.random_all_to_all_circuit_code"><code>QuantumClifford.ECC.random_all_to_all_circuit_code</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Random all-to-all Clifford circuit code (<a href="../references/#brown2013short">Brown and Fawzi, Jul 2013</a>).</p><p>The code of <code>n</code> qubits is generated by an all-to-all random Clifford circuit of <code>ngates</code> gates that encodes a subset of qubits <code>encode_qubits</code> into logical qubits.</p><p>Because of the random picking, the size of <code>encode_qubits</code> is the only thing that matters for the code, referred to as <code>k</code>.</p><p>See also: <a href="../API/#QuantumClifford.random_all_to_all_clifford_circuit-Tuple{Random.AbstractRNG, Int64, Int64}"><code>random_all_to_all_clifford_circuit</code></a>, <a href="#QuantumClifford.ECC.CircuitCode"><code>CircuitCode</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/codes/random_circuit.jl#L34-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.random_brickwork_circuit_code" href="#QuantumClifford.ECC.random_brickwork_circuit_code"><code>QuantumClifford.ECC.random_brickwork_circuit_code</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Random brickwork Clifford circuit code (<a href="../references/#brown2013short">Brown and Fawzi, Jul 2013</a>).</p><p>The code is generated by a brickwork random Clifford circuit of <code>nlayers</code> layers that encodes a subset of qubits <code>encode_qubits</code> into logical qubits.</p><p>See also: <a href="../API/#QuantumClifford.random_brickwork_clifford_circuit-Tuple{Random.AbstractRNG, Tuple{Vararg{Int64, N}} where N, Int64}"><code>random_brickwork_clifford_circuit</code></a>, <a href="#QuantumClifford.ECC.CircuitCode"><code>CircuitCode</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/codes/random_circuit.jl#L62-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.rate-Tuple{Any}" href="#QuantumClifford.ECC.rate-Tuple{Any}"><code>QuantumClifford.ECC.rate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The rate of a code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/ECC.jl#L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.shor_syndrome_circuit" href="#QuantumClifford.ECC.shor_syndrome_circuit"><code>QuantumClifford.ECC.shor_syndrome_circuit</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Generate the Shor fault-tolerant stabilizer measurement cicuit for a given code instance or parity check tableau.</p><p>Use the <code>ancillary_index</code> and <code>bit_index</code> arguments to offset where the corresponding part the circuit starts. Ancillary qubits</p><p>Returns:</p><ul><li>The ancillary cat state preparation circuit.</li><li>The Shor syndrome measurement circuit.</li><li>The number of ancillary qubits that were added.</li><li>The list of bit indices that store the final measurement results.</li></ul><p>See also: <a href="#QuantumClifford.ECC.naive_syndrome_circuit"><code>naive_syndrome_circuit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/59e399d17ddb1430482ed343d221680754b54bf0/src/ecc/circuits.jl#L139-L152">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ECC_evaluating/">« Evaluating codes and decoders</a><a class="docs-footer-nextpage" href="../allops/">All Gates »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Friday 5 July 2024 00:09">Friday 5 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

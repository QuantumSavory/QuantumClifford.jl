<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · QuantumClifford.jl</title><meta name="title" content="API · QuantumClifford.jl"/><meta property="og:title" content="API · QuantumClifford.jl"/><meta property="twitter:title" content="API · QuantumClifford.jl"/><meta name="description" content="Documentation for QuantumClifford.jl."/><meta property="og:description" content="Documentation for QuantumClifford.jl."/><meta property="twitter:description" content="Documentation for QuantumClifford.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumClifford.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">QuantumClifford.jl</a></li><li><span class="tocitem">Stabilizer Tableau Algebra</span><ul><li><a class="tocitem" href="../stab-algebra-manual/">Manual</a></li><li><a class="tocitem" href="../canonicalization/">Canonicalization</a></li><li><a class="tocitem" href="../mixed/">Mixed States</a></li><li><a class="tocitem" href="../graphs/">Graph States</a></li><li><a class="tocitem" href="../datastructures/">Datastructure Choice</a></li><li><a class="tocitem" href="../commonstates/">Useful States</a></li></ul></li><li><span class="tocitem">Noisy Circuits</span><ul><li><a class="tocitem" href="../noisycircuits/">Simulation of Noisy Circuits</a></li><li><a class="tocitem" href="../noisycircuits_mc/">Monte Carlo</a></li><li><a class="tocitem" href="../noisycircuits_perturb/">Perturbative Expansions</a></li><li><a class="tocitem" href="../ecc_example_sim/">ECC example</a></li><li><a class="tocitem" href="../noisycircuits_ops/">Circuit Operations</a></li><li><a class="tocitem" href="../noisycircuits_API/">API</a></li></ul></li><li><span class="tocitem">ECC compendium</span><ul><li><a class="tocitem" href="../ECC_evaluating/">Evaluating codes and decoders</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Implemented-in-an-extension-requiring-Hecke.jl"><span>Implemented in an extension requiring <code>Hecke.jl</code></span></a></li></ul></li></ul></li><li><a class="tocitem" href="../allops/">All Gates</a></li><li><a class="tocitem" href="../plotting/">Visualizations</a></li><li><a class="tocitem" href="../API/">API</a></li><li><a class="tocitem" href="../tutandpub/">Tutorials and Publications</a></li><li><a class="tocitem" href="../references/">Suggested Readings &amp; References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ECC compendium</a></li><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumSavory/QuantumClifford.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/master/docs/src/ECC_API.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Full-ECC-API-(autogenerated)"><a class="docs-heading-anchor" href="#Full-ECC-API-(autogenerated)">Full ECC API (autogenerated)</a><a id="Full-ECC-API-(autogenerated)-1"></a><a class="docs-heading-anchor-permalink" href="#Full-ECC-API-(autogenerated)" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.CSS" href="#QuantumClifford.ECC.CSS"><code>QuantumClifford.ECC.CSS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>An arbitrary CSS error correcting code defined by its X and Z checks.</p><pre><code class="language-julia-repl hljs">julia&gt; CSS([0 1 1 0; 1 1 0 0], [1 1 1 1]) |&gt; parity_checks
+ _XX_
+ XX__
+ ZZZZ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/codes/css.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.CircuitCode" href="#QuantumClifford.ECC.CircuitCode"><code>QuantumClifford.ECC.CircuitCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>CircuitCode</code> is defined by a given encoding circuit <code>circ</code>.</p><ul><li><code>n</code>: qubit number</li><li><code>circ</code>: the encoding circuit</li><li><code>encode_qubits</code>: the qubits to be encoded</li></ul><p>See also: <a href="#QuantumClifford.ECC.random_all_to_all_circuit_code"><code>random_all_to_all_circuit_code</code></a>, <a href="#QuantumClifford.ECC.random_brickwork_circuit_code"><code>random_brickwork_circuit_code</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/codes/random_circuit.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.Cleve8" href="#QuantumClifford.ECC.Cleve8"><code>QuantumClifford.ECC.Cleve8</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A pedagogical example of a quantum error correcting [8,3] code used in (<a href="../references/#cleve1997efficient">Cleve and Gottesman, 1997</a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/codes/clevecode.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.CommutationCheckECCSetup" href="#QuantumClifford.ECC.CommutationCheckECCSetup"><code>QuantumClifford.ECC.CommutationCheckECCSetup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Configuration for ECC evaluator that does not simulate any ECC circuits, rather it simply checks the commutation of the parity check and the Pauli error.</p><p>This is much faster than any other simulation method, but it is incapable of noisy-circuit simulations and thus useless for fault-tolerance studies.</p><p>See also: <a href="#QuantumClifford.ECC.NaiveSyndromeECCSetup"><code>NaiveSyndromeECCSetup</code></a>, <a href="#QuantumClifford.ECC.ShorSyndromeECCSetup"><code>ShorSyndromeECCSetup</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/decoder_pipeline.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.Concat" href="#QuantumClifford.ECC.Concat"><code>QuantumClifford.ECC.Concat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Concat(c₁, c₂)</code> is a code concatenation of two quantum codes (<a href="../references/#knill1996concatenated">Knill and Laflamme, 1996</a>).</p><p>The inner code c₁ and the outer code c₂. The construction is the following: replace each qubit in code c₂ with logical qubits encoded by code c₁. The resulting code will have <code>n = n₁ × n₂</code> qubits and <code>k = k₁ × k₂</code> logical qubits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/codes/concat.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.Gottesman" href="#QuantumClifford.ECC.Gottesman"><code>QuantumClifford.ECC.Gottesman</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The family of <code>[[2ʲ, 2ʲ - j - 2, 3]]</code> Gottesman codes, also known as quantum Hamming codes, as described in <a href="../references/#gottesman1997stabilizer">Gottesman&#39;s 1997 PhD thesis</a> and in (<a href="../references/#gottesman1996class">Gottesman, 1996</a>).</p><p>You might be interested in consulting (<a href="../references/#yu2013all">Yu <em>et al.</em>, 2013</a>) and (<a href="../references/#chao2018quantum">Chao and Reichardt, 2017</a>) as well.</p><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/quantum_hamming">entry for this family</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/codes/gottesman.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.NaiveSyndromeECCSetup" href="#QuantumClifford.ECC.NaiveSyndromeECCSetup"><code>QuantumClifford.ECC.NaiveSyndromeECCSetup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Configuration for ECC evaluator that runs the simplest syndrome measurement circuit.</p><p>The circuit is being simulated (as opposed to doing only a quick commutation check). This circuit would give poor performance if there is non-zero gate noise.</p><p>See also: <a href="#QuantumClifford.ECC.CommutationCheckECCSetup"><code>CommutationCheckECCSetup</code></a>, <a href="#QuantumClifford.ECC.ShorSyndromeECCSetup"><code>ShorSyndromeECCSetup</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/decoder_pipeline.jl#L46-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.QuantumReedMuller" href="#QuantumClifford.ECC.QuantumReedMuller"><code>QuantumClifford.ECC.QuantumReedMuller</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The family of <code>[[2ᵐ - 1, 1, 3]]</code> CSS Quantum-Reed-Muller codes, as discovered by Steane in his 1999 paper (<a href="../references/#steane1999quantum">Steane, 1999</a>).</p><p>Quantum codes are constructed from shortened Reed-Muller codes <code>RM(1, m)</code>, by removing the first row and column of the generator matrix <code>Gₘ</code>. Similarly, we can define truncated dual codes <code>RM(m - 2, m)</code> using the generator matrix <code>Hₘ</code> (<a href="../references/#anderson2014fault">Anderson <em>et al.</em>, 2014</a>). The quantum Reed-Muller codes <code>QRM(m)</code> derived from <code>RM(1, m)</code> are CSS codes. </p><p>Given that the stabilizers of the quantum code are defined through the generator matrix of the classical code, the minimum distance of the quantum code corresponds to the minimum distance of the dual classical code, which is <code>d = 3</code>, thus it can correct any single qubit error. Since one stabilizer from the original and one from the dual code are removed in the truncation process, the code parameters are <code>[[2ᵐ - 1, 1, 3]]</code>.</p><p>You might be interested in consulting (<a href="../references/#anderson2014fault">Anderson <em>et al.</em>, 2014</a>) and (<a href="../references/#campbell2012magic">Campbell <em>et al.</em>, 2012</a>) as well.</p><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/quantum_reed_muller">entry for this family</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/codes/quantumreedmuller.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.ShorSyndromeECCSetup" href="#QuantumClifford.ECC.ShorSyndromeECCSetup"><code>QuantumClifford.ECC.ShorSyndromeECCSetup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Configuration for ECC evaluators that simulate the Shor-style syndrome measurement (without a flag qubit).</p><p>The simulated circuit includes:</p><ul><li>perfect noiseless encoding (encoding and its fault tolerance are not being studied here)</li><li>one round of &quot;memory noise&quot; after the encoding but before the syndrome measurement</li><li>perfect preparation of entangled ancillary qubits</li><li>noisy Shor-style syndrome measurement (only two-qubit gate noise)</li><li>noiseless &quot;logical state measurement&quot; (providing the comparison data when evaluating the decoder)</li></ul><p>See also: <a href="#QuantumClifford.ECC.CommutationCheckECCSetup"><code>CommutationCheckECCSetup</code></a>, <a href="#QuantumClifford.ECC.NaiveSyndromeECCSetup"><code>NaiveSyndromeECCSetup</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/decoder_pipeline.jl#L62-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.Surface" href="#QuantumClifford.ECC.Surface"><code>QuantumClifford.ECC.Surface</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The planar surface code refers to the code (<a href="../references/#kitaev2003fault">Kitaev, 2003</a>) in a 2D lattice with open boundaries.</p><p>Illustration of a 3×2 surface code, where qubits are located on the edges:</p><pre><code class="nohighlight hljs">|---1--(Z)--2---|---3---|
|  (X)  7       8       o
|---4---|---5---|---6---|
|       o       o       o
|       |       |       |</code></pre><p>The surface code has open boundary conditions, unlike the toric code. To this end, we remove qubits (denoted by &quot;o&quot;) and parity checks on the right and bottom sides.</p><p>Faces like <code>(1,4,7)</code> have X checks, and crosses like <code>(1,2,7)</code> have Z checks. Due to the removal of the bottom and right sides, we have some 3-qubit checks on the boundaries.</p><pre><code class="language-julia-repl hljs">julia&gt; parity_checks(Surface(3,2))
+ X__X__X_
+ _X__X_XX
+ __X__X_X
+ ZZ____Z_
+ _ZZ____Z
+ ___ZZ_Z_
+ ____ZZ_Z</code></pre><p>More information can be seen in (<a href="../references/#fowler2012surface">Fowler <em>et al.</em>, 2012</a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/codes/surface.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.TableDecoder" href="#QuantumClifford.ECC.TableDecoder"><code>QuantumClifford.ECC.TableDecoder</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A simple look-up table decoder for error correcting codes.</p><p>The lookup table contains only weight=1 errors, thus it is small, but at best it provides only for distance=3 decoding.</p><p>The size of the lookup table would grow exponentially quickly for higher distances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/decoder_pipeline.jl#L210-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.Toric" href="#QuantumClifford.ECC.Toric"><code>QuantumClifford.ECC.Toric</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The Toric code (<a href="../references/#kitaev2003fault">Kitaev, 2003</a>).</p><p>Illustration of a 2x2 toric code, where qubits are located on the edges:</p><pre><code class="nohighlight hljs">|--1-(Z)-2--|
| (X) 5     6
|--3--|--4--|
|     7     8
|     |     |</code></pre><p>It is important to note that the toric code has periodic boundary conditions, which means that the top and bottom sides are essentially glued together, as are the left and right sides.</p><p>Faces like <code>(1,3,5,6)</code> have X checks, and crosses like <code>(1,2,5,7)</code> have Z checks.</p><pre><code class="language-julia-repl hljs">julia&gt; parity_checks(Toric(2,2))
+ X_X_XX__
+ _X_XXX__
+ X_X___XX
+ ZZ__Z_Z_
+ ZZ___Z_Z
+ __ZZZ_Z_</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/codes/toric.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.BeliefPropDecoder-Tuple" href="#QuantumClifford.ECC.BeliefPropDecoder-Tuple"><code>QuantumClifford.ECC.BeliefPropDecoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A simple Belief Propagation decoder built around tools from <code>LDPCDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/decoder_pipeline.jl#L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.BitFlipDecoder-Tuple" href="#QuantumClifford.ECC.BitFlipDecoder-Tuple"><code>QuantumClifford.ECC.BitFlipDecoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>An Iterative Bitflip decoder built around tools from <code>LDPCDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/decoder_pipeline.jl#L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.LPCode-Tuple" href="#QuantumClifford.ECC.LPCode-Tuple"><code>QuantumClifford.ECC.LPCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Lifted product codes ((<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>), (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>))</p><p>Implemented as a package extension with Hecke. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/codes/lifted_product.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.LiftedCode-Tuple" href="#QuantumClifford.ECC.LiftedCode-Tuple"><code>QuantumClifford.ECC.LiftedCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Classical codes lifted over a group algebra, used for lifted product code construction ((<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>), (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>))</p><p>Implemented as a package extension with Hecke. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/codes/classical/lifted.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.PyBeliefPropDecoder-Tuple" href="#QuantumClifford.ECC.PyBeliefPropDecoder-Tuple"><code>QuantumClifford.ECC.PyBeliefPropDecoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A Belief Propagation decoder built around tools from the python package <code>ldpc</code> available from the julia package <code>PyQDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/decoder_pipeline.jl#L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.PyBeliefPropOSDecoder-Tuple" href="#QuantumClifford.ECC.PyBeliefPropOSDecoder-Tuple"><code>QuantumClifford.ECC.PyBeliefPropOSDecoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A Belief Propagation decoder with ordered statistics decoding, built around tools from the python package <code>ldpc</code> available from the julia package <code>PyQDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/decoder_pipeline.jl#L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.PyMatchingDecoder-Tuple" href="#QuantumClifford.ECC.PyMatchingDecoder-Tuple"><code>QuantumClifford.ECC.PyMatchingDecoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A perfect matching decoder built around tools from the python package <code>pymatching</code> available from the julia package <code>PyQDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/decoder_pipeline.jl#L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.bicycle_codes" href="#QuantumClifford.ECC.bicycle_codes"><code>QuantumClifford.ECC.bicycle_codes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Hecke.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/codes/lifted_product.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.code_k-Tuple{Stabilizer}" href="#QuantumClifford.ECC.code_k-Tuple{Stabilizer}"><code>QuantumClifford.ECC.code_k</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The number of logical qubits in a code.</p><p>Note that when redundant rows exist in the parity check matrix, the number of logical qubits <code>code_k(c)</code> will be greater than <code>code_n(c) - code_s(c)</code>, where the difference equals the redundancy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/ECC.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.code_n" href="#QuantumClifford.ECC.code_n"><code>QuantumClifford.ECC.code_n</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The number of physical qubits in a code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/ECC.jl#L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.code_s" href="#QuantumClifford.ECC.code_s"><code>QuantumClifford.ECC.code_s</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The number of stabilizer checks in a code. They might not be all linearly independent, thus <code>code_s &gt;= code_n-code_k</code>. For the number of linearly independent checks you can use <code>LinearAlgebra.rank</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/ECC.jl#L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.distance" href="#QuantumClifford.ECC.distance"><code>QuantumClifford.ECC.distance</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The distance of a code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/ECC.jl#L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, QuantumClifford.ECC.AbstractECCSetup, Int64}" href="#QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, QuantumClifford.ECC.AbstractECCSetup, Int64}"><code>QuantumClifford.ECC.evaluate_decoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Evaluate the performance of a given decoder (e.g. <a href="#QuantumClifford.ECC.TableDecoder"><code>TableDecoder</code></a>) and a given style of running an ECC code (e.g. <a href="#QuantumClifford.ECC.ShorSyndromeECCSetup"><code>ShorSyndromeECCSetup</code></a>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/decoder_pipeline.jl#L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, Vararg{Any, 5}}" href="#QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, Vararg{Any, 5}}"><code>QuantumClifford.ECC.evaluate_decoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Evaluate the performance of an error-correcting circuit.</p><p>This method requires you give the circuit that performs both syndrome measurements and (probably noiseless) logical state measurements. The faults matrix that translates an error vector into corresponding logical errors is necessary as well.</p><p>This is a relatively barebones method that assumes the user prepares necessary circuits, etc. It is a method that is used internally by more user-frienly methods providing automatic conversion of codes and noise models to the necessary noisy circuits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/decoder_pipeline.jl#L154-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.faults_matrix-Tuple{Stabilizer}" href="#QuantumClifford.ECC.faults_matrix-Tuple{Stabilizer}"><code>QuantumClifford.ECC.faults_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Error-to-logical-observable map (a.k.a. fault matrix) of a code.</p><p>For a code with n physical qubits and k logical qubits this function returns a 2k × 2n binary matrix O such that <code>O[i,j]</code> is true if the logical observable of index <code>i</code> is flipped by the single physical qubit error of index <code>j</code>. Indexing is such that:</p><ul><li><code>O[1:k,:]</code> is the error-to-logical-X-observable map (logical X observable, i.e. triggered by logical Z errors)</li><li><code>O[k+1:2k,:]</code> is the error-to-logical-Z-observable map</li><li><code>O[:,1:n]</code> is the X-physical-error-to-logical-observable map</li><li><code>O[n+1:2n,:]</code> is the Z-physical-error-to-logical-observable map</li></ul><p>E.g. for <code>k=1</code>, <code>n=10</code>, then if <code>O[2,5]</code> is true, then the logical Z observable is flipped by a X₅ error; and if <code>O[1,12]</code> is true, then the logical X observable is flipped by a Z₂ error.</p><p>Of note is that there is a lot of freedom in choosing the logical operations! A logical operator multiplied by a stabilizer operator is still a logical operator. Similarly there is a different fault matrix for each choice of logical operators. But once the logical operators are picked, the fault matrix is fixed.</p><p>Below we show an example that uses the Shor code. While it is not the smallest code, it is a convenient choice to showcase the importance of the fault matrix when dealing with degenerate codes where a correction operation and an error do not need to be the same.</p><p>First, consider a single-qubit error, potential correction operations, and their effect on the Shor code:</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford.ECC: faults_matrix, Shor9

julia&gt; state = MixedDestabilizer(Shor9())
𝒟ℯ𝓈𝓉𝒶𝒷━━━━━
+ Z________
+ ___Z_____
+ _X_______
+ __X______
+ ____X____
+ _____X___
+ ______X__
+ _______X_
𝒳ₗ━━━━━━━━━
+ ______XXX
𝒮𝓉𝒶𝒷━━━━━━━
+ XXX___XXX
+ ___XXXXXX
+ ZZ_______
+ Z_Z______
+ ___ZZ____
+ ___Z_Z___
+ ______Z_Z
+ _______ZZ
𝒵ₗ━━━━━━━━━
+ Z__Z____Z

julia&gt; err_Z₁ = single_z(9,1) # the error we will simulate
+ Z________

julia&gt; cor_Z₂ = single_z(9,2) # the correction operation we will perform
+ _Z_______

julia&gt; err_Z₁ * state # observe that one of the syndrome bits is now flipped
𝒟ℯ𝓈𝓉𝒶𝒷━━━━━
+ Z________
+ ___Z_____
+ _X_______
+ __X______
+ ____X____
+ _____X___
+ ______X__
+ _______X_
𝒳ₗ━━━━━━━━━
+ ______XXX
𝒮𝓉𝒶𝒷━━━━━━━
- XXX___XXX
+ ___XXXXXX
+ ZZ_______
+ Z_Z______
+ ___ZZ____
+ ___Z_Z___
+ ______Z_Z
+ _______ZZ
𝒵ₗ━━━━━━━━━
+ Z__Z____Z

julia&gt; cor_Z₂ * err_Z₁ * state # we are back to a good code state
𝒟ℯ𝓈𝓉𝒶𝒷━━━━━
+ Z________
+ ___Z_____
- _X_______
+ __X______
+ ____X____
+ _____X___
+ ______X__
+ _______X_
𝒳ₗ━━━━━━━━━
+ ______XXX
𝒮𝓉𝒶𝒷━━━━━━━
+ XXX___XXX
+ ___XXXXXX
+ ZZ_______
+ Z_Z______
+ ___ZZ____
+ ___Z_Z___
+ ______Z_Z
+ _______ZZ
𝒵ₗ━━━━━━━━━
+ Z__Z____Z

julia&gt; bad_Z₆Z₉ = single_z(9,6) * single_z(9,9) # a different &quot;correction&quot; operation
+ _____Z__Z

julia&gt; bad_Z₆Z₉ * err_Z₁ * state # the syndrome is trivial, but now we have a logical error
𝒟ℯ𝓈𝓉𝒶𝒷━━━━━
+ Z________
+ ___Z_____
+ _X_______
+ __X______
+ ____X____
- _____X___
+ ______X__
+ _______X_
𝒳ₗ━━━━━━━━━
- ______XXX
𝒮𝓉𝒶𝒷━━━━━━━
+ XXX___XXX
+ ___XXXXXX
+ ZZ_______
+ Z_Z______
+ ___ZZ____
+ ___Z_Z___
+ ______Z_Z
+ _______ZZ
𝒵ₗ━━━━━━━━━
+ Z__Z____Z</code></pre><p>The success of <code>cor_Z₂</code> and the failure of <code>bad_Z₆Z₉</code> can be immediately seen through the fault matrix, as the wrong &quot;correction&quot; does not result in the same logical flips ad the error:</p><pre><code class="language-julia-repl hljs">julia&gt; O = faults_matrix(Shor9())
2×18 BitMatrix:
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1
 1  0  0  1  0  0  0  0  1  0  0  0  0  0  0  0  0  0

julia&gt; O * stab_to_gf2(err_Z₁)
2-element Vector{Int64}:
 0
 0

julia&gt; O * stab_to_gf2(cor_Z₂)
2-element Vector{Int64}:
 0
 0

julia&gt; O * stab_to_gf2(bad_Z₆Z₉)
2-element Vector{Int64}:
 1
 0</code></pre><p>While its use in this situation is rather contrived, the fault matrix is incredibly useful when running large scale simulations in which we want a separate fast error sampling process, (e.g. with Pauli frames) and a syndrome decoding process, without coupling between them. We just gather all our syndrome measurement <strong>and logical observables</strong> from the Pauli frame simulations, and then use them with the fault matrix in the syndrome decoding simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/ECC.jl#L144-L312">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.generalized_bicycle_codes" href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>QuantumClifford.ECC.generalized_bicycle_codes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Hecke.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/codes/lifted_product.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.haah_cubic_codes" href="#QuantumClifford.ECC.haah_cubic_codes"><code>QuantumClifford.ECC.haah_cubic_codes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Hecke.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/codes/lifted_product.jl#L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.iscss-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:QuantumClifford.ECC.AbstractECC" href="#QuantumClifford.ECC.iscss-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:QuantumClifford.ECC.AbstractECC"><code>QuantumClifford.ECC.iscss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Check if the code is CSS.</p><p>Return <code>nothing</code> if unknown from the type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/ECC.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.isdegenerate" href="#QuantumClifford.ECC.isdegenerate"><code>QuantumClifford.ECC.isdegenerate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Check if the code is degenerate with respect to a given set of error or with respect to all &quot;up to d physical-qubit&quot; errors (defaulting to d=1).</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford.ECC

julia&gt; isdegenerate(Shor9(), [single_z(9,1), single_z(9,2)])
true

julia&gt; isdegenerate(Shor9(), [single_z(9,1), single_x(9,1)])
false

julia&gt; isdegenerate(Steane7(), 1)
false

julia&gt; isdegenerate(Steane7(), 2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/ECC.jl#L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.naive_encoding_circuit-Tuple{Any}" href="#QuantumClifford.ECC.naive_encoding_circuit-Tuple{Any}"><code>QuantumClifford.ECC.naive_encoding_circuit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Encoding physical qubits into a larger logical code.</p><p>The initial physical qubits to be encoded have to be at indices <code>n-k+1:n</code>.</p><div class="admonition is-info"><header class="admonition-header">Encoding circuits are not fault-tolerant</header><div class="admonition-body"><p>Encoding circuits are not fault-tolerant, and thus should not be used in practice. Instead, you should measure the stabilizers of the code and the logical observables, thus projecting into the code space (which can be fault-tolerant).</p></div></div><p>The canonicalization operation performed on the code may permute the qubits (see <a href="../API/#QuantumClifford.canonicalize_gott!-Tuple{Stabilizer}"><code>canonicalize_gott!</code></a>). That permutation is corrected for with SWAP gates by default (controlled by the <code>undoperm</code> keyword argument).</p><p>Based on (<a href="../references/#cleve1997efficient">Cleve and Gottesman, 1997</a>) and (<a href="../references/#gottesman1997stabilizer">Gottesman, 1997</a>), however it seems the published algorithm has some errors. Consult the erratum, as well as the more recent (<a href="../references/#grassl2002algorithmic">Grassl, 2002</a>) and (<a href="../references/#grassl2011variations">Grassl, 2011</a>), and be aware that this implementation also uses H instead of Z gates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/circuits.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.naive_syndrome_circuit" href="#QuantumClifford.ECC.naive_syndrome_circuit"><code>QuantumClifford.ECC.naive_syndrome_circuit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Generate the non-fault-tolerant stabilizer measurement cicuit for a given code instance or parity check tableau.</p><p>Use the <code>ancillary_index</code> and <code>bit_index</code> arguments to offset where the corresponding part the circuit starts.</p><p>Returns the circuit, the number of ancillary qubits that were added, and a list of bit indices that will store the measurement results.</p><p>See also: <a href="#QuantumClifford.ECC.shor_syndrome_circuit"><code>shor_syndrome_circuit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/circuits.jl#L85-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.parity_checks" href="#QuantumClifford.ECC.parity_checks"><code>QuantumClifford.ECC.parity_checks</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parity check tableau of a code.</p><p>See also: <a href="#QuantumClifford.ECC.parity_checks_x-Tuple{QuantumClifford.ECC.AbstractECC}"><code>parity_checks_x</code></a> and <a href="#QuantumClifford.ECC.parity_checks_z-Tuple{QuantumClifford.ECC.AbstractECC}"><code>parity_checks_z</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/ECC.jl#L40-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.parity_checks_x-Tuple{QuantumClifford.ECC.AbstractECC}" href="#QuantumClifford.ECC.parity_checks_x-Tuple{QuantumClifford.ECC.AbstractECC}"><code>QuantumClifford.ECC.parity_checks_x</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parity check boolean matrix of a code (only the X entries in the tableau, i.e. the checks for Z errors).</p><p>Only CSS codes have this method.</p><p>See also: <a href="#QuantumClifford.ECC.parity_checks"><code>parity_checks</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/ECC.jl#L45-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.parity_checks_z-Tuple{QuantumClifford.ECC.AbstractECC}" href="#QuantumClifford.ECC.parity_checks_z-Tuple{QuantumClifford.ECC.AbstractECC}"><code>QuantumClifford.ECC.parity_checks_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parity check boolean matrix of a code (only the Z entries in the tableau, i.e. the checks for X errors).</p><p>Only CSS codes have this method.</p><p>See also: <a href="#QuantumClifford.ECC.parity_checks"><code>parity_checks</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/ECC.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.random_all_to_all_circuit_code" href="#QuantumClifford.ECC.random_all_to_all_circuit_code"><code>QuantumClifford.ECC.random_all_to_all_circuit_code</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Random all-to-all Clifford circuit code (<a href="../references/#brown2013short">Brown and Fawzi, Jul 2013</a>).</p><p>The code of <code>n</code> qubits is generated by an all-to-all random Clifford circuit of <code>ngates</code> gates that encodes a subset of qubits <code>encode_qubits</code> into logical qubits.</p><p>Because of the random picking, the size of <code>encode_qubits</code> is the only thing that matters for the code, referred to as <code>k</code>.</p><p>See also: <a href="../API/#QuantumClifford.random_all_to_all_clifford_circuit-Tuple{Random.AbstractRNG, Int64, Int64}"><code>random_all_to_all_clifford_circuit</code></a>, <a href="#QuantumClifford.ECC.CircuitCode"><code>CircuitCode</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/codes/random_circuit.jl#L34-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.random_brickwork_circuit_code" href="#QuantumClifford.ECC.random_brickwork_circuit_code"><code>QuantumClifford.ECC.random_brickwork_circuit_code</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Random brickwork Clifford circuit code (<a href="../references/#brown2013short">Brown and Fawzi, Jul 2013</a>).</p><p>The code is generated by a brickwork random Clifford circuit of <code>nlayers</code> layers that encodes a subset of qubits <code>encode_qubits</code> into logical qubits.</p><p>See also: <a href="../API/#QuantumClifford.random_brickwork_clifford_circuit-Tuple{Random.AbstractRNG, NTuple{N, Int64} where N, Int64}"><code>random_brickwork_clifford_circuit</code></a>, <a href="#QuantumClifford.ECC.CircuitCode"><code>CircuitCode</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/codes/random_circuit.jl#L62-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.rate-Tuple{Any}" href="#QuantumClifford.ECC.rate-Tuple{Any}"><code>QuantumClifford.ECC.rate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The rate of a code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/ECC.jl#L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.shor_syndrome_circuit" href="#QuantumClifford.ECC.shor_syndrome_circuit"><code>QuantumClifford.ECC.shor_syndrome_circuit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Generate the Shor fault-tolerant stabilizer measurement cicuit for a given code instance or parity check tableau.</p><p>Use the <code>ancillary_index</code> and <code>bit_index</code> arguments to offset where the corresponding part the circuit starts. Ancillary qubits</p><p>Returns:</p><ul><li>The ancillary cat state preparation circuit.</li><li>The Shor syndrome measurement circuit.</li><li>The number of ancillary qubits that were added.</li><li>The list of bit indices that store the final measurement results.</li></ul><p>See also: <a href="#QuantumClifford.ECC.naive_syndrome_circuit"><code>naive_syndrome_circuit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/circuits.jl#L140-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.two_block_group_algebra_codes" href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>QuantumClifford.ECC.two_block_group_algebra_codes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Hecke.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/src/ecc/codes/lifted_product.jl#L12">source</a></section></article><h2 id="Implemented-in-an-extension-requiring-Hecke.jl"><a class="docs-heading-anchor" href="#Implemented-in-an-extension-requiring-Hecke.jl">Implemented in an extension requiring <code>Hecke.jl</code></a><a id="Implemented-in-an-extension-requiring-Hecke.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Implemented-in-an-extension-requiring-Hecke.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordHeckeExt.LPCode" href="#QuantumCliffordHeckeExt.LPCode"><code>QuantumCliffordHeckeExt.LPCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LPCode &lt;: QuantumClifford.ECC.AbstractECC</code></pre><p>Lifted product codes ((<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>), (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>))</p><p>A lifted product code is defined by the hypergraph product of a base matrices <code>A</code> and the conjugate of another base matrix <code>B&#39;</code>. Here, the hypergraph product is taken over a group algebra, of which the base matrices are consisting.</p><p>The binary parity check matrix is obtained by applying <code>repr</code> to each element of the matrix resulted from the hypergraph product, which is mathematically a linear map from each group algebra element to a binary matrix.</p><p><strong>Constructors</strong></p><p>Multiple constructors are available:</p><ol><li><p>Two base matrices of group algebra elements.</p></li><li><p>Two lifted codes, whose base matrices are for quantum code construction.</p></li><li><p>Two base matrices of group elements, where each group element will be considered as a group algebra element by assigning a unit coefficient.</p></li><li><p>Two base matrices of integers, where each integer represent the shift of a cyclic permutation. The order of the cyclic permutation should be specified.</p></li></ol><p><strong>Examples</strong></p><p>A [[882, 24, d ≤ 24]] code from Appendix B of (<a href="../references/#roffe2023bias">Roffe <em>et al.</em>, 2023</a>). We use the 1st constructor to generate the code and check its length and dimension. During the construction, we do arithmetic operations to get the group algebra elements in base matrices <code>A</code> and <code>B</code>. Here <code>x</code> is the generator of the group algebra, i.e., offset-1 cyclic permutation, and <code>GA(1)</code> is the unit element.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; import LinearAlgebra: diagind; using QuantumClifford.ECC;

julia&gt; l = 63; GA = group_algebra(GF(2), abelian_group(l)); x = gens(GA)[];

julia&gt; A = zeros(GA, 7, 7);

julia&gt; A[diagind(A)] .= x^27;

julia&gt; A[diagind(A, -1)] .= x^54;

julia&gt; A[diagind(A, 6)] .= x^54;

julia&gt; A[diagind(A, -2)] .= GA(1);

julia&gt; A[diagind(A, 5)] .= GA(1);

julia&gt; B = reshape([1 + x + x^6], (1, 1));

julia&gt; c1 = LPCode(A, B);

julia&gt; code_n(c1), code_k(c1)
(882, 24)</code></pre><p>A [[175, 19, d ≤ 10]] code from Eq. (18) in Appendix A of (<a href="../references/#raveendran2022finite">Raveendran <em>et al.</em>, 2022</a>), following the 4th constructor.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke; using QuantumClifford.ECC;

julia&gt; base_matrix = [0 0 0 0; 0 1 2 5; 0 6 3 1]; l = 7;

julia&gt; c2 = LPCode(base_matrix, l .- base_matrix&#39;, l);

julia&gt; code_n(c2), code_k(c2)
(175, 19)</code></pre><p><strong>Code subfamilies and convenience constructors for them</strong></p><ul><li>When the base matrices of the <code>LPCode</code> are 1×1, the code is called a two-block group-algebra code <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>.</li><li>When the base matrices of the <code>LPCode</code> are 1×1 and their elements are sums of cyclic permutations, the code is called a generalized bicycle code <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>.</li><li>When the two matrices are adjoint to each other, the code is called a bicycle code <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>.</li></ul><p><strong>The representation function</strong></p><p>We use the default representation function <code>Hecke.representation_matrix</code> to convert a <code>GF(2)</code>-group algebra element to a binary matrix. The default representation, provided by <code>Hecke</code>, is the permutation representation.</p><p>We also accept a custom representation function as detailed in <a href="#QuantumCliffordHeckeExt.LiftedCode"><code>LiftedCode</code></a>.</p><p>See also: <a href="#QuantumCliffordHeckeExt.LiftedCode"><code>LiftedCode</code></a>, <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.haah_cubic_codes"><code>haah_cubic_codes</code></a>.</p><ul><li><p><code>A::Union{LinearAlgebra.Adjoint{&lt;:Hecke.GroupAlgebraElem, &lt;:Matrix{&lt;:Hecke.GroupAlgebraElem}}, Matrix{&lt;:Hecke.GroupAlgebraElem}}</code>: the first base matrix of the code, whose elements are in a group algebra.</p></li><li><p><code>B::Union{LinearAlgebra.Adjoint{&lt;:Hecke.GroupAlgebraElem, &lt;:Matrix{&lt;:Hecke.GroupAlgebraElem}}, Matrix{&lt;:Hecke.GroupAlgebraElem}}</code>: the second base matrix of the code, whose elements are in the same group algebra as <code>A</code>.</p></li><li><p><code>GA::Hecke.GroupAlgebra</code>: the group algebra for which elements in <code>A</code> and <code>B</code> are from.</p></li><li><p><code>repr::Function</code>: a function that converts a group algebra element to a binary matrix; default to be the permutation representation for GF(2)-algebra.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/ext/QuantumCliffordHeckeExt/lifted_product.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordHeckeExt.LiftedCode" href="#QuantumCliffordHeckeExt.LiftedCode"><code>QuantumCliffordHeckeExt.LiftedCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LiftedCode &lt;: QuantumClifford.ECC.ClassicalCode</code></pre><p>Classical codes lifted over a group algebra, used for lifted product code construction ((<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>), (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>))</p><p>The parity-check matrix is constructed by applying <code>repr</code> to each element of <code>A</code>, which is mathematically a linear map from a group algebra element to a binary matrix. The size of the parity check matrix will enlarged with each element of <code>A</code> being inflated into a matrix. The procedure is called a lift (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>).</p><p><strong>Constructors</strong></p><p>A lifted code can be constructed via the following approaches:</p><ol><li><p>A matrix of group algebra elements.</p></li><li><p>A matrix of group elements, where a group element will be considered as a group algebra element by assigning a unit coefficient.</p></li><li><p>A matrix of integers, where each integer represent the shift of a cyclic permutation. The order of the cyclic permutation should be specified.</p></li></ol><p>The default <code>GA</code> is the group algebra of <code>A[1, 1]</code>, the default representation <code>repr</code> is the permutation representation.</p><p><strong>The representation function <code>repr</code></strong></p><p>We use the default representation function <code>Hecke.representation_matrix</code> to convert a <code>GF(2)</code>-group algebra element to a binary matrix. The default representation, provided by <code>Hecke</code>, is the permutation representation.</p><p>We also accept a custom representation function (the <code>repr</code> field of the constructor). Whatever the representation, the matrix elements need to be convertible to Integers (e.g. permit <code>lift(ZZ, ...)</code>). Such a customization would be useful to reduce the number of bits required by the code construction.</p><p>For example, if we use a D4 group for lifting, our default representation will be <code>8×8</code> permutation matrices, where 8 is the group&#39;s order. However, we can find a <code>4×4</code> matrix representation for the group, e.g. by using the typical <a href="https://en.wikipedia.org/wiki/Dihedral_group"><code>2×2</code> representation</a> and converting it into binary representation by replacing &quot;1&quot; with the Pauli I, and &quot;-1&quot; with the Pauli X matrix.</p><p>See also: <a href="#QuantumCliffordHeckeExt.LPCode"><code>LPCode</code></a>.</p><ul><li><p><code>A::Union{LinearAlgebra.Adjoint{&lt;:Hecke.GroupAlgebraElem, &lt;:Matrix{&lt;:Hecke.GroupAlgebraElem}}, Matrix{&lt;:Hecke.GroupAlgebraElem}}</code>: the base matrix of the code, whose elements are in a group algebra.</p></li><li><p><code>GA::Hecke.GroupAlgebra</code>: the group algebra for which elements in <code>A</code> are from.</p></li><li><p><code>repr::Function</code>: a function that converts a group algebra element to a binary matrix; default to be the permutation representation for GF(2)-algebra.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/ext/QuantumCliffordHeckeExt/lifted.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordHeckeExt.LiftedCode-Tuple{Matrix{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, &lt;:Hecke.GroupAlgebra}}}" href="#QuantumCliffordHeckeExt.LiftedCode-Tuple{Matrix{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, &lt;:Hecke.GroupAlgebra}}}"><code>QuantumCliffordHeckeExt.LiftedCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>LiftedCode</code> constructor using the default <code>GF(2)</code> representation (coefficients converted to a permutation matrix by <code>representation_matrix</code> provided by Hecke).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/ext/QuantumCliffordHeckeExt/lifted.jl#L58-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.bicycle_codes-Tuple{Array{Int64}, Int64}" href="#QuantumClifford.ECC.bicycle_codes-Tuple{Array{Int64}, Int64}"><code>QuantumClifford.ECC.bicycle_codes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Bicycle codes are a special case of generalized bicycle codes, where <code>a</code> and <code>b</code> are conjugate to each other. The order of the cyclic group is <code>l</code>, and the shifts <code>a_shifts</code> and <code>b_shifts</code> are reverse to each other.</p><p>See also: <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.haah_cubic_codes"><code>haah_cubic_codes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/ext/QuantumCliffordHeckeExt/lifted_product.jl#L313-L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.check_repr_commutation_relation-Tuple{Hecke.GroupAlgebra}" href="#QuantumClifford.ECC.check_repr_commutation_relation-Tuple{Hecke.GroupAlgebra}"><code>QuantumClifford.ECC.check_repr_commutation_relation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Checks the commutation relation between the left and right representation matrices for two randomly-sampled elements <code>a</code> and <code>b</code> in the group algebra <code>ℱ[G]</code> with a general group <code>G</code>. It verifies the commutation relation that states, <code>L(a)·R(b) = R(b)·L(a)</code>. This property shows that matrices from the left and right representation sets commute with each other, which is an important property related to the CSS orthogonality condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/ext/QuantumCliffordHeckeExt/util.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.generalized_bicycle_codes-Tuple{Array{Int64}, Array{Int64}, Int64}" href="#QuantumClifford.ECC.generalized_bicycle_codes-Tuple{Array{Int64}, Array{Int64}, Int64}"><code>QuantumClifford.ECC.generalized_bicycle_codes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Generalized bicycle codes, which are a special case of <em>abelian</em> 2GBA codes (and therefore of lifted product codes). Here the group is chosen as the cyclic group of order <code>l</code>, and the base matrices <code>a</code> and <code>b</code> are the sum of the group algebra elements corresponding to the shifts <code>a_shifts</code> and <code>b_shifts</code>.</p><p>See also: <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>.</p><p>A [[254, 28, 14 ≤ d ≤ 20]] code from (A1) in Appendix B of (<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke; using QuantumClifford.ECC

julia&gt; c = generalized_bicycle_codes([0, 15, 20, 28, 66], [0, 58, 59, 100, 121], 127);

julia&gt; code_n(c), code_k(c)
(254, 28)</code></pre><p>An [[70, 8, 10]] <em>abelian</em> 2BGA code from Table 1 of (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>), with cyclic group of order <code>l = 35</code>, illustrates that <em>abelian</em> 2BGA codes can be viewed as GB codes.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke; using QuantumClifford.ECC

julia&gt; l = 35;

julia&gt; c1 = generalized_bicycle_codes([0, 15, 16, 18], [0, 1, 24, 27], l);

julia&gt; code_n(c1), code_k(c1)
(70, 8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/ext/QuantumCliffordHeckeExt/lifted_product.jl#L274-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.haah_cubic_codes-Tuple{Array{Int64}, Array{Int64}, Int64}" href="#QuantumClifford.ECC.haah_cubic_codes-Tuple{Array{Int64}, Array{Int64}, Int64}"><code>QuantumClifford.ECC.haah_cubic_codes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Haah’s cubic codes (<a href="../references/#haah2011local">Haah, 2011</a>) can be viewed as generalized bicycle (GB) codes with the group <code>G = Cₗ × Cₗ × Cₗ</code>, where <code>l</code> denotes the lattice size. In particular, a GB code with the group <code>G = ℤ₃ˣ³</code> corresponds to a cubic code.</p><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/haah_cubic">entry for this family</a>.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke; using QuantumClifford.ECC;

julia&gt; c = haah_cubic_codes([0, 15, 20, 28, 66], [0, 58, 59, 100, 121], 6);

julia&gt; code_n(c), code_k(c)
(432, 8)</code></pre><p>See also: <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/ext/QuantumCliffordHeckeExt/lifted_product.jl#L326-L343">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.two_block_group_algebra_codes-Tuple{Hecke.GroupAlgebraElem, Hecke.GroupAlgebraElem}" href="#QuantumClifford.ECC.two_block_group_algebra_codes-Tuple{Hecke.GroupAlgebraElem, Hecke.GroupAlgebraElem}"><code>QuantumClifford.ECC.two_block_group_algebra_codes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Two-block group algebra (2BGA) codes, which are a special case of lifted product codes from two group algebra elements <code>a</code> and <code>b</code>, used as <code>1x1</code> base matrices.</p><p><strong>Examples of 2BGA code subfamilies</strong></p><p><strong><code>C₄ x C₂</code></strong></p><p>Here is an example of a [[56, 28, 2]] 2BGA code from Table 2 of (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>) with direct product of <code>C₄ x C₂</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; using QuantumClifford.ECC;

julia&gt; GA = group_algebra(GF(2), abelian_group([14,2]));

julia&gt; x, s = gens(GA);

julia&gt; A = 1 + x^7;

julia&gt; B = 1 + x^7 + s + x^8 + s*x^7 + x;

julia&gt; c = two_block_group_algebra_codes(A,B);

julia&gt; code_n(c), code_k(c)
(56, 28)</code></pre><p><strong>Bivariate Bicycle codes</strong></p><p>Bivariate Bicycle codes are a class of Abelian 2BGA codes formed by the direct product of two cyclic groups <code>ℤₗ × ℤₘ</code>. The parameters <code>l</code> and <code>m</code> represent the orders of the first and second cyclic groups, respectively.</p><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/qcga">entry for this family</a>.</p><p>A [[756, 16, ≤ 34]] code from Table 3 of (<a href="../references/#bravyi2024high">Bravyi <em>et al.</em>, 2024</a>):</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; using QuantumClifford.ECC;

julia&gt; l=21; m=18;

julia&gt; GA = group_algebra(GF(2), abelian_group([l, m]));

julia&gt; x, y = gens(GA);

julia&gt; A = x^3 + y^10 + y^17;

julia&gt; B = y^5 + x^3  + x^19;

julia&gt; c = two_block_group_algebra_codes(A,B);

julia&gt; code_n(c), code_k(c)
(756, 16)</code></pre><p><strong>Multivariate Bicycle code</strong></p><p>The group algebra of the qubit multivariate bicycle (MB) code with r variables is <code>𝔽₂[𝐺ᵣ]</code>, where <code>𝐺ᵣ = ℤ/l₁ × ℤ/l₂ × ... × ℤ/lᵣ</code>.</p><p>A [[48, 4, 6]] Weight-6 TB-QLDPC code from Appendix A Table 2 of (<a href="../references/#voss2024multivariatebicyclecodes">Voss <em>et al.</em>, 2024</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; using QuantumClifford.ECC;

julia&gt; l=4; m=6;

julia&gt; GA = group_algebra(GF(2), abelian_group([l, m]));

julia&gt; x, y = gens(GA);

julia&gt; z = x*y;

julia&gt; A = x^3 + y^5;

julia&gt; B = x + z^5 + y^5 + y^2;

julia&gt; c = two_block_group_algebra_codes(A, B);

julia&gt; code_n(c), code_k(c)
(48, 4)</code></pre><p><strong>Coprime Bivariate Bicycle code</strong></p><p>The coprime bivariate bicycle (BB) codes are defined by two polynomials <code>𝑎(𝑥,𝑦)</code> and <code>𝑏(𝑥,𝑦)</code>, where <code>𝑙</code> and <code>𝑚</code> are coprime, and can be expressed as univariate polynomials <code>𝑎(𝜋)</code> and <code>𝑏(𝜋)</code>, with generator <code>𝜋 = 𝑥𝑦</code>. They can be viewed as a special case of Lifted Product construction based on abelian group <code>ℤₗ x ℤₘ</code> where <code>ℤⱼ</code> cyclic group of order <code>j</code>.</p><p>[[108, 12, 6]] coprime-bivariate bicycle (BB) code from Table 2 of (<a href="../references/#wang2024coprime">Wang and Mueller, 2024</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; using QuantumClifford.ECC;

julia&gt; l=2; m=27;

julia&gt; GA = group_algebra(GF(2), abelian_group([l*m]));

julia&gt; 𝜋 = gens(GA)[1];

julia&gt; A = 𝜋^2 + 𝜋^5  + 𝜋^44;

julia&gt; B = 𝜋^8 + 𝜋^14 + 𝜋^47;

julia&gt; c = two_block_group_algebra_codes(A, B);

julia&gt; code_n(c), code_k(c)
(108, 12)</code></pre><p>See also: <a href="#QuantumCliffordHeckeExt.LPCode"><code>LPCode</code></a>, <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.haah_cubic_codes"><code>haah_cubic_codes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/ext/QuantumCliffordHeckeExt/lifted_product.jl#L155-L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordHeckeExt.group_algebra_conj-Union{Tuple{Hecke.GroupAlgebraElem{T}}, Tuple{T}} where T" href="#QuantumCliffordHeckeExt.group_algebra_conj-Union{Tuple{Hecke.GroupAlgebraElem{T}}, Tuple{T}} where T"><code>QuantumCliffordHeckeExt.group_algebra_conj</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Compute the conjugate of a group algebra element. The conjugate is defined by inversing elements in the associated group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/75e5fe9553044949e00c63f45a7a441ac57261a6/ext/QuantumCliffordHeckeExt/types.jl#L13-L16">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ECC_evaluating/">« Evaluating codes and decoders</a><a class="docs-footer-nextpage" href="../allops/">All Gates »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Wednesday 30 April 2025 01:16">Wednesday 30 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

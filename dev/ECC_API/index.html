<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · QuantumClifford.jl</title><meta name="title" content="API · QuantumClifford.jl"/><meta property="og:title" content="API · QuantumClifford.jl"/><meta property="twitter:title" content="API · QuantumClifford.jl"/><meta name="description" content="Documentation for QuantumClifford.jl."/><meta property="og:description" content="Documentation for QuantumClifford.jl."/><meta property="twitter:description" content="Documentation for QuantumClifford.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumClifford.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">QuantumClifford.jl</a></li><li><span class="tocitem">Stabilizer Tableau Algebra</span><ul><li><a class="tocitem" href="../stab-algebra-manual/">Manual</a></li><li><a class="tocitem" href="../canonicalization/">Canonicalization</a></li><li><a class="tocitem" href="../mixed/">Mixed States</a></li><li><a class="tocitem" href="../graphs/">Graph States</a></li><li><a class="tocitem" href="../datastructures/">Datastructure Choice</a></li><li><a class="tocitem" href="../commonstates/">Useful States</a></li></ul></li><li><span class="tocitem">Circuit Simulation</span><ul><li><a class="tocitem" href="../noisycircuits/">Simulation of Noisy Circuits</a></li><li><a class="tocitem" href="../noisycircuits_mc/">Monte Carlo</a></li><li><a class="tocitem" href="../noisycircuits_perturb/">Perturbative Expansions</a></li><li><a class="tocitem" href="../ecc_example_sim/">ECC example</a></li><li><a class="tocitem" href="../noisycircuits_ops/">Circuit Operations</a></li><li><a class="tocitem" href="../noisycircuits_API/">API</a></li></ul></li><li><span class="tocitem">ECC compendium</span><ul><li><a class="tocitem" href="../ECC_evaluating/">Evaluating codes and decoders</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#The-base-library-QECCore.jl"><span>The base library <code>QECCore.jl</code></span></a></li><li><a class="tocitem" href="#Implemented-in-an-extension-requiring-Hecke.jl"><span>Implemented in an extension requiring <code>Hecke.jl</code></span></a></li><li><a class="tocitem" href="#Implemented-in-an-extension-requiring-Oscar.jl"><span>Implemented in an extension requiring <code>Oscar.jl</code></span></a></li><li><a class="tocitem" href="#Implemented-in-an-extension-requiring-JuMP.jl"><span>Implemented in an extension requiring <code>JuMP.jl</code></span></a></li></ul></li></ul></li><li><a class="tocitem" href="../allops/">All Gates</a></li><li><a class="tocitem" href="../plotting/">Visualizations</a></li><li><a class="tocitem" href="../API/">API</a></li><li><a class="tocitem" href="../tutandpub/">Tutorials and Publications</a></li><li><a class="tocitem" href="../references/">Suggested Readings &amp; References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ECC compendium</a></li><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumSavory/QuantumClifford.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/master/docs/src/ECC_API.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Full-ECC-API-(autogenerated)"><a class="docs-heading-anchor" href="#Full-ECC-API-(autogenerated)">Full ECC API (autogenerated)</a><a id="Full-ECC-API-(autogenerated)-1"></a><a class="docs-heading-anchor-permalink" href="#Full-ECC-API-(autogenerated)" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.CircuitCode" href="#QuantumClifford.ECC.CircuitCode"><code>QuantumClifford.ECC.CircuitCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>CircuitCode</code> is defined by a given encoding circuit <code>circ</code>.</p><ul><li><code>n</code>: qubit number</li><li><code>circ</code>: the encoding circuit</li><li><code>encode_qubits</code>: the qubits to be encoded</li></ul><p>See also: <a href="#QuantumClifford.ECC.random_all_to_all_circuit_code"><code>random_all_to_all_circuit_code</code></a>, <a href="#QuantumClifford.ECC.random_brickwork_circuit_code"><code>random_brickwork_circuit_code</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/random_circuit.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.CommutationCheckECCSetup" href="#QuantumClifford.ECC.CommutationCheckECCSetup"><code>QuantumClifford.ECC.CommutationCheckECCSetup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Configuration for ECC evaluator that does not simulate any ECC circuits, rather it simply checks the commutation of the parity check and the Pauli error.</p><p>This is much faster than any other simulation method, but it is incapable of noisy-circuit simulations and thus useless for fault-tolerance studies.</p><p>See also: <a href="#QuantumClifford.ECC.NaiveSyndromeECCSetup"><code>NaiveSyndromeECCSetup</code></a>, <a href="#QuantumClifford.ECC.ShorSyndromeECCSetup"><code>ShorSyndromeECCSetup</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/decoder_pipeline.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.Concat" href="#QuantumClifford.ECC.Concat"><code>QuantumClifford.ECC.Concat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Concat(c₁, c₂)</code> is a code concatenation of two quantum codes (<a href="../references/#knill1996concatenated">Knill and Laflamme, 1996</a>).</p><p>The inner code c₁ and the outer code c₂. The construction is the following: replace each qubit in code c₂ with logical qubits encoded by code c₁. The resulting code will have <code>n = n₁ × n₂</code> qubits and <code>k = k₁ × k₂</code> logical qubits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/concat.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.DecoderCorrectionGate" href="#QuantumClifford.ECC.DecoderCorrectionGate"><code>QuantumClifford.ECC.DecoderCorrectionGate</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Applies a Pauli correction on the <code>data_qubits</code> determined by the <code>decoder</code> using the corresponding <code>syndrome_bits</code> from the classical register.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/decoder_correction_gate.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.DistanceMIPAlgorithm" href="#QuantumClifford.ECC.DistanceMIPAlgorithm"><code>QuantumClifford.ECC.DistanceMIPAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DistanceMIPAlgorithm &lt;: AbstractDistanceAlg</code></pre><p>A Mixed Integer Programming (MIP) method for computing the code distance of CSS stabilizer codes by finding the minimum-weight non-trivial logical <a href="../API/#QuantumClifford.PauliOperator"><code>PauliOperator</code></a> (either <code>X</code>-type or <code>Z</code>-type). Used with <a href="#QECCore.distance"><code>distance</code></a> to select MIP as the method of finding the distance of a code.</p><div class="admonition is-info" id="Note-c7dd4d4a058d44a4"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c7dd4d4a058d44a4" title="Permalink"></a></header><div class="admonition-body"><ul><li>Requires a <code>JuMP</code>-compatible MIP solver (e.g., <code>HiGHS</code>, <code>SCIP</code>).</li><li>For some stabilizer CSS codes, the <code>X</code>-distance and <code>Z</code>-distance are equal.</li></ul></div></div><ul><li><p><code>logical_qubit</code>: index of the logical qubit to compute code distance for (nothing means compute for all logical qubits)</p></li><li><p><code>logical_operator_type</code>: type of logical operator to consider (:X or :Z, defaults to :minXZ).</p></li><li><p><code>solver</code>: <code>JuMP</code>-compatible MIP solver (e.g., <code>HiGHS</code>, <code>SCIP</code>)</p></li><li><p><code>opt_summary</code>: when <code>true</code> (default=<code>false</code>), prints the MIP solver&#39;s solution summary</p></li><li><p><code>time_limit</code>: time limit (in seconds) for the MIP solver&#39;s execution (default=60.0)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/ECC.jl#L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.NaiveSyndromeECCSetup" href="#QuantumClifford.ECC.NaiveSyndromeECCSetup"><code>QuantumClifford.ECC.NaiveSyndromeECCSetup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Configuration for ECC evaluator that runs the simplest syndrome measurement circuit.</p><p>The circuit is being simulated (as opposed to doing only a quick commutation check). This circuit would give poor performance if there is non-zero gate noise.</p><p>See also: <a href="#QuantumClifford.ECC.CommutationCheckECCSetup"><code>CommutationCheckECCSetup</code></a>, <a href="#QuantumClifford.ECC.ShorSyndromeECCSetup"><code>ShorSyndromeECCSetup</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/decoder_pipeline.jl#L46-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.ShorSyndromeECCSetup" href="#QuantumClifford.ECC.ShorSyndromeECCSetup"><code>QuantumClifford.ECC.ShorSyndromeECCSetup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Configuration for ECC evaluators that simulate the Shor-style syndrome measurement (without a flag qubit).</p><p>The simulated circuit includes:</p><ul><li>perfect noiseless encoding (encoding and its fault tolerance are not being studied here)</li><li>one round of &quot;memory noise&quot; after the encoding but before the syndrome measurement</li><li>perfect preparation of entangled ancillary qubits</li><li>noisy Shor-style syndrome measurement (only two-qubit gate noise)</li><li>noiseless &quot;logical state measurement&quot; (providing the comparison data when evaluating the decoder)</li></ul><p>See also: <a href="#QuantumClifford.ECC.CommutationCheckECCSetup"><code>CommutationCheckECCSetup</code></a>, <a href="#QuantumClifford.ECC.NaiveSyndromeECCSetup"><code>NaiveSyndromeECCSetup</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/decoder_pipeline.jl#L62-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.TableDecoder" href="#QuantumClifford.ECC.TableDecoder"><code>QuantumClifford.ECC.TableDecoder</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A simple look-up table decoder for error correcting codes.</p><p>The lookup table contains only weight=1 errors, thus it is small, but at best it provides only for distance=3 decoding.</p><p>The size of the lookup table would grow exponentially quickly for higher distances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/decoder_pipeline.jl#L210-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.code_k-Tuple{Stabilizer}" href="#QECCore.code_k-Tuple{Stabilizer}"><code>QECCore.code_k</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The number of logical qubits in a code.</p><p>Note that when redundant rows exist in the parity check matrix, the number of logical qubits <code>code_k(c)</code> will be greater than <code>code_n(c) - code_s(c)</code>, where the difference equals the redundancy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/ECC.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.parity_matrix_x-Tuple{AbstractECC}" href="#QECCore.parity_matrix_x-Tuple{AbstractECC}"><code>QECCore.parity_matrix_x</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parity check boolean matrix of a code (only the X entries in the tableau, i.e. the checks for Z errors).</p><p>Only CSS codes have this method.</p><p>See also: <a href="#QuantumClifford.ECC.parity_checks"><code>parity_checks</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/ECC.jl#L56-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.parity_matrix_z-Tuple{AbstractECC}" href="#QECCore.parity_matrix_z-Tuple{AbstractECC}"><code>QECCore.parity_matrix_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parity check boolean matrix of a code (only the Z entries in the tableau, i.e. the checks for X errors).</p><p>Only CSS codes have this method.</p><p>See also: <a href="#QuantumClifford.ECC.parity_checks"><code>parity_checks</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/ECC.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.BeliefPropDecoder-Tuple" href="#QuantumClifford.ECC.BeliefPropDecoder-Tuple"><code>QuantumClifford.ECC.BeliefPropDecoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A simple Belief Propagation decoder built around tools from <code>LDPCDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/decoder_pipeline.jl#L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.BitFlipDecoder-Tuple" href="#QuantumClifford.ECC.BitFlipDecoder-Tuple"><code>QuantumClifford.ECC.BitFlipDecoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>An Iterative Bitflip decoder built around tools from <code>LDPCDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/decoder_pipeline.jl#L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.BivariateBicycleCode-Tuple" href="#QuantumClifford.ECC.BivariateBicycleCode-Tuple"><code>QuantumClifford.ECC.BivariateBicycleCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Bivariate Bicycle codes ((<a href="../references/#jacob2025singleshotdecodingfaulttolerantgates">Jacob <em>et al.</em>, 2025</a>)) Implemented as a package extension with <code>Oscar</code>. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/qeccs_using_oscar.jl#L78-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.DDimensionalSurfaceCode-Tuple" href="#QuantumClifford.ECC.DDimensionalSurfaceCode-Tuple"><code>QuantumClifford.ECC.DDimensionalSurfaceCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>D-Dimensional Surface codes ((<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>), (<a href="../references/#Zeng_2019">Zeng and Pryadko, 2019</a>))</p><p>Implemented as a package extension with <code>Oscar</code>. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/qeccs_using_oscar.jl#L13-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.DDimensionalToricCode-Tuple" href="#QuantumClifford.ECC.DDimensionalToricCode-Tuple"><code>QuantumClifford.ECC.DDimensionalToricCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>D-Dimensional Toric codes ((<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>), (<a href="../references/#Zeng_2019">Zeng and Pryadko, 2019</a>))</p><p>Implemented as a package extension with <code>Oscar</code>. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/qeccs_using_oscar.jl#L24-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.DoubleHomologicalProductCode-Tuple" href="#QuantumClifford.ECC.DoubleHomologicalProductCode-Tuple"><code>QuantumClifford.ECC.DoubleHomologicalProductCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Double Homological Product codes ((<a href="../references/#Campbell_2019">Campbell, 2019</a>)).</p><p>Implemented as a package extension with <code>Oscar</code>. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/qeccs_using_oscar.jl#L46-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.ExtendedGeneralizedBicycleCode-Tuple" href="#QuantumClifford.ECC.ExtendedGeneralizedBicycleCode-Tuple"><code>QuantumClifford.ECC.ExtendedGeneralizedBicycleCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Extended Generalized Bicycle codes ((<a href="../references/#koukoulekidis2024smallquantumcodesalgebraic">Koukoulekidis <em>et al.</em>, 2024</a>))</p><p>Implemented as a package extension with Hecke. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/qeccs_using_hecke.jl#L58-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.GeneralizedBicycleCode-Tuple" href="#QuantumClifford.ECC.GeneralizedBicycleCode-Tuple"><code>QuantumClifford.ECC.GeneralizedBicycleCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Generalized Bicycle codes ((<a href="../references/#koukoulekidis2024smallquantumcodesalgebraic">Koukoulekidis <em>et al.</em>, 2024</a>))</p><p>Implemented as a package extension with Hecke. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/qeccs_using_hecke.jl#L47-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.GeneralizedHyperGraphProductCode-Tuple" href="#QuantumClifford.ECC.GeneralizedHyperGraphProductCode-Tuple"><code>QuantumClifford.ECC.GeneralizedHyperGraphProductCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Generalized Hypergraph Product codes (<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>) Implemented as a package extension with Hecke. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/qeccs_using_hecke.jl#L37-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.GeneralizedToricCode-Tuple" href="#QuantumClifford.ECC.GeneralizedToricCode-Tuple"><code>QuantumClifford.ECC.GeneralizedToricCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Generalized Toric codes ((<a href="../references/#liang2025generalizedtoriccodestwisted">Liang <em>et al.</em>, 2025</a>))</p><p>Implemented as a package extension with <code>Oscar</code>. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/qeccs_using_oscar.jl#L57-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.HomologicalProductCode-Tuple" href="#QuantumClifford.ECC.HomologicalProductCode-Tuple"><code>QuantumClifford.ECC.HomologicalProductCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Homological Product codes ((<a href="../references/#Quintavalle_2021">Quintavalle <em>et al.</em>, 2021</a>), (<a href="../references/#xu2024fastparallelizablelogicalcomputation">Xu <em>et al.</em>, 2024</a>)).</p><p>Implemented as a package extension with <code>Oscar</code>. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/qeccs_using_oscar.jl#L35-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.LPCode-Tuple" href="#QuantumClifford.ECC.LPCode-Tuple"><code>QuantumClifford.ECC.LPCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Lifted product codes ((<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>), (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>))</p><p>Implemented as a package extension with Hecke. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/qeccs_using_hecke.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.LaCross-Tuple" href="#QuantumClifford.ECC.LaCross-Tuple"><code>QuantumClifford.ECC.LaCross</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>La-cross codes ((<a href="../references/#pecorari2025high">Pecorari <em>et al.</em>, 2025</a>)) Implemented as a package extension with Hecke. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/qeccs_using_hecke.jl#L27-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.LiftedCode-Tuple" href="#QuantumClifford.ECC.LiftedCode-Tuple"><code>QuantumClifford.ECC.LiftedCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Classical codes lifted over a group algebra, used for lifted product code construction ((<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>), (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>))</p><p>Implemented as a package extension with Hecke. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/classical/lifted.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.PyBeliefPropDecoder-Tuple" href="#QuantumClifford.ECC.PyBeliefPropDecoder-Tuple"><code>QuantumClifford.ECC.PyBeliefPropDecoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A Belief Propagation decoder built around tools from the python package <code>ldpc</code> available from the julia package <code>PyQDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/decoder_pipeline.jl#L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.PyBeliefPropOSDecoder-Tuple" href="#QuantumClifford.ECC.PyBeliefPropOSDecoder-Tuple"><code>QuantumClifford.ECC.PyBeliefPropOSDecoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A Belief Propagation decoder with ordered statistics decoding, built around tools from the python package <code>ldpc</code> available from the julia package <code>PyQDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/decoder_pipeline.jl#L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.PyMatchingDecoder-Tuple" href="#QuantumClifford.ECC.PyMatchingDecoder-Tuple"><code>QuantumClifford.ECC.PyMatchingDecoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A perfect matching decoder built around tools from the python package <code>pymatching</code> available from the julia package <code>PyQDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/decoder_pipeline.jl#L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.TrivariateTricycleCode-Tuple" href="#QuantumClifford.ECC.TrivariateTricycleCode-Tuple"><code>QuantumClifford.ECC.TrivariateTricycleCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Trivariate Tricycle codes ((<a href="../references/#jacob2025singleshotdecodingfaulttolerantgates">Jacob <em>et al.</em>, 2025</a>)) Implemented as a package extension with <code>Oscar</code>. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/qeccs_using_oscar.jl#L68-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.bicycle_codes" href="#QuantumClifford.ECC.bicycle_codes"><code>QuantumClifford.ECC.bicycle_codes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Hecke. Check the docs for the <a href="http://qc.quantumsavory.org/stable/ECC_API/#Implemented-in-an-extension-requiring-Hecke.jl">Hecke extension</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/qeccs_using_hecke.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.boundary_maps" href="#QuantumClifford.ECC.boundary_maps"><code>QuantumClifford.ECC.boundary_maps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with <code>Oscar</code>. Check the docs for the <a href="http://qc.quantumsavory.org/stable/ECC_API/#Implemented-in-an-extension-requiring-Oscar.jl">Oscar extension</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/qeccs_using_oscar.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, QuantumClifford.ECC.AbstractECCSetup, Int64}" href="#QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, QuantumClifford.ECC.AbstractECCSetup, Int64}"><code>QuantumClifford.ECC.evaluate_decoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Evaluate the performance of a given decoder (e.g. <a href="#QuantumClifford.ECC.TableDecoder"><code>TableDecoder</code></a>) and a given style of running an ECC code (e.g. <a href="#QuantumClifford.ECC.ShorSyndromeECCSetup"><code>ShorSyndromeECCSetup</code></a>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/decoder_pipeline.jl#L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, Vararg{Any, 5}}" href="#QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, Vararg{Any, 5}}"><code>QuantumClifford.ECC.evaluate_decoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Evaluate the performance of an error-correcting circuit.</p><p>This method requires you give the circuit that performs both syndrome measurements and (probably noiseless) logical state measurements. The faults matrix that translates an error vector into corresponding logical errors is necessary as well.</p><p>This is a relatively barebones method that assumes the user prepares necessary circuits, etc. It is a method that is used internally by more user-frienly methods providing automatic conversion of codes and noise models to the necessary noisy circuits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/decoder_pipeline.jl#L154-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.faults_matrix-Tuple{Stabilizer}" href="#QuantumClifford.ECC.faults_matrix-Tuple{Stabilizer}"><code>QuantumClifford.ECC.faults_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Error-to-logical-observable map (a.k.a. fault matrix) of a code.</p><p>For a code with n physical qubits and k logical qubits this function returns a 2k × 2n binary matrix O such that <code>O[i,j]</code> is true if the logical observable of index <code>i</code> is flipped by the single physical qubit error of index <code>j</code>. Indexing is such that:</p><ul><li><code>O[1:k,:]</code> is the error-to-logical-X-observable map (logical X observable, i.e. triggered by logical Z errors)</li><li><code>O[k+1:2k,:]</code> is the error-to-logical-Z-observable map</li><li><code>O[:,1:n]</code> is the X-physical-error-to-logical-observable map</li><li><code>O[n+1:2n,:]</code> is the Z-physical-error-to-logical-observable map</li></ul><p>E.g. for <code>k=1</code>, <code>n=10</code>, then if <code>O[2,5]</code> is true, then the logical Z observable is flipped by a X₅ error; and if <code>O[1,12]</code> is true, then the logical X observable is flipped by a Z₂ error.</p><p>Of note is that there is a lot of freedom in choosing the logical operations! A logical operator multiplied by a stabilizer operator is still a logical operator. Similarly there is a different fault matrix for each choice of logical operators. But once the logical operators are picked, the fault matrix is fixed.</p><p>Below we show an example that uses the Shor code. While it is not the smallest code, it is a convenient choice to showcase the importance of the fault matrix when dealing with degenerate codes where a correction operation and an error do not need to be the same.</p><p>First, consider a single-qubit error, potential correction operations, and their effect on the Shor code:</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford.ECC: faults_matrix, Shor9

julia&gt; state = MixedDestabilizer(Shor9())
𝒟ℯ𝓈𝓉𝒶𝒷━━━━━
+ Z________
+ ___Z_____
+ _X_______
+ __X______
+ ____X____
+ _____X___
+ ______X__
+ _______X_
𝒳ₗ━━━━━━━━━
+ ______XXX
𝒮𝓉𝒶𝒷━━━━━━━
+ XXX___XXX
+ ___XXXXXX
+ ZZ_______
+ Z_Z______
+ ___ZZ____
+ ___Z_Z___
+ ______Z_Z
+ _______ZZ
𝒵ₗ━━━━━━━━━
+ Z__Z____Z

julia&gt; err_Z₁ = single_z(9,1) # the error we will simulate
+ Z________

julia&gt; cor_Z₂ = single_z(9,2) # the correction operation we will perform
+ _Z_______

julia&gt; err_Z₁ * state # observe that one of the syndrome bits is now flipped
𝒟ℯ𝓈𝓉𝒶𝒷━━━━━
+ Z________
+ ___Z_____
+ _X_______
+ __X______
+ ____X____
+ _____X___
+ ______X__
+ _______X_
𝒳ₗ━━━━━━━━━
+ ______XXX
𝒮𝓉𝒶𝒷━━━━━━━
- XXX___XXX
+ ___XXXXXX
+ ZZ_______
+ Z_Z______
+ ___ZZ____
+ ___Z_Z___
+ ______Z_Z
+ _______ZZ
𝒵ₗ━━━━━━━━━
+ Z__Z____Z

julia&gt; cor_Z₂ * err_Z₁ * state # we are back to a good code state
𝒟ℯ𝓈𝓉𝒶𝒷━━━━━
+ Z________
+ ___Z_____
- _X_______
+ __X______
+ ____X____
+ _____X___
+ ______X__
+ _______X_
𝒳ₗ━━━━━━━━━
+ ______XXX
𝒮𝓉𝒶𝒷━━━━━━━
+ XXX___XXX
+ ___XXXXXX
+ ZZ_______
+ Z_Z______
+ ___ZZ____
+ ___Z_Z___
+ ______Z_Z
+ _______ZZ
𝒵ₗ━━━━━━━━━
+ Z__Z____Z

julia&gt; bad_Z₆Z₉ = single_z(9,6) * single_z(9,9) # a different &quot;correction&quot; operation
+ _____Z__Z

julia&gt; bad_Z₆Z₉ * err_Z₁ * state # the syndrome is trivial, but now we have a logical error
𝒟ℯ𝓈𝓉𝒶𝒷━━━━━
+ Z________
+ ___Z_____
+ _X_______
+ __X______
+ ____X____
- _____X___
+ ______X__
+ _______X_
𝒳ₗ━━━━━━━━━
- ______XXX
𝒮𝓉𝒶𝒷━━━━━━━
+ XXX___XXX
+ ___XXXXXX
+ ZZ_______
+ Z_Z______
+ ___ZZ____
+ ___Z_Z___
+ ______Z_Z
+ _______ZZ
𝒵ₗ━━━━━━━━━
+ Z__Z____Z</code></pre><p>The success of <code>cor_Z₂</code> and the failure of <code>bad_Z₆Z₉</code> can be immediately seen through the fault matrix, as the wrong &quot;correction&quot; does not result in the same logical flips ad the error:</p><pre><code class="language-julia-repl hljs">julia&gt; O = faults_matrix(Shor9())
2×18 BitMatrix:
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1
 1  0  0  1  0  0  0  0  1  0  0  0  0  0  0  0  0  0

julia&gt; O * stab_to_gf2(err_Z₁)
2-element Vector{Int64}:
 0
 0

julia&gt; O * stab_to_gf2(cor_Z₂)
2-element Vector{Int64}:
 0
 0

julia&gt; O * stab_to_gf2(bad_Z₆Z₉)
2-element Vector{Int64}:
 1
 0</code></pre><p>While its use in this situation is rather contrived, the fault matrix is incredibly useful when running large scale simulations in which we want a separate fast error sampling process, (e.g. with Pauli frames) and a syndrome decoding process, without coupling between them. We just gather all our syndrome measurement <strong>and logical observables</strong> from the Pauli frame simulations, and then use them with the fault matrix in the syndrome decoding simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/ECC.jl#L168-L336">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.generalized_bicycle_codes" href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>QuantumClifford.ECC.generalized_bicycle_codes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Hecke. Check the docs for the <a href="http://qc.quantumsavory.org/stable/ECC_API/#Implemented-in-an-extension-requiring-Hecke.jl">Hecke extension</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/qeccs_using_hecke.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.haah_cubic_codes" href="#QuantumClifford.ECC.haah_cubic_codes"><code>QuantumClifford.ECC.haah_cubic_codes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Hecke. Check the docs for the <a href="http://qc.quantumsavory.org/stable/ECC_API/#Implemented-in-an-extension-requiring-Hecke.jl">Hecke extension</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/qeccs_using_hecke.jl#L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.honeycomb_color_codes" href="#QuantumClifford.ECC.honeycomb_color_codes"><code>QuantumClifford.ECC.honeycomb_color_codes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Hecke.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/qeccs_using_hecke.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.iscss-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractECC" href="#QuantumClifford.ECC.iscss-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractECC"><code>QuantumClifford.ECC.iscss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Check if the code is CSS.</p><p>Return <code>nothing</code> if unknown from the type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/ECC.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.isdegenerate" href="#QuantumClifford.ECC.isdegenerate"><code>QuantumClifford.ECC.isdegenerate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Check if the code is degenerate with respect to a given set of error or with respect to all &quot;up to d physical-qubit&quot; errors (defaulting to d=1).</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford.ECC

julia&gt; isdegenerate(Shor9(), [single_z(9,1), single_z(9,2)])
true

julia&gt; isdegenerate(Shor9(), [single_z(9,1), single_x(9,1)])
false

julia&gt; isdegenerate(Steane7(), 1)
false

julia&gt; isdegenerate(Steane7(), 2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/ECC.jl#L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.naive_encoding_circuit-Tuple{Any}" href="#QuantumClifford.ECC.naive_encoding_circuit-Tuple{Any}"><code>QuantumClifford.ECC.naive_encoding_circuit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Encoding physical qubits into a larger logical code.</p><p>The initial physical qubits to be encoded have to be at indices <code>n-k+1:n</code>.</p><div class="admonition is-info" id="Encoding-circuits-are-not-fault-tolerant-b464ac5e2ecb3c3c"><header class="admonition-header">Encoding circuits are not fault-tolerant<a class="admonition-anchor" href="#Encoding-circuits-are-not-fault-tolerant-b464ac5e2ecb3c3c" title="Permalink"></a></header><div class="admonition-body"><p>Encoding circuits are not fault-tolerant, and thus should not be used in practice. Instead, you should measure the stabilizers of the code and the logical observables, thus projecting into the code space (which can be fault-tolerant).</p></div></div><p>The canonicalization operation performed on the code may permute the qubits (see <a href="../API/#QuantumClifford.canonicalize_gott!-Tuple{Stabilizer}"><code>canonicalize_gott!</code></a>). That permutation is corrected for with SWAP gates by default (controlled by the <code>undoperm</code> keyword argument).</p><p>Based on (<a href="../references/#cleve1997efficient">Cleve and Gottesman, 1997</a>) and (<a href="../references/#gottesman1997stabilizer">Gottesman, 1997</a>), however it seems the published algorithm has some errors. Consult the erratum, as well as the more recent (<a href="../references/#grassl2002algorithmic">Grassl, 2002</a>) and (<a href="../references/#grassl2011variations">Grassl, 2011</a>), and be aware that this implementation also uses H instead of Z gates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/circuits.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.naive_syndrome_circuit" href="#QuantumClifford.ECC.naive_syndrome_circuit"><code>QuantumClifford.ECC.naive_syndrome_circuit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Generate the non-fault-tolerant stabilizer measurement cicuit for a given code instance or parity check tableau.</p><p>Use the <code>ancillary_index</code> and <code>bit_index</code> arguments to offset where the corresponding part the circuit starts.</p><p>Returns the circuit, the number of ancillary qubits that were added, and a list of bit indices that will store the measurement results.</p><p>See also: <a href="#QuantumClifford.ECC.shor_syndrome_circuit"><code>shor_syndrome_circuit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/circuits.jl#L85-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.parity_checks" href="#QuantumClifford.ECC.parity_checks"><code>QuantumClifford.ECC.parity_checks</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parity check tableau of a code.</p><p>See also: <a href="#QECCore.parity_matrix_x"><code>parity_matrix_x</code></a> and <a href="#QECCore.parity_matrix_z"><code>parity_matrix_z</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/ECC.jl#L51-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.random_all_to_all_circuit_code" href="#QuantumClifford.ECC.random_all_to_all_circuit_code"><code>QuantumClifford.ECC.random_all_to_all_circuit_code</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Random all-to-all Clifford circuit code (<a href="../references/#brown2013short">Brown and Fawzi, Jul 2013</a>).</p><p>The code of <code>n</code> qubits is generated by an all-to-all random Clifford circuit of <code>ngates</code> gates that encodes a subset of qubits <code>encode_qubits</code> into logical qubits.</p><p>Because of the random picking, the size of <code>encode_qubits</code> is the only thing that matters for the code, referred to as <code>k</code>.</p><p>See also: <a href="../API/#QuantumClifford.random_all_to_all_clifford_circuit-Tuple{Random.AbstractRNG, Int64, Int64}"><code>random_all_to_all_clifford_circuit</code></a>, <a href="#QuantumClifford.ECC.CircuitCode"><code>CircuitCode</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/random_circuit.jl#L34-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.random_brickwork_circuit_code" href="#QuantumClifford.ECC.random_brickwork_circuit_code"><code>QuantumClifford.ECC.random_brickwork_circuit_code</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Random brickwork Clifford circuit code (<a href="../references/#brown2013short">Brown and Fawzi, Jul 2013</a>).</p><p>The code is generated by a brickwork random Clifford circuit of <code>nlayers</code> layers that encodes a subset of qubits <code>encode_qubits</code> into logical qubits.</p><p>See also: <a href="../API/#QuantumClifford.random_brickwork_clifford_circuit-Tuple{Random.AbstractRNG, NTuple{N, Int64} where N, Int64}"><code>random_brickwork_clifford_circuit</code></a>, <a href="#QuantumClifford.ECC.CircuitCode"><code>CircuitCode</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/random_circuit.jl#L62-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.shor_syndrome_circuit" href="#QuantumClifford.ECC.shor_syndrome_circuit"><code>QuantumClifford.ECC.shor_syndrome_circuit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Generate the Shor fault-tolerant stabilizer measurement cicuit for a given code instance or parity check tableau.</p><p>Use the <code>ancillary_index</code> and <code>bit_index</code> arguments to offset where the corresponding part the circuit starts. Ancillary qubits</p><p>Returns:</p><ul><li>The ancillary cat state preparation circuit.</li><li>The Shor syndrome measurement circuit.</li><li>The number of ancillary qubits that were added.</li><li>The list of bit indices that store the final measurement results.</li></ul><p>See also: <a href="#QuantumClifford.ECC.naive_syndrome_circuit"><code>naive_syndrome_circuit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/circuits.jl#L140-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.two_block_group_algebra_codes" href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>QuantumClifford.ECC.two_block_group_algebra_codes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Hecke. Check the docs for the <a href="http://qc.quantumsavory.org/stable/ECC_API/#Implemented-in-an-extension-requiring-Hecke.jl">Hecke extension</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/qeccs_using_hecke.jl#L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.twobga_from_direct_product" href="#QuantumClifford.ECC.twobga_from_direct_product"><code>QuantumClifford.ECC.twobga_from_direct_product</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Oscar. Check the docs for the <a href="http://qc.quantumsavory.org/stable/ECC_API/#Implemented-in-an-extension-requiring-Oscar.jl">Oscar extension</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/qeccs_using_oscar.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.twobga_from_fp_group" href="#QuantumClifford.ECC.twobga_from_fp_group"><code>QuantumClifford.ECC.twobga_from_fp_group</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Oscar. Check the docs for the <a href="http://qc.quantumsavory.org/stable/ECC_API/#Implemented-in-an-extension-requiring-Oscar.jl">Oscar extension</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/src/ecc/codes/qeccs_using_oscar.jl#L4">source</a></section></article><h2 id="The-base-library-QECCore.jl"><a class="docs-heading-anchor" href="#The-base-library-QECCore.jl">The base library <code>QECCore.jl</code></a><a id="The-base-library-QECCore.jl-1"></a><a class="docs-heading-anchor-permalink" href="#The-base-library-QECCore.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.AbstractCECC" href="#QECCore.AbstractCECC"><code>QECCore.AbstractCECC</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractCECC &lt;: AbstractECC</code></pre><p>Abstract type for classical error correction code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/interface.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.AbstractCSSCode" href="#QECCore.AbstractCSSCode"><code>QECCore.AbstractCSSCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractCSSCode &lt;: AbstractQECC</code></pre><p>Abstract type for Calderbank-Shor-Steane (CSS) code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/interface.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.AbstractDistanceAlg" href="#QECCore.AbstractDistanceAlg"><code>QECCore.AbstractDistanceAlg</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractDistanceAlg</code></pre><p>Abstract type representing algorithms for computing the minimum distance of quantum error correction codes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/interface.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.AbstractECC" href="#QECCore.AbstractECC"><code>QECCore.AbstractECC</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractECC</code></pre><p>Abstract type for error correction code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/interface.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.AbstractQECC" href="#QECCore.AbstractQECC"><code>QECCore.AbstractQECC</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractQECC &lt;: AbstractECC</code></pre><p>Abstract type for quantum error correction code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/interface.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.Bitflip3" href="#QECCore.Bitflip3"><code>QECCore.Bitflip3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Bitflip3 &lt;: AbstractQECC</code></pre><p><code>Bitflip3</code> is a three-qubit bit-flip code that corrects single-qubit bit-flip error and does not detect any phase-flip errors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/bitflipcode.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.CSS" href="#QECCore.CSS"><code>QECCore.CSS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct CSS &lt;: AbstractCSSCode</code></pre><p>An arbitrary CSS error correction code defined by its <code>X</code> and <code>Z</code> checks.</p><p><strong>Fields</strong></p><ul><li><p><code>Hx::Matrix{Bool}</code>: The parity check matrix of the <code>X</code> stabilizers.</p></li><li><p><code>Hz::Matrix{Bool}</code>: The parity check matrix of the <code>Z</code> stabilizers.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/css.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.Cleve8" href="#QECCore.Cleve8"><code>QECCore.Cleve8</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Cleve8 &lt;: AbstractQECC</code></pre><p>A pedagogical example of a quantum error correcting [8,3] code used in (<a href="../references/#cleve1997efficient">Cleve and Gottesman, 1997</a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/clevecode.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.CyclicQuantumTannerGraphProduct" href="#QECCore.CyclicQuantumTannerGraphProduct"><code>QECCore.CyclicQuantumTannerGraphProduct</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct CyclicQuantumTannerGraphProduct &lt;: AbstractCSSCode</code></pre><p>Constructs a <code>𝑄(𝐺₁ × 𝐺₂)</code> quantum Tanner graph product code using cyclic Tanner graphs of length <code>2m</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; m = 1;

julia&gt; c = parity_checks(CyclicQuantumTannerGraphProduct(m))
+ X_X_XX__
+ _X_XXX__
+ X_X___XX
+ _X_X__XX
+ ZZ__Z_Z_
+ ZZ___Z_Z
+ __ZZZ_Z_
+ __ZZ_Z_Z

julia&gt; code_n(c), code_k(c)
(8, 2)

julia&gt; m = 10;

julia&gt; c = parity_checks(CyclicQuantumTannerGraphProduct(m));

julia&gt; code_n(c), code_k(c)
(800, 2)</code></pre><p><strong>Fields</strong></p><ul><li><code>m::Int64</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/quantumtannergraphproduct.jl#L169-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.DelfosseReichardt" href="#QECCore.DelfosseReichardt"><code>QECCore.DelfosseReichardt</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DelfosseReichardt &lt;: AbstractCSSCode</code></pre><p>The Delfosse-Reichardt code is derived from the classical <em>self-orthogonal</em> Reed-Muller codes. For parameters <code>(r,m)</code> = <code>(1,3)</code> and <code>(2,4)</code>, (<a href="../references/#delfosse2020short">Delfosse and Reichardt, 2020</a>) constructs families of:</p><ul><li><code>[[8p, 6(p-1), 4]]</code> codes requiring <code>8</code> measurement rounds.</li><li><code>[[16p, 14p-8, 4]]</code> codes requiring <code>10</code> measurement rounds.</li></ul><p>Delfosse and Reichardt ((<a href="../references/#delfosse2020short">Delfosse and Reichardt, 2020</a>)) utilize the <code>[8, 4, 4]</code> Reed-Muller code to construct <code>[[8p, 6(p−1), 4]]</code> self-dual CSS quantum codes for <code>p ≥ 2</code>, and the <code>[16, 11, 4]</code> Reed-Muller code to construct <code>[[16p, 14p − 8, 4]]</code> self-dual CSS quantum codes for <code>p ≥ 1</code>.  The parameter <code>p</code> specifies the <strong>number of blocks</strong> in the code construction.</p><p>To generalize the code construction, we extended the approach by using self-orthogonal <code>Reed-Muller</code> codes as base matrices for the <code>Delfosse-Reichardt</code> code.</p><div class="admonition is-info" id="Note-8e6423e8e882e3b3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-8e6423e8e882e3b3" title="Permalink"></a></header><div class="admonition-body"><p>Single-shot distance-3 fault tolerance uses two Reed-Muller subfamilies: <em>repetition</em> codes and <em>extended Hamming</em> codes. Their structure may enable <code>distance &gt; 4</code> fault-tolerant sequences, raising a key <em>open problem</em> (<a href="../references/#delfosse2020short">Delfosse and Reichardt, 2020</a>): &quot;Find a minimum-length sequence of parity check measurements for distance-<code>7</code> fault-tolerant error correction with distance-<code>8</code> Reed-Muller codes.&quot;</p></div></div><p><strong>[[8p, 6(p−1), 4]] code family</strong></p><p>An <code>[[16, 6, 4]]</code> Delfosse-Reichardt code of from <code>[[8p, 6(p−1), 4]]</code> code family from (<a href="../references/#delfosse2020short">Delfosse and Reichardt, 2020</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford; using QuantumClifford.ECC; # hide

julia&gt; p = 2; r = 1; m = 3;

julia&gt; c = parity_checks(DelfosseReichardt(p, r, m))
+ XXXXXXXX________
+ ________XXXXXXXX
+ XXXX____XXXX____
+ XX__XX__XX__XX__
+ X_X_X_X_X_X_X_X_
+ ZZZZZZZZ________
+ ________ZZZZZZZZ
+ ZZZZ____ZZZZ____
+ ZZ__ZZ__ZZ__ZZ__
+ Z_Z_Z_Z_Z_Z_Z_Z_

julia&gt; code_n(c), code_k(c)
(16, 6)</code></pre><p><strong>[[16p, 14p − 8, 4]] code family</strong></p><p>An <code>[[32, 20, 4]]</code> Delfosse-Reichardt code of from <code>[[16p, 14p − 8, 4]]</code> code family.</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford; using QuantumClifford.ECC; # hide

julia&gt; p = 2; r = 2; m = 4;

julia&gt; c = parity_checks(DelfosseReichardt(p, r, m))
+ XXXXXXXXXXXXXXXX________________
+ ________________XXXXXXXXXXXXXXXX
+ XXXXXXXX________XXXXXXXX________
+ XXXX____XXXX____XXXX____XXXX____
+ XX__XX__XX__XX__XX__XX__XX__XX__
+ X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_
+ ZZZZZZZZZZZZZZZZ________________
+ ________________ZZZZZZZZZZZZZZZZ
+ ZZZZZZZZ________ZZZZZZZZ________
+ ZZZZ____ZZZZ____ZZZZ____ZZZZ____
+ ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__
+ Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_

julia&gt; code_n(c), code_k(c)
(32, 20)</code></pre><p><strong>Fields</strong></p><ul><li><p><code>p::Int64</code>: The number of blocks in the Delfosse-Reichardt CSS code.</p></li><li><p><code>r::Int64</code>: The order of the classical Reed-Muller code.</p></li><li><p><code>m::Int64</code>: The log-length of the classical Reed-Muller code.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/delfosse_reichardt_code.jl#L1-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.DelfosseReichardt823" href="#QECCore.DelfosseReichardt823"><code>QECCore.DelfosseReichardt823</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DelfosseReichardt823 &lt;: AbstractQECC</code></pre><p>The <code>[[8p, 4p − 2, 3]]</code> Delfosse-Reichardt Generalized <code>[[8,2,3]]</code> code is derived from the quantum <code>[[8,2,3]]</code> code. These codes were introduced by Delfosse and Reichardt in the paper <em>Short Shor-style syndrome sequences</em> (<a href="../references/#delfosse2020short">Delfosse and Reichardt, 2020</a>). The parameter <code>p</code> specifies the <strong>number of blocks</strong> in the code construction.</p><p>The <code>[[8, 2, 3]]</code> non-CSS code serves as the seed code for constructing Delfosse-Reichardt generalized <code>[[8p, 4p − 2, 3]]</code>codes.</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford; using QuantumClifford.ECC; # hide

julia&gt; p = 1;

julia&gt; c = parity_checks(DelfosseReichardt823(p))
+ ZZZZ____
+ XXXX____
+ ____ZZZZ
+ ____XXXX
+ _XYZ_XYZ
+ _ZXY_ZXY

julia&gt; code_n(c), code_k(c)
(8, 2)</code></pre><p>An <code>[[16, 6, 3]]</code> Delfosse-Reichardt Generalized <code>[[8,2,3]]</code> code from (<a href="../references/#delfosse2020short">Delfosse and Reichardt, 2020</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford; using QuantumClifford.ECC; # hide

julia&gt; p = 2;

julia&gt; c = parity_checks(DelfosseReichardt823(p))
+ ZZZZ____________
+ XXXX____________
+ ____ZZZZ________
+ ____XXXX________
+ ________ZZZZ____
+ ________XXXX____
+ ____________ZZZZ
+ ____________XXXX
+ _XYZ_XYZ_XYZ_XYZ
+ _ZXY_ZXY_ZXY_ZXY

julia&gt; code_n(c), code_k(c)
(16, 6)</code></pre><p><strong>Fields</strong></p><ul><li><code>p::Int64</code>: The number of blocks in the Delfosse-Reichardt generalized [[8, 2, 3]] code.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/delfosse_reichardt_823_code.jl#L1-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.DelfosseReichardtRepCode" href="#QECCore.DelfosseReichardtRepCode"><code>QECCore.DelfosseReichardtRepCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DelfosseReichardtRepCode &lt;: AbstractCSSCode</code></pre><p>The <code>[[4p, 2(p − 2), 4]]</code> Delfosse-Reichardt repetition code is derived from the classical <code>[4, 1, 4]</code> repetition code and is used to construct quantum stabilizer code.</p><p>The <code>[4, 1, 4]</code> repetition code is a classical error-correcting code where each bit is repeated four times to improve error detection and correction. It is defined by the following parity-check matrix:</p><p class="math-container">\[\begin{pmatrix}
1 &amp; 1 &amp; 1 &amp; 1 \\
0 &amp; 0 &amp; 1 &amp; 1 \\
0 &amp; 1 &amp; 0 &amp; 1
\end{pmatrix}\]</p><p>The <code>[[4p, 2(p − 2), 4]]</code> codes were introduced by Delfosse and Reichardt in the paper <em>Short Shor-style syndrome sequences</em> (<a href="../references/#delfosse2020short">Delfosse and Reichardt, 2020</a>). The parameter <code>p</code> specifies the <strong>number of blocks</strong> in the code construction. For the code to be valid, <code>p</code> must be a multiple of 2.</p><p>An <code>[[24, 8, 4]]</code> Delfosse-Reichardt repetition code from (<a href="../references/#delfosse2020short">Delfosse and Reichardt, 2020</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford; using QuantumClifford.ECC # hide

julia&gt; p = 6;

julia&gt; c = parity_checks(DelfosseReichardtRepCode(p))
+ XXXX____________________
+ ____XXXX________________
+ ________XXXX____________
+ ____________XXXX________
+ ________________XXXX____
+ ____________________XXXX
+ __XX__XX__XX__XX__XX__XX
+ _X_X_X_X_X_X_X_X_X_X_X_X
+ ZZZZ____________________
+ ____ZZZZ________________
+ ________ZZZZ____________
+ ____________ZZZZ________
+ ________________ZZZZ____
+ ____________________ZZZZ
+ __ZZ__ZZ__ZZ__ZZ__ZZ__ZZ
+ _Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z

julia&gt; code_n(c), code_k(c)
(24, 8)</code></pre><p><strong>Fields</strong></p><ul><li><code>p::Int64</code>: The number of blocks in the Delfosse-Reichardt Repetition code.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/delfosse_reichardt_repcode.jl#L1-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.GallagerLDPC" href="#QECCore.GallagerLDPC"><code>QECCore.GallagerLDPC</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GallagerLDPC &lt;: AbstractCECC</code></pre><p>Construct a regular LDPC code parity-check matrix <code>H</code> using Gallager&#39;s original construction method (<a href="../references/#gallager1962ldpc">Gallager, 1962</a>).</p><p><strong>Mathematical Formulation</strong></p><p>The parity-check matrix <code>H</code> is constructed as:</p><p class="math-container">\[\begin{aligned}
H = \begin{bmatrix} H_1 \\ H_2 \\ \vdots \\ H_{w_c} \end{bmatrix}
\end{aligned}\]</p><p>where each submatrix <span>$H_d$</span> is a <span>$μ × μw_r$</span> binary matrix with:</p><ul><li>Row weight <span>$w_r$</span> (number of 1s per row)</li><li>Column weight 1 (each column has exactly one 1)</li></ul><p>The first submatrix <span>$H_1$</span> has a specific structure where row <span>$i$</span> (<span>$1 ≤ i ≤ μ$</span>) contains  its <span>$w_r$</span> 1s in columns <span>$(i-1)w_r + 1$</span> to <span>$iw_r$</span>. Subsequent submatrices <span>$H_2,...,H_{w_c}$</span>  are <em>column permutations</em> of <span>$H_1$</span>.</p><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/gallager">entry for this family</a>.</p><p><strong>Example</strong></p><p>Here is an example of <code>(3,4)</code>-LDPC code</p><pre><code class="language-julia-repl hljs">julia&gt; using QECCore; using Nemo

julia&gt; μ = 3; wc = 3; wr = 4;

julia&gt; c = GallagerLDPC(μ, wc, wr);

julia&gt; H = parity_matrix(c)
9×12 SparseArrays.SparseMatrixCSC{Bool, Int64} with 36 stored entries:
 1  1  1  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅  ⋅  1  1  1  1  ⋅  ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  1  1  1
 1  ⋅  1  ⋅  ⋅  ⋅  1  ⋅  1  ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  1  ⋅  ⋅  1  1
 ⋅  1  ⋅  1  1  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅
 ⋅  1  1  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1
 ⋅  ⋅  ⋅  1  ⋅  1  1  1  ⋅  ⋅  ⋅  ⋅
 1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  1  1  ⋅

julia&gt; code_n(c), code_k(c)
(12, 5)

julia&gt; all(sum(Matrix(H), dims=1) .== 3)
true

julia&gt; all(sum(Matrix(H), dims=2) .== 4)
true</code></pre><p><strong>Fields</strong></p><ul><li><p><code>block_rows::Int64</code>: Number of block rows called &quot;submatrices&quot; in the Gallager&#39;s construction (<a href="../references/#gallager1962ldpc">Gallager, 1962</a>).</p></li><li><p><code>col_weight::Int64</code>: Column weight</p></li><li><p><code>row_weight::Int64</code>: Row weight which must be greater column weight.</p></li><li><p><code>seed::Int64</code>: Random seed for reproducible parity check matrix generation (<code>default=42</code>).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/classical/gallager.jl#L1-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.GeneralizedCirculantBivariateBicycle" href="#QECCore.GeneralizedCirculantBivariateBicycle"><code>QECCore.GeneralizedCirculantBivariateBicycle</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GeneralizedCirculantBivariateBicycle &lt;: AbstractCSSCode</code></pre><p>A generalization of the circulant bivariate bicycle code introduced in (<a href="../references/#bravyi2024high">Bravyi <em>et al.</em>, 2024</a>), extending the original three-term polynomial representation up to <code>ℓ</code> terms (for <code>x</code>-powers) and <code>m</code> terms (for <code>y</code>-powers).</p><p><strong>Bivariate Bicycle Codes</strong></p><p>Bivariate bicycle codes are a class of group algebra codes defined for the finite abelian group <span>$G = \mathbb{Z}/\ell\mathbb{Z} \times \mathbb{Z}/m\mathbb{Z}$</span>. The group algebra <span>$\mathbb{F}_2[G]$</span> admits an identification with the quotient ring <span>$R = \mathbb{F}_2[x,y]/(x^\ell - 1, y^m - 1)$</span>, where the standard basis consists of monomials <span>${x^iy^j}$</span> for <span>$0 \leq i &lt; \ell$</span> and <span>$0 \leq j &lt; m$</span> (<a href="../references/#eberhardt2024logical">Eberhardt and Steffan, 2024</a>). Within this framework, every pair of elements <span>$c,d \in R$</span> determines a BB code <span>$(C(c,d)$</span> through the group algebra construction. </p><p><strong>Circulant Matrix Representation</strong></p><p>BB codes admit a matrix representation via the <a href="https://en.wikipedia.org/wiki/Injective_function">injective</a> <a href="https://en.wikipedia.org/wiki/Ring_homomorphism">ring homomorphism</a> (<a href="../references/#eberhardt2024logical">Eberhardt and Steffan, 2024</a>):</p><p class="math-container">\[\begin{aligned}
\varphi: R = \mathbb{F}_2[x,y]/(x^\ell - 1, y^m - 1) \rightarrow \mathbb{F}_2^{\ell m \times \ell m}
\end{aligned}\]</p><p>where <span>$\varphi(x) = S_\ell \otimes I_m$</span> and <span>$\varphi(y) = I_\ell \otimes S_m$</span> provides matrix representations of the algebraic generators. Through this mapping, any code-defining polynomials <span>$c,d \in R$</span> correspond to parity-check matrices <span>$A = \varphi(c)$</span> and <span>$B = \varphi(d)$</span> composed of tensor products of circulant blocks.</p><p><strong>Three-term Polynomials</strong></p><p>The original construction in (<a href="../references/#bravyi2024high">Bravyi <em>et al.</em>, 2024</a>) constrained the polynomials to specific forms:  </p><p class="math-container">\[\begin{aligned}
a(x, y) = x^a + y^b + y^c, \quad b(x, y) = y^d + x^e + x^f
\end{aligned}\]</p><p>Thus, <span>$A$</span> and <span>$B$</span> can be expressed as <span>$A = A_1 + A_2 + A_3$</span> and <span>$B = B_1 + B_2 + B_3$</span>. Consequently, each stabilizer generator has weight at most 6 for any valid three-term polynomials (<a href="../references/#postema2025existencecharacterisationbivariatebicycle">Postema and Kokkelmans, 2025</a>).  </p><p><strong>Generalized Polynomials</strong></p><p>We extend the original three-term construction of (<a href="../references/#bravyi2024high">Bravyi <em>et al.</em>, 2024</a>) to arbitrary finite sums of commuting monomials in <span>$x$</span> and <span>$y$</span>:</p><p class="math-container">\[\begin{aligned}
A = \sum_{i \in I} x^{p_i} + \sum_{j \in J} y^{q_j}, \quad B = \sum_{k \in K} x^{r_k} + \sum_{l \in L} y^{s_l}
\end{aligned}\]</p><p>where index sets <span>$I, J, K, L$</span> are finite and non-empty, with powers bounded by:</p><p class="math-container">\[\begin{aligned}
0 \leq p_i, r_k \leq \ell-1, \quad 0 \leq q_j, s_l \leq m-1
\end{aligned}\]</p><p><strong>Commuting Shift Matrices</strong></p><p>The matrices <span>$x = S_\ell \otimes I_m$</span> and <span>$y = I_\ell \otimes S_m$</span> form a pair of commuting operators, where <span>$S_\ell$</span> and <span>$S_m$</span> are cyclic shift matrices of sizes <span>$\ell \times \ell$</span> and <span>$m \times m$</span> respectively, and <span>$I_\ell$</span>, <span>$I_m$</span> denote identity matrices of corresponding dimensions. Their commutativity <span>$xy = yx$</span> follows from the <em>mixed-product property</em> of Kronecker products (<a href="../references/#wang2024coprime">Wang and Mueller, 2024</a>):</p><p class="math-container">\[\begin{aligned}
(A \otimes B)(C \otimes D) = (AC) \otimes (BD)
\end{aligned}\]</p><p>which yields:</p><p class="math-container">\[\begin{aligned}
(S_\ell \otimes I_m)(I_\ell \otimes S_m) = (I_\ell \otimes S_m)(S_\ell \otimes I_m) = S_\ell \otimes S_m
\end{aligned}\]</p><p>The set of monomials <span>$\{x^i y^j \mid 0 \leq i &lt; \ell, 0 \leq j &lt; m}$</span> forms a basis for the matrix algebra generated by <span>$x$</span> and <span>$y$</span>, establishing a <a href="https://en.wikipedia.org/wiki/Bijection">bijection</a> between these monomials and the resulting <span>$(\ell m) \times (\ell m)$</span> matrices. This correspondence allows us to work equivalently with either the polynomial or matrix formulation (<a href="../references/#wang2024coprime">Wang and Mueller, 2024</a>).</p><p><strong>Parity Checks</strong></p><p>The commuting polynomial matrices <span>$A = a(x, y)$</span> and <span>$B = b(x, y)$</span> define the code’s parity checks:</p><p class="math-container">\[\begin{aligned}
H_x = [A \mid B], \quad H_z = [B^\top \mid A^\top]
\end{aligned}\]</p><p>The addition and multiplication on binary matrices are performed modulo 2. Both <span>$H_x$</span> and <span>$H_z$</span> are <span>$(n/2)×n$</span> matrices.</p><p><strong>Circulant Bivariate Bicycle Code</strong></p><p>The BB code is represented by matrices <code>A</code> and <code>B</code>, defined as: <span>$A = A_1 + A_2 + A_3$</span> and <span>$B = B_1 + B_2 + B_3$</span>.</p><div class="admonition is-info" id="Note-84d3f500113fca91"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-84d3f500113fca91" title="Permalink"></a></header><div class="admonition-body"><p>Both A and B are matrices in which each row and column contains exactly three non-zero entries when using a 3-term polynomial representation (<a href="../references/#bravyi2024high">Bravyi <em>et al.</em>, 2024</a>).</p></div></div><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/qcga">entry for this family</a>.</p><p><strong>Example</strong></p><p>Here is <code>[[756, 16, ≤ 34]]</code> circulant bivariate bicycle code from Table 1 of (<a href="../references/#bravyi2024high">Bravyi <em>et al.</em>, 2024</a>) with polynomials <span>$A = x^3 + y^10 + y^17$</span> and <span>$B = y^5 + x^3 + x^19$</span>. </p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford; using QuantumClifford.ECC; # hide

julia&gt; l, m = 21, 18;

julia&gt; A = [(:x,3), (:y,10), (:y,17)];

julia&gt; B = [(:y,5), (:x,3), (:x,19)];

julia&gt; c = GeneralizedCirculantBivariateBicycle(l, m, A, B);

julia&gt; code_n(c), code_k(c)
(756, 16)</code></pre><p><strong>Generalized Circulant Bivariate Bicycle Code</strong></p><p>Here is an example of <code>[[128, 14, 12]]</code> generalized circulant bivariate bicycle code that uses 4-term polynomials <span>$c = x^2 + y + y^3 + y^4$</span> and <span>$d = y^2 + x + x^3 + x^4$</span> with group orders <span>$l, m = 8, 8$</span> from (<a href="../references/#eberhardt2024logical">Eberhardt and Steffan, 2024</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford; using QuantumClifford.ECC; # hide

julia&gt; l, m = 8, 8;

julia&gt; A = [(:x,2), (:y,1), (:y,3), (:y,4)];

julia&gt; B = [(:y,2), (:x,1), (:x,3), (:x,4)];

julia&gt; c = GeneralizedCirculantBivariateBicycle(l, m, A, B);

julia&gt; code_n(c), code_k(c)
(128, 14)</code></pre><p>Here is <code>[[18, 4, 4]]</code> generalized circulant bivariate bicycle code that uses 3-term polynomials <span>$a = 1 + x + y$</span> and <span>$b = 1 + x^2 + y^2$</span> with group orders <span>$l, m = 3, 3$</span> from Table III of (<a href="../references/#wang2024coprime">Wang and Mueller, 2024</a>). </p><div class="admonition is-info" id="Note-2543f4bd8b63d245"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-2543f4bd8b63d245" title="Permalink"></a></header><div class="admonition-body"><p>We can also employ 3-term polynomials of a different form than those proposed in (<a href="../references/#bravyi2024high">Bravyi <em>et al.</em>, 2024</a>).</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; l, m = 3, 3;

julia&gt; A = [(:x, 0), (:x, 1), (:y, 1)];

julia&gt; B = [(:y, 0), (:x, 2), (:y, 2)];

julia&gt; c = GeneralizedCirculantBivariateBicycle(l, m, A, B);

julia&gt; code_n(c), code_k(c)
(18, 4)</code></pre><div class="admonition is-info" id="Note-a78a1a0133434c11"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a78a1a0133434c11" title="Permalink"></a></header><div class="admonition-body"><p>The Bivariate Bicycle code <span>$\mathrm{QC}(A,B)$</span> is a specific instance of the <em>Lifted Product</em> construction, where the underlying group is the direct product  <span>$\mathbb{Z}_\ell \times \mathbb{Z}_m$</span> (with <span>$\mathbb{Z}_j$</span> denoting the cyclic group of order <span>$j$</span>).</p></div></div><p>Here is <code>[[36, 4, 6]]</code> generalized circulant bivariate bicycle code that uses 3-term polynomials <span>$a = x + y^2 + y^3$</span> and <span>$b = 1 + y + x^2$</span> with group orders <span>$l, m = 3, 6$</span> from Table III of (<a href="../references/#wang2024coprime">Wang and Mueller, 2024</a>). </p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; import Hecke: group_algebra, GF, abelian_group, gens;

julia&gt; l, m = 3, 6;

julia&gt; GA = group_algebra(GF(2), abelian_group([l, m]));

julia&gt; x, y = gens(GA);

julia&gt; A = x + y^2 + y^3;

julia&gt; B = 1 + y + x^2;

julia&gt; c = two_block_group_algebra_codes(A,B);

julia&gt; code_n(c), code_k(c)
(36, 4)</code></pre><p><strong>Fields</strong></p><ul><li><p><code>l::Int64</code>: Dimension of cyclic shift matrix <code>Sₗ</code> where <code>x = Sₗ ⊗ Iₘ</code></p></li><li><p><code>m::Int64</code>:  Dimension of cyclic shift matrix <code>Sₘ</code> where <code>y = Iₗ ⊗ Sₘ</code></p></li><li><p><code>A::Vector{Tuple{Symbol, Int64}}</code>: Terms in matrix A, where each tuple is (:x or :y, power)</p></li><li><p><code>B::Vector{Tuple{Symbol, Int64}}</code>: Terms in matrix B, where each tuple is (:x or :y, power)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/generalized_circulant_bivariate_bicycle.jl#L1-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.Golay" href="#QECCore.Golay"><code>QECCore.Golay</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Golay &lt;: AbstractCECC</code></pre><p>The family of classical binary Golay codes were discovered by Edouard Golay in his 1949 paper (<a href="../references/#golay1949notes">Golay, 1949</a>), where he described the binary <code>[23, 12, 7]</code> Golay code.</p><p>There are two binary Golay codes:</p><ul><li>Binary <code>[23, 12, 7]</code> Golay code: The perfect code with code length <code>n = 23</code></li></ul><p>and dimension <code>k = 12</code>. By puncturing in any of the coordinates of parity check matrix <code>H</code> = <code>[24, 12, 8]</code>, we obtain a <code>[23, 12, 7]</code> Golay code.</p><ul><li>Extended Binary <code>[24, 12, 8]</code> Golay code: Obtained by adding a parity check bit</li></ul><p>to <code>[23, 12, 7]</code>. The bordered reverse circulant matrix <code>(A)</code> of <code>[24, 12, 8]</code> Golay code is self-dual, i.e., <code>A₂₄</code> is same as A₂₄&#39;.</p><p>The parity check matrix is defined as follows: <code>H₂₄ = [I₁₂ | A&#39;]</code> where <code>I₁₂</code> is the <code>12 × 12</code> identity matrix and <code>A</code> is a bordered reverse circulant matrix. Puncturing and then extending any column in​ with an overall parity check <code>H₂₃</code> reconstructs the original parity check matrix <code>H₂₄</code>. Thus, all punctured codes are equivalent.</p><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/golay">entry for this family</a>.</p><p><strong>Fields</strong></p><ul><li><code>n::Int64</code>: The number of bits in the code.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/classical/golay.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.Gottesman" href="#QECCore.Gottesman"><code>QECCore.Gottesman</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Gottesman &lt;: AbstractQECC</code></pre><p>The family of <code>[[2ʲ, 2ʲ - j - 2, 3]]</code> Gottesman codes, also known as quantum Hamming codes, as described in <a href="../references/#gottesman1997stabilizer">Gottesman&#39;s 1997 PhD thesis</a> and in (<a href="../references/#gottesman1996class">Gottesman, 1996</a>).</p><p>You might be interested in consulting (<a href="../references/#yu2013all">Yu <em>et al.</em>, 2013</a>) and (<a href="../references/#chao2018quantum">Chao and Reichardt, 2017</a>) as well.</p><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/quantum_hamming">entry for this family</a></p><p><strong>Fields</strong></p><ul><li><code>j::Int64</code>: The parameter <code>j</code> of the code.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/gottesman.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.Hamming" href="#QECCore.Hamming"><code>QECCore.Hamming</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Hamming &lt;: AbstractCECC</code></pre><p>The family of <code>[2ʳ - 1, 2ʳ - 1 - r, 3]</code> Hamming binary codes were discovered by Richard W. Hamming in his 1950 paper (<a href="../references/#hamming1950error">Hamming, 1950</a>) as a way of automatically correcting errors introduced by punched card readers. In his original paper, Hamming elaborated his general idea, but specifically focused on the <code>Hamming(7, 4)</code> code which adds three parity bits to four bits of data.</p><p>The Hamming matrix <code>H</code> is an <code>r × (2ʳ - 1)</code> binary matrix, where each column corresponds to the binary representation of the integers from 1 to 2ʳ - 1, with <code>r ≥ 2</code>. This matrix serves as the parity-check matrix for a binary Hamming code with parameters <code>[2ʳ − 1, 2ʳ − 1 − r, 3]</code> The minimum Hamming distance of this code is 3, as detailed in (<a href="../references/#huffman2010fundamentals">Huffman and Pless, 2010</a>).</p><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/hamming">entry for this family</a>.</p><p><strong>Fields</strong></p><ul><li><code>r::Int64</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/classical/hamming.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.Perfect5" href="#QECCore.Perfect5"><code>QECCore.Perfect5</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Perfect5 &lt;: AbstractQECC</code></pre><p><code>Perfect5</code> code (<a href="../references/#lafiamme1996perfect">Lafiamme <em>et al.</em>, 1996</a>) is the smallest qubit stabilizer code to correct a single-qubit error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/fivequbit.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.Phaseflip3" href="#QECCore.Phaseflip3"><code>QECCore.Phaseflip3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Phaseflip3 &lt;: AbstractQECC</code></pre><p><code>Phaseflip3</code> is a three-qubit phase-flip code that corrects single-qubit phase-flip error and does not detect any bit-flip errors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/bitflipcode.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.QuantumReedMuller" href="#QECCore.QuantumReedMuller"><code>QECCore.QuantumReedMuller</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct QuantumReedMuller &lt;: AbstractCSSCode</code></pre><p>The family of <code>[[2ᵐ - 1, 1, 3]]</code> CSS Quantum-Reed-Muller codes, as discovered by Steane in his 1999 paper (<a href="../references/#steane1999quantum">Steane, 1999</a>).</p><p>Quantum codes are constructed from shortened Reed-Muller codes <code>RM(1, m)</code>, by removing the first row and column of the generator matrix <code>Gₘ</code>. Similarly, we can define truncated dual codes <code>RM(m - 2, m)</code> using the generator matrix <code>Hₘ</code> (<a href="../references/#anderson2014fault">Anderson <em>et al.</em>, 2014</a>). The quantum Reed-Muller codes <code>QRM(m)</code> derived from <code>RM(1, m)</code> are CSS codes. </p><p>Given that the stabilizers of the quantum code are defined through the generator matrix of the classical code, the minimum distance of the quantum code corresponds to the minimum distance of the dual classical code, which is <code>d = 3</code>, thus it can correct any single qubit error. Since one stabilizer from the original and one from the dual code are removed in the truncation process, the code parameters are <code>[[2ᵐ - 1, 1, 3]]</code>.</p><p>You might be interested in consulting (<a href="../references/#anderson2014fault">Anderson <em>et al.</em>, 2014</a>) and (<a href="../references/#campbell2012magic">Campbell <em>et al.</em>, 2012</a>) as well.</p><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/quantum_reed_muller">entry for this family</a>.</p><p>See also: <a href="#QECCore.ReedMuller"><code>ReedMuller</code></a> and <a href="#QECCore.RecursiveReedMuller"><code>RecursiveReedMuller</code></a></p><p><strong>Fields</strong></p><ul><li><code>m::Int64</code>: The log-length of the code.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/quantumreedmuller.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.QuantumTannerGraphProduct" href="#QECCore.QuantumTannerGraphProduct"><code>QECCore.QuantumTannerGraphProduct</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct QuantumTannerGraphProduct &lt;: AbstractCSSCode</code></pre><p>Represents the CSS quantum code <code>Q(G₁ × G₂)</code> constructed from two binary codes with parity-check matrices <code>H₁</code> and <code>H₂</code>, using the hypergraph product formulation introduced by (<a href="../references/#tillich2013quantum">Tillich and Zémor, 2013</a>).</p><p>This construction corresponds to a specific product of Tanner graphs:</p><ul><li>Let <code>G₁ = T(V₁, C₁, E₁)</code> and <code>G₂ = T(V₂, C₂, E₂)</code> be the Tanner graphs of <code>H₁</code> and <code>H₂</code>.</li><li>The product graph <code>G₁ × G₂</code> has vertex set <code>(V₁ × V₂) ∪ (C₁ × C₂)</code> and check set <code>(C₁ × V₂) ∪ (V₁ × C₂)</code>.</li><li>The Tanner subgraphs <code>G₁ ×ₓ G₂</code> and <code>G₁ ×𝓏 G₂</code> define classical codes <code>Cₓ</code> and <code>C𝓏</code> used in the CSS construction.</li></ul><p>The <code>hgp(H₁, H₂)</code> function algebraically realizes this graph-theoretic product using Kronecker operations, yielding the <code>X</code>- and <code>Z</code>-type parity-check matrices:</p><ul><li><code>H_X = [H₁ ⊗ I  |  I ⊗ H₂ᵗ]</code> corresponds to <code>G₁ ×ₓ G₂</code></li><li><code>H_Z = [I ⊗ H₂  |  H₁ᵗ ⊗ I]</code> corresponds to <code>G₁ ×𝓏 G₂</code></li></ul><p>These matrices ensure <code>H_X * H_Zᵗ = 0</code>, satisfying the CSS condition.</p><p>See: (<a href="../references/#tillich2013quantum">Tillich and Zémor, 2013</a>), Section 4.3 — “The hypergraph connection, product codes”</p><p><strong>𝑄(𝐺₁ × 𝐺₂)</strong></p><p>The <code>𝑄(𝐺₁ × 𝐺₂)</code> quantum LDPC codes represent a broader generalization of <strong>quantum expander codes</strong> which are derived from the Leverrier-Tillich-Zémor construction (<a href="../references/#tillich2013quantum">Tillich and Zémor, 2013</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford; using QuantumClifford.ECC; using QECCore

julia&gt; H1 = [1 0 1 0; 0 1 0 1; 1 1 0 0];

julia&gt; H2 = [1 1 0; 0 1 1];

julia&gt; c = parity_checks(QuantumTannerGraphProduct(H1, H2))
+ X_____X_____X_____
+ _X_____X____XX____
+ __X_____X____X____
+ ___X_____X____X___
+ ____X_____X___XX__
+ _____X_____X___X__
+ X__X____________X_
+ _X__X___________XX
+ __X__X___________X
+ ZZ__________Z___Z_
+ _ZZ__________Z___Z
+ ___ZZ_________Z_Z_
+ ____ZZ_________Z_Z
+ ______ZZ____Z_____
+ _______ZZ____Z____
+ _________ZZ___Z___
+ __________ZZ___Z__

julia&gt;  code_n(c), code_k(c)
(18, 1)</code></pre><p><strong>Quantum Expander code</strong></p><p>The <code>𝑄(𝐺₁ × 𝐺₂)</code> code is more general than the <strong>standard quantum expander code</strong> (<a href="../references/#leverrier2015quantum">Leverrier <em>et al.</em>, 2015</a>) construction. The quantum expander code construction corresponds to the specific case where <code>G = G1 = G2</code>​.</p><pre><code class="language-julia-repl hljs">julia&gt; H = parity_matrix(RepCode(3));

julia&gt; c = parity_checks(QuantumTannerGraphProduct(H, H))
+ X__X_____X_X______
+ _X__X____XX_______
+ __X__X____XX______
+ ___X__X_____X_X___
+ ____X__X____XX____
+ _____X__X____XX___
+ X_____X________X_X
+ _X_____X_______XX_
+ __X_____X_______XX
+ ZZ_______Z_____Z__
+ _ZZ_______Z_____Z_
+ Z_Z________Z_____Z
+ ___ZZ____Z__Z_____
+ ____ZZ____Z__Z____
+ ___Z_Z_____Z__Z___
+ ______ZZ____Z__Z__
+ _______ZZ____Z__Z_
+ ______Z_Z_____Z__Z

julia&gt;  code_n(c), code_k(c)
(18, 2)</code></pre><p><strong>Fields</strong></p><ul><li><p><code>H1::AbstractMatrix</code>: The first classical seed code for the the quantum tanner graph code.</p></li><li><p><code>H2::AbstractMatrix</code>: The second classical seed code for the the quantum tanner graph code.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/quantumtannergraphproduct.jl#L67-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.RecursiveReedMuller" href="#QECCore.RecursiveReedMuller"><code>QECCore.RecursiveReedMuller</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct RecursiveReedMuller &lt;: AbstractCECC</code></pre><p>A construction of the Reed-Muller class of codes using the recursive definition.</p><p>The Plotkin <code>(u, u + v)</code> construction defines a recursive relation between generator matrices of Reed-Muller <code>(RM)</code> codes (<a href="../references/#abbe2020reed">Abbe <em>et al.</em>, 2020</a>). To derive the generator matrix <code>G(m, r)</code> for <code>RM(r, m)</code>, the generator matrices of lower-order codes are utilized:</p><ul><li><code>G(r - 1, m - 1)</code>: Generator matrix of <code>RM(r - 1, m - 1)</code></li><li><code>G(r, m - 1)</code>: Generator matrix of <code>RM(r, m - 1)</code></li></ul><p>The generator matrix <code>G(m, r)</code> of <code>RM(m, r)</code> is formulated as follows in matrix notation:</p><p class="math-container">\[G(m, r) = egin{bmatrix}
G(r, m - 1) &amp; G(r, m - 1) \
0 &amp; G(r - 1, m - 1)
nd{bmatrix}\]</p><p>Here, the matrix 0 denotes an all-zero matrix with dimensions matching <code>G(r - 1, m - 1)</code>. This recursive approach facilitates the construction of higher-order Reed-Muller codes based on the generator matrices of lower-order codes.</p><p>In addition, the dimension of <code>RM(m - r - 1, m)</code> equals the dimension of the dual of <code>RM(r, m)</code>. Thus, <code>RM(m - r - 1, m) = RM(r, m)^⊥</code> shows that the <a href="https://en.wikipedia.org/wiki/Dual_code">dual code</a> of <code>RM(r, m)</code> is <code>RM(m − r − 1, m)</code>, indicating the parity check matrix of <code>RM(r, m)</code> is the generator matrix for <code>RM(m - r - 1, m)</code>.</p><p>See also: <a href="#QECCore.ReedMuller"><code>ReedMuller</code></a> and <a href="#QECCore.QuantumReedMuller"><code>QuantumReedMuller</code></a></p><p><strong>Fields</strong></p><ul><li><p><code>r::Int64</code>: The order of the code.</p></li><li><p><code>m::Int64</code>: The log-length of the code.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/classical/recursivereedmuller.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.ReedMuller" href="#QECCore.ReedMuller"><code>QECCore.ReedMuller</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ReedMuller &lt;: AbstractCECC</code></pre><p>The family of Reed-Muller codes, as discovered by Muller in his 1954 paper (<a href="../references/#muller1954application">Muller, 1954</a>) and Reed who proposed the first efficient decoding algorithm (<a href="../references/#reed1954class">Reed, 1954</a>).</p><p>Let <code>m</code> be a positive integer and <code>r</code> a nonnegative integer with <code>r ≤ m</code>. These linear codes, denoted as <code>RM(r, m)</code>, have order <code>r</code> (where <code>0 ≤ r ≤ m</code>) and codeword length <code>n</code> of <code>2ᵐ</code>.</p><p>Two special cases of generator(RM(r, m)) exist:     1. <code>generator(RM(0, m))</code>: This is the <code>0ᵗʰ</code>-order <code>RM</code> code, similar to the binary repetition code with length <code>2ᵐ</code>. It&#39;s characterized by a single basis vector containing all ones.     2. <code>generator(RM(m, m))</code>: This is the <code>mᵗʰ</code>-order <code>RM</code> code. It encompasses the entire field <code>F(2ᵐ)</code>, representing all possible binary strings of length <code>2ᵐ</code>.</p><p>You might be interested in consulting (<a href="../references/#raaphorst2003reed">Raaphorst, 2003</a>), (<a href="../references/#abbe2020reed">Abbe <em>et al.</em>, 2020</a>), and (<a href="../references/#djordjevic2021quantum">Djordjevic, 2021</a>) as well.</p><p>The dimension of <code>RM(m - r - 1, m)</code> equals the dimension of the dual of <code>RM(r, m)</code>. Thus, <code>RM(m - r - 1, m) = RM(r, m)^⊥</code> shows that the <a href="https://en.wikipedia.org/wiki/Dual_code">dual code</a> of <code>RM(r, m)</code> is <code>RM(m − r − 1, m)</code>, indicating the parity check matrix of <code>RM(r, m)</code> is the generator matrix for <code>RM(m - r - 1, m)</code>.</p><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/reed_muller">entry for this family</a>.</p><p>See also: <a href="#QECCore.RecursiveReedMuller"><code>RecursiveReedMuller</code></a> and <a href="#QECCore.QuantumReedMuller"><code>QuantumReedMuller</code></a></p><p><strong>Fields</strong></p><ul><li><p><code>r::Int64</code>: The order of the code.</p></li><li><p><code>m::Int64</code>: The log-length of the code.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/classical/reedmuller.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.RepCode" href="#QECCore.RepCode"><code>QECCore.RepCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct RepCode &lt;: AbstractCECC</code></pre><p>Repetition code is a classical error correction code that repeats the same bit <code>n</code> times.</p><p><strong>Fields</strong></p><ul><li><code>n::Int64</code>: The number of times to repeat the bit.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/classical/repetition.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.Shor9" href="#QECCore.Shor9"><code>QECCore.Shor9</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Shor9 &lt;: AbstractCSSCode</code></pre><p>Shor9 code (<a href="../references/#shor1995scheme">Shor, 1995</a>)is a nine-qubit CSS code that is the first quantum error-correcting code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/shorcode.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.Steane7" href="#QECCore.Steane7"><code>QECCore.Steane7</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Steane7 &lt;: AbstractCSSCode</code></pre><p>Steane code (<a href="../references/#steane1996error">Steane, 1996</a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/steanecode.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.Surface" href="#QECCore.Surface"><code>QECCore.Surface</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Surface &lt;: AbstractCSSCode</code></pre><p>The planar surface code refers to the code (<a href="../references/#kitaev2003fault">Kitaev, 2003</a>) in a 2D lattice with open boundaries. Illustration of a 3×2 surface code, where qubits are located on the edges:</p><pre><code class="language-julia hljs">|---1--(Z)--2---|---3---|
|  (X)  7       8       o
|---4---|---5---|---6---|
|       o       o       o
|       |       |       |</code></pre><p>The surface code has open boundary conditions, unlike the toric code. To this end, we remove qubits (denoted by &quot;o&quot;) and parity checks on the right and bottom sides.</p><p>Faces like <code>(1,4,7)</code> have <code>X</code> checks, and crosses like <code>(1,2,7)</code> have <code>Z</code> checks. Due to the removal of the bottom and right sides, we have some 3-qubit checks on the boundaries.</p><p>The parity checks of <code>Surface(3,2)</code> are:</p><pre><code class="language-julia hljs">X__X__X_
_X__X_XX
__X__X_X
ZZ____Z_
_ZZ____Z
___ZZ_Z_
____ZZ_Z</code></pre><p>More information can be seen in (<a href="../references/#fowler2012surface">Fowler <em>et al.</em>, 2012</a>).</p><p><strong>Fields</strong></p><ul><li><p><code>dx::Int64</code>: The number of qubits in the <code>x</code> direction.</p></li><li><p><code>dz::Int64</code>: The number of qubits in the <code>z</code> direction.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/surface.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.TillichZemor" href="#QECCore.TillichZemor"><code>QECCore.TillichZemor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct TillichZemor{M} &lt;: AbstractCSSCode</code></pre><p>The <code>[[n² + m²,(n - rank([C ∣ M]))² + (m − rank([C ∣ M]ᵀ))², d]]</code> <strong>quantum Tillich Zémor code</strong> is a novel quantum LDPC code is constructed using the hypergraph product of two classical seed <strong>(n, m, r)-Structured LDPC</strong> codes.</p><p><strong>Structured LDPC</strong></p><p>The classical <code>(n, m, r)</code>-structured LDPC codes were introduced in (<a href="../references/#tillich2006minimum">Tillich and Zémor, 2006</a>).  The minimum distance of structured binary LDPC codes with parity-check matrices of the form <span>$[C \mid M]$</span>, where <code>C</code> is circulant and <code>M</code> has fixed column weight <span>$r \geq 3$</span>, is in <span>$O(n^{\frac{r-2}{r-1} + \epsilon})$</span>, improving the previous bound of <span>$O(n^{\frac{r-1}{r}}$</span>(<a href="../references/#arnault2025upperboundsminimumdistance">Arnault <em>et al.</em>, 2025</a>).</p><p>The classical <em>structured</em> LDPC codes are defined by a specific structure in their parity-check matrix <code>H</code>, which is composed of a circulant matrix <code>C</code> and a binary matrix <code>M</code>. The ensemble of these codes is referred to as <code>(n, m, r)</code>-structured LDPC codes, where <code>n</code> is the block length of the code, <code>m</code> is the number of parity-check equations, <code>r</code> is the weight of the columns in the matrix <code>M</code>.</p><p><strong>Parity-Check Matrix Structure</strong></p><p>The parity-check matrix <code>H</code> is an <code>m × n</code> binary matrix of the form: <span>$[C \mid M]$</span> where: <code>C</code>  is an  <span>$m \times m$</span>  <strong>circulant matrix</strong>. <code>M</code> is an <span>$m \times (n - m)$</span> binary matrix with specific properties.</p><p><strong>Circulant Matrix C</strong></p><p>The circulant matrix <code>C</code> is defined as:</p><p class="math-container">\[\begin{aligned}
C = \begin{pmatrix}
1 &amp;        &amp;        &amp;        &amp; 1 \\
1 &amp; 1      &amp;        &amp;        &amp;   \\
  &amp; 1      &amp; \ddots &amp;        &amp;   \\
  &amp;        &amp; \ddots &amp; 1      &amp;   \\
  &amp;        &amp;        &amp; 1      &amp; 1
\end{pmatrix}
\end{aligned}\]</p><p>This matrix has the property that each row is a cyclic shift of the previous row. The first row contains two consecutive <code>1</code>s, and the rest of the entries are <code>0</code>s.</p><p><strong>Binary Matrix M</strong></p><p>The matrix <code>M</code> satisfies the following conditions:</p><ul><li><strong>No Zero Rows</strong>: Every row of <code>M</code> contains at least one non-zero element.</li><li><strong>Column Weight</strong>: Every column of <code>M</code> has a constant weight <code>r</code>, where <span>$r \geq 3$</span>.</li></ul><p><strong>Existence Conditions</strong></p><p>The family of classical <code>(n, m, r)</code>-structured LDPC codes exists if and only if the following conditions are satisfied:</p><p class="math-container">\[\begin{aligned}
m \geq r \quad \text{and} \quad (n - m)r \geq m
\end{aligned}\]</p><p>These conditions ensure that the matrix <code>M</code> can be constructed with the required properties.</p><p><strong>Quantum <span>$(n, m, r)$</span>-Structured LDPC codes</strong></p><p>We introduce a novel construction of quantum LDPC codes from classical <span>$(n, m, r)$</span>-structured LDPC seed codes, whose parity-check matrices <span>$H = [C \mid M]$</span> consist of an <span>$m \times m$</span> circulant core <span>$C$</span> with column weight <span>$2$</span> (enabling linear-time encoding) and an <span>$m \times (n-m)$</span> matrix <code>M</code> with column weight <span>$r \geq 3$</span> and no zero rows. The resulting <strong>quantum Tillich-Zémor code</strong> has block length <span>$N = n^2 + m^2` and code dimension$</span>K = (n - \text{rank}([C \mid M]))^2 + (m - \text{rank}([C \mid M]^\top))^2<span>$. This construction inherits the classical seed code&#39;s sub-linear distance scaling ($</span>d = O(n^{\frac{r-2}{r-1}+\epsilon}`<code>) per Theorem</code>1` of (<a href="../references/#arnault2025upperboundsminimumdistance">Arnault <em>et al.</em>, 2025</a>) while preserving efficient encoding.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford; using QuantumClifford.ECC; using QECCore;

julia&gt; n, m, r = 4, 3, 3;

julia&gt; c = parity_checks(TillichZemor(n, m, r))
+ X_______X___X___XX_______
+ _X_______X___X___XX______
+ __X_______X___X_X_X______
+ ___X_______X___XXXX______
+ X___X_______X______XX____
+ _X___X_______X______XX___
+ __X___X_______X____X_X___
+ ___X___X_______X___XXX___
+ ____X___X___X_________XX_
+ _____X___X___X_________XX
+ ______X___X___X_______X_X
+ _______X___X___X______XXX
+ Z_ZZ____________Z__Z_____
+ ZZ_Z_____________Z__Z____
+ _ZZZ______________Z__Z___
+ ____Z_ZZ___________Z__Z__
+ ____ZZ_Z____________Z__Z_
+ _____ZZZ_____________Z__Z
+ ________Z_ZZ____Z_____Z__
+ ________ZZ_Z_____Z_____Z_
+ _________ZZZ______Z_____Z
+ ____________Z_ZZZ__Z__Z__
+ ____________ZZ_Z_Z__Z__Z_
+ _____________ZZZ__Z__Z__Z

julia&gt; code_n(c), code_k(c)
(25, 1)

julia&gt; n, m, r = 100, 40, 40;

julia&gt; c = TillichZemor(n, m, r);

julia&gt; code_n(c), code_k(c)
(11600, 3722)</code></pre><p><strong>Fields</strong></p><ul><li><p><code>n::Int64</code>: The block length of the classical <strong>(n, m, r)-Structured LDPC</strong> seed code.</p></li><li><p><code>m::Int64</code>: The number of check nodes (rows in the parity-check matrix <code>H</code>).</p></li><li><p><code>r::Int64</code>: The column weight parameter for matrix <code>M</code> (each column of M must have exactly <code>r</code> ones).</p></li><li><p><code>matrices::Any</code>: The <code>X</code>-type and <code>Z</code>-type parity check matrices generated via the hypergraph product of the classical parity check matrix <code>H = [C | M]</code>. For randomized constructions via <code>random_TillichZemor_code</code>, these matrices are derived from the hypergraph product of a randomly generated <strong>(n, m, r)-Structured LDPC</strong> seed code.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/tillichzemor.jl#L1-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.Toric" href="#QECCore.Toric"><code>QECCore.Toric</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Toric &lt;: AbstractCSSCode</code></pre><p>The Toric code (<a href="../references/#kitaev2003fault">Kitaev, 2003</a>). Illustration of a 2x2 toric code, where qubits are located on the edges:</p><pre><code class="language-julia hljs">|--1-(Z)-2--|
| (X) 5     6
|--3--|--4--|
|     7     8
|     |     |</code></pre><p>It is important to note that the toric code has periodic boundary conditions, which means that the top and bottom sides are essentially glued together, as are the left and right sides.</p><p>Faces like <code>(1,3,5,6)</code> have <code>X</code> checks, and crosses like <code>(1,2,5,7)</code> have <code>Z</code> checks.</p><p>The parity checks of <code>Toric(2,2)</code> are:</p><pre><code class="language-julia hljs">X_X_XX__
_X_XXX__
X_X___XX
ZZ__Z_Z_
ZZ___Z_Z
__ZZZ_Z_</code></pre><p><strong>Fields</strong></p><ul><li><p><code>dx::Int64</code>: The number of qubits in the <code>x</code> direction.</p></li><li><p><code>dz::Int64</code>: The number of qubits in the <code>z</code> direction.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/toric.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.Triangular488" href="#QECCore.Triangular488"><code>QECCore.Triangular488</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Triangular488 &lt;: QECCore.TriangularCode</code></pre><p>Triangular code following the <code>4.8.8</code> tiling. Constructor take a distance <code>d</code> as input.</p><p><strong>Example</strong></p><p>Here is <code>[[17,1, 5]]</code> color code following the <code>4.8.8</code> tiling:</p><pre><code class="language-julia-repl hljs">julia&gt; import HiGHS; import JuMP; # hide

julia&gt; using QuantumClifford.ECC: Triangular666, DistanceMIPAlgorithm; # hide

julia&gt; c = Triangular488(5);

julia&gt; code = Stabilizer(c)
+ XXXX_____________
+ X_X_XX___________
+ __XX_XX__XX__XX__
+ ____XX__XX_______
+ ______XX__XX_____
+ _______X___X___XX
+ ________XX__XX___
+ __________XX__XX_
+ ZZZZ_____________
+ Z_Z_ZZ___________
+ __ZZ_ZZ__ZZ__ZZ__
+ ____ZZ__ZZ_______
+ ______ZZ__ZZ_____
+ _______Z___Z___ZZ
+ ________ZZ__ZZ___
+ __________ZZ__ZZ_

julia&gt; distance(c, DistanceMIPAlgorithm(solver=HiGHS))
5</code></pre><p>More information can be seen in (<a href="../references/#landahl2011color">Landahl <em>et al.</em>, 2011</a>)</p><p><strong>Fields</strong></p><ul><li><code>d::Int64</code>: The distance of the code.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/color_codes.jl#L6-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.Triangular666" href="#QECCore.Triangular666"><code>QECCore.Triangular666</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Triangular666 &lt;: QECCore.TriangularCode</code></pre><p>Triangular code following the <code>6.6.6</code> tiling. Constructor take a distance <code>d</code> as input.</p><p><strong>Example</strong></p><p>Here is <code>[[19,1, 5]]</code> color code following the <code>6.6.6</code> tiling:</p><pre><code class="language-julia-repl hljs">julia&gt; import HiGHS; import JuMP; # hide

julia&gt; using QuantumClifford.ECC: Triangular666, DistanceMIPAlgorithm; # hide

julia&gt; c = Triangular666(5);

julia&gt; code = Stabilizer(c)
+ XXXX_______________
+ _X_X_XX____________
+ __XXXX_XX__________
+ ____X__X__XX_______
+ _________X___X___XX
+ _____XX_XX__XX_____
+ _______XX__XX__XX__
+ __________XX__XX___
+ ____________XX__XX_
+ ZZZZ_______________
+ _Z_Z_ZZ____________
+ __ZZZZ_ZZ__________
+ ____Z__Z__ZZ_______
+ _________Z___Z___ZZ
+ _____ZZ_ZZ__ZZ_____
+ _______ZZ__ZZ__ZZ__
+ __________ZZ__ZZ___
+ ____________ZZ__ZZ_

julia&gt; distance(c, DistanceMIPAlgorithm(solver=HiGHS))
5</code></pre><p>More information can be seen in (<a href="../references/#landahl2011color">Landahl <em>et al.</em>, 2011</a>)</p><p><strong>Fields</strong></p><ul><li><code>d::Int64</code>: The distance of the code.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/color_codes.jl#L63-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.GoppaCode-Tuple" href="#QECCore.GoppaCode-Tuple"><code>QECCore.GoppaCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Goppa codes (<a href="../references/#goppa1970new">Goppa, 1970</a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/classical/goppa.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.bivariate_bicycle_code_k" href="#QECCore.bivariate_bicycle_code_k"><code>QECCore.bivariate_bicycle_code_k</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with <code>Oscar</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/interface.jl#L449">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.code_k" href="#QECCore.code_k"><code>QECCore.code_k</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">code_k(c::AbstractECC)</code></pre><p>The number of logical qubits in a error correction code.</p><p>See also: <a href="#QECCore.code_n-Tuple{AbstractQECC}"><code>code_n</code></a> and <a href="#QECCore.code_s"><code>code_s</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/interface.jl#L82-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.code_n-Tuple{AbstractQECC}" href="#QECCore.code_n-Tuple{AbstractQECC}"><code>QECCore.code_n</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">code_n(c::AbstractECC)</code></pre><p>The number of physical qubits in a error correction code.</p><p>See also: <a href="#QECCore.code_k"><code>code_k</code></a> and <a href="#QECCore.code_s"><code>code_s</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/interface.jl#L59-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.code_s" href="#QECCore.code_s"><code>QECCore.code_s</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">code_s(c::AbstractECC)</code></pre><p>The number of stabilizers in a error correction code. They might not be all linearly independent, thus <code>code_s &gt;= code_n-code_k</code>. For the number of linearly independent checks you can use <code>LinearAlgebra.rank</code>.</p><p>See also: <a href="#QECCore.code_n-Tuple{AbstractQECC}"><code>code_n</code></a> and <a href="#QECCore.code_k"><code>code_k</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/interface.jl#L71-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.distance" href="#QECCore.distance"><code>QECCore.distance</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance(c::AbstractECC)</code></pre><p>The code distance of a error correction code.</p><p>See also: <a href="#QECCore.code_n-Tuple{AbstractQECC}"><code>code_n</code></a> and <a href="#QECCore.code_k"><code>code_k</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/interface.jl#L103-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.generator_polynomial" href="#QECCore.generator_polynomial"><code>QECCore.generator_polynomial</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generator_polynomial(c::AbstractCECC)</code></pre><p>The generator polynomial g(x) of a <a href="https://en.wikipedia.org/wiki/Cyclic_code">cyclic code</a> which generates the ideal corresponding to the code in the quotient ring <span>$\mathbb{F}_q[x]/(x^n - 1)$</span>.</p><p>The generator polynomial is the unique <em>monic</em> polynomial of minimal degree in the <a href="https://en.wikipedia.org/wiki/Polynomial_code">polynomial code</a>. For a cyclic  code C of length n over <span>$\mathbb{F}_q$</span>, g(x) satisfies:</p><ul><li>g(x) divides <span>$x^n - 1$</span> in <span>$\mathbb{F}_q[x]$</span>.</li><li>The degree of g(x) is n - k, where k is the code dimension for the non-degenerate case.</li><li>Every codeword polynomial <span>$c(x) \in C$</span> can be expressed as <span>$c(x) = m(x)g(x) \mod (x^n - 1)$</span>.</li></ul><p>The input is a classical polynomial error-correcting code defined over a finite field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/interface.jl#L452-L466">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.metacheck_matrix" href="#QECCore.metacheck_matrix"><code>QECCore.metacheck_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">metacheck_matrix(c::AbstractCSSCode)</code></pre><p>Return the X- and Z-metacheck matrices for CSS codes enabling <strong>single-shot quantum error correction</strong> — a fault-tolerant scheme that corrects both data and measurement errors using <strong>one</strong> round of syndrome measurements ((<a href="../references/#Higgott_2023">Higgott and Breuckmann, 2023</a>), (<a href="../references/#quintavalle2021single">Quintavalle <em>et al.</em>, 2021</a>)).</p><p><strong>Single-Shot QEC</strong></p><p>Single-shot QEC enables both physical errors on qubits and errors in syndrome measurements to be detected and corrected using only a <em>single round of noisy measurements</em>, without requiring repeated measurement rounds. A layer of redundancy is added to the measurement process itself. This redundancy is captured by <em>metasyndromes</em>: linear constraints that the noisy syndrome outcomes must satisfy if no measurement error has occurred. When violated, they indicate faults in the syndrome extraction layer itself.</p><p>Traditional QEC combats measurement faults by repeating stabilizer measurements. In contrast, <strong>single-shot QEC</strong> uses <em>spatial redundancy</em> via <strong>metachecks</strong> — extra linear constraints on syndrome outcomes (&quot;checks of checks&quot;) to detect and correct measurement errors immediately.</p><p>As noted in (<a href="../references/#Higgott_2023">Higgott and Breuckmann, 2023</a>): &quot;Some single-shot codes have <em>linear dependencies</em> amongst the check operators, leading to syndromes becoming code words of a classical linear code (called a <em>metacode</em>) that can be used for syndrome repair. These linear dependencies are not a requirement for a code to be single-shot (indeed, quantum expander codes are single shot and confined but can have full-rank check matrices); however, a metacode can nevertheless be useful when decoding. We can construct a code that has syndromes encoded in a metacode using a chain complex with length at least 3 (to obtain a metacode for either X or Z syndromes), or length 4 if we would like a metacode for both X and Z syndromes.&quot;</p><p><strong>Confinement and Single-Shot Decoding</strong></p><p>Metachecks enable single-shot decoding by providing a metacode for syndrome repair, but their role is best understood through the broader property of <strong>confinement</strong> (<a href="../references/#Higgott_2023">Higgott and Breuckmann, 2023</a>):</p><ul><li>A code has <em>(t,f)</em>-confinement if, for all errors <em>E</em> with <span>$|E|_{\text{red}} \leq t$</span>,</li></ul><p>the syndrome weight satisfies <span>$f(|\sigma(E)|) \geq |E|_{\text{red}}$</span>, where <span>$f: \mathbb{Z} \to \mathbb{R}$</span> is an increasing function. This bounds the physical error weight by a function of the syndrome weight.</p><p>Codes with metachecks (e.g., D-dimensional surface and toric codes) exhibit confinement because <span>$M_X/M_Z$</span> constrain syndromes to a metacode, but confinement can exist <em>without</em> metachecks (e.g., quantum expander codes). Thus, while metachecks are sufficient for single-shot QEC (via syndrome repair), they are not strictly necessary.</p><p><strong>Repair-Syndrome Decoding</strong></p><p>To correct errors in CSS codes, a <strong>two-stage</strong> decoder can be employed when given a noisy syndrome measurement <code>z′</code>. This method separately addresses data qubit errors (e.g., <code>Z</code>-errors) and syndrome measurement errors (e.g., faulty X-stabilizer measurements). The same approach applies symmetrically for X-errors and Z-stabilizer measurements.</p><p><strong>Stage I: Syndrome Repair via Metachecks</strong></p><ul><li>The metacheck matrix <span>$M_X$</span> computes the metasyndrome <span>$s = M_Xz&#39;$</span>, identifying inconsistencies caused by measurement errors.</li><li>A classical decoder <span>$f^1_d : \mathbb{F}^{n_{i-2}}_2 \rightarrow \mathbb{F}^{n_{i-1}}_2$</span> estimates the noiseless syndrome <span>$z$</span> from <span>$s$</span>, effectively &quot;repairing&quot; the syndrome.</li></ul><p><strong>Stage II: Data Qubit Correction</strong></p><p>A second decoder <span>$f^2_d : \mathbb{F}^{n_{i-1}}_2 \rightarrow \mathbb{F}^n_2$</span>​ uses the corrected syndrome <code>z</code> to compute a noise vector <code>n</code> such that <span>$H_{X}n = z$</span>, determining the most likely data qubit errors.</p><p>The correction can fail in two ways:</p><ul><li><strong>Invalid Syndrome</strong>: The repaired <code>z</code> lies outside the valid syndrome space <span>$im(H_X​$</span>).</li><li><strong>Logical Error</strong>: The correction <code>n</code> corresponds to a nontrivial logical operator (i.e., <span>$n \in \ker(H_X)$</span>).</li></ul><p>To mitigate the first failure (i.e. invalid syndrome), we can modify the metacheck matrix to</p><p class="math-container">\[\begin{aligned}
M&#39; = \begin{pmatrix}
M_X \\
L_M
\end{pmatrix}
\end{aligned}\]</p><p>where <span>$L_M$</span> spans the cohomology group <span>$H^{i-1}$</span>. However, if <span>$L_M$</span> is non-sparse (common in topological codes), decoding efficiency may suffer.</p><div class="admonition is-info" id="Note-f99322258f349464"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-f99322258f349464" title="Permalink"></a></header><div class="admonition-body"><p>The modified metacheck matrix <span>$M&#39;$</span> is only employed when the initial decoding attempt yields an invalid syndrome (<span>$z \notin \text{im}(H_X)$</span>). This approach helps maintain decoder efficiency, particularly for topological codes where <span>$L_M$</span> is typically non-sparse (<a href="../references/#Higgott_2023">Higgott and Breuckmann, 2023</a>). However, the overall performance of two-stage decoders remains fundamentally constrained by the metacode&#39;s threshold, often resulting in suboptimal error correction capability.</p></div></div><p><strong>Single-Stage Decoding</strong></p><p>Single-stage decoding provides a unified framework for correcting both data qubit errors (<code>e</code>) and syndrome measurement errors (<code>s_e</code>) simultaneously (<a href="../references/#Higgott_2023">Higgott and Breuckmann, 2023</a>). Given an observed syndrome <span>$s = H_X e + s_e$</span>, where <code>H_X</code> is the <code>X</code>-stabilizer matrix, the decoder seeks the most probable error configuration <span>$e&#39; = \begin{pmatrix}e \\ s_e\end{pmatrix}$</span> that satisfies the extended parity-check equation:</p><p class="math-container">\[\begin{aligned}
H&#39; e&#39; = s \quad \text{where} \quad H&#39; = \begin{pmatrix}H_X &amp; I_r\end{pmatrix}
\end{aligned}\]</p><p>The Tanner graph <span>$T(H&#39;)$</span> for this system is constructed by augmenting the original Tanner graph <span>$T(H_X)$</span> with additional variable nodes <span>$\{v_i^m\}_{i=1}^r$</span> representing potential measurement errors. Each check node <span>$f_i$</span> gains a corresponding edge <span>$(v_i^m, f_i)$</span>, creating a structure where measurement errors appear explicitly in the decoding graph.</p><p>The decoding framework can be further enhanced by explicitly incorporating <em>metachecks</em> through the extended matrix:</p><p class="math-container">\[\begin{aligned}
\begin{equation}
H_M = \begin{pmatrix}
H_X &amp; I_r \\
0 &amp; M
\end{pmatrix}
\end{equation}
\end{aligned}\]</p><p>where <span>$M$</span> is the metacheck matrix. Though these metachecks are implicitly present as linear combinations in <span>$T(H&#39;)$</span>, their explicit inclusion significantly improves decoder performance.</p><p>The single-stage decoding approach offers several key advantages over two-stage methods, including the elimination of metacode failures—since the combined error syndrome <span>$s + s_e$</span> is within the image of <span>$H_X$</span> by construction—along with the avoidance of non-sparse <span>$L_M$</span> matrices that can degrade decoder performance, and ultimately yielding improved thresholds for topological codes (<a href="../references/#Higgott_2023">Higgott and Breuckmann, 2023</a>).</p><p><strong>Chain Complexes and <span>$\mathbb{F_2}$</span> Homology</strong></p><p>A chain complex of length <code>l</code> is a <a href="https://en.wikipedia.org/wiki/Exact_sequence">sequence</a> of <a href="https://en.wikipedia.org/wiki/Vector_space">vector spaces</a> connected by <a href="https://en.wikipedia.org/wiki/Boundary_(topology)">boundary</a> maps:</p><p class="math-container">\[\begin{aligned}
\{0\} \xrightarrow{\partial_{l+1}} C_l \xrightarrow{\partial_l} C_{l-1} \xrightarrow{\partial_{l-1}} \cdots \xrightarrow{\partial_1} C_0 \xrightarrow{\partial_0} \{0\}
\end{aligned}\]</p><p>where</p><ul><li>Each <span>$C_i$</span> is called an <em>i-cell</em>.</li><li>The <a href="https://en.wikipedia.org/wiki/Image_(mathematics)">image</a> of <span>$\partial_{i+1}$</span>, denoted <span>$\mathrm{im}\partial_{i+1}$</span>, consists of <em>i-boundaries</em>.</li><li>The <a href="https://en.wikipedia.org/wiki/Kernel_(algebra)#Linear_maps">kernel</a> of <span>$\partial_i$</span>, denoted <span>$\ker\partial_i$</span>, consists of <em>i-cycles</em>.</li></ul><p>The boundary maps satisfy the constraint:</p><p class="math-container">\[\begin{aligned}
\partial_i \circ \partial_{i+1} = 0 \quad \text{for all } i \in \{0, \dots, l\}
\end{aligned}\]</p><p>Because <span>$\partial_i \circ \partial_{i+1} = 0$</span>, every boundary is a cycle:</p><p class="math-container">\[\begin{aligned}
\mathrm{im}\partial_{i+1} \subseteq \ker\partial_i
\end{aligned}\]</p><p>The <strong>i-th <a href="https://en.wikipedia.org/wiki/Homology_(mathematics)">homology</a> group</strong> measures the difference between cycles and boundaries:</p><p class="math-container">\[\begin{aligned}
H_i = \frac{\ker\partial_i}{\mathrm{im}\partial_{i+1}}
\end{aligned}\]</p><p>Associated with a chain complex is a <strong>cochain complex</strong> with <em>coboundary operators</em> <span>$\delta^i: C^i \to C^{i+1}$</span>, typically defined as the transpose (or dual) of the boundary maps:</p><p class="math-container">\[\begin{aligned}
\{0\} \xrightarrow{\delta^{-1}} C^0 \xrightarrow{\delta^0} C^1 \xrightarrow{\delta^1} \cdots \xrightarrow{\delta^{l-1}} C^l \xrightarrow{\delta^l} \{0\}
\end{aligned}\]</p><p>where</p><ul><li><span>$\ker\delta^i$</span> consists of <em>i-cocycles</em>.</li><li><span>$\mathrm{im}\delta^{i-1}$</span> consists of <em>i-coboundaries</em>.</li></ul><p>The <strong>i-th cohomology group</strong> is:</p><p class="math-container">\[\begin{aligned}
H^i = \frac{\ker\delta^i}{\mathrm{im}\delta^{i-1}}
\end{aligned}\]</p><p><strong>CSS codes using Homological Algebra</strong></p><p>Quantum CSS codes can be described using the framework of <a href="https://en.wikipedia.org/wiki/Chain_complex">chain complexes</a>.</p><p>For a chain complex of length <code>l ≥ 4</code> , where qubits are placed on <code>i</code>-cells (<code>C_i</code>) with (<code>1 &lt; i &lt; l−1</code>):</p><p class="math-container">\[\begin{aligned}
C_{l-1} \xrightarrow{\partial_{l-1}} \cdots \xrightarrow{\partial_{i+2}} C_{i+1} \xrightarrow{\partial_{i+1}} C_i \xrightarrow{\partial_i} C_{i-1} \xrightarrow{\partial_{i-1}} \cdots \xrightarrow{\partial_1} C_0
\end{aligned}\]</p><p>where</p><ul><li><code>parity_checks_x(c)</code>: <strong>X-stabilizers</strong> are given by the boundary map <span>$H_X = \partial_i: C_i → C_{i-1}$</span>.</li><li><code>parity_checks_z(c)</code>: <strong>Z-stabilizers</strong> are given by the coboundary map <span>$H_Z = \partial_{i+1}^T: C_i → C_{i+1}$</span>.</li><li><code>metacheck_matrix_x(c)</code>: <strong>X-metachecks</strong> are defined as <span>$M_X = \partial_{i-1}: C_{i-1} → C_{i-2}$</span>.</li><li><code>metacheck_matrix_z(c)</code>: <strong>Z-metachecks</strong> are defined as <span>$M_Z = \partial_{i+2}^T: C_{i+2} → C_{i+1}$</span>.</li></ul><p>The boundary conditions <span>$\partial_{i-1} \partial_i = 0$</span> (i.e., <span>$M_X H_X = 0$</span>) guarantee that valid syndromes (<code>im H_X</code>) lie in <code>ker M_X</code>.</p><p>Invalid syndromes in <span>$ker M_X \setminus im H_X$</span> belong to the <span>$(i−1)$</span>-th homology group <span>$H_{i-1} = \ker \partial_{i-1} / \mathrm{im} \partial_i$</span>, while invalid <code>Z</code>-syndromes in <span>$ker M_Z \setminus im H_Z$</span> belong to the <span>$(i+1)$</span>-th cohomology group.</p><div class="admonition is-info" id="Note-6f2002a3a21ee27b"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-6f2002a3a21ee27b" title="Permalink"></a></header><div class="admonition-body"><p>A code can be designed to incorporate syndromes within a metacode by employing a chain complex of minimum length three—sufficient for encoding either X or Z syndromes. If the goal is to include both X and Z syndromes in the metacode, the chain complex must extend to at least length four (<a href="../references/#Higgott_2023">Higgott and Breuckmann, 2023</a>).</p></div></div><p><strong>Metachecks in Higher-Dimensional Complexes</strong></p><p>In D-dimensional codes, such as the <code>4D</code> surface code, we consider a <code>5</code>-term chain complex:</p><p class="math-container">\[\begin{aligned}
C_4 \xrightarrow{\partial_4} C_3 \xrightarrow{\partial_3} C_2 \xrightarrow{\partial_2} C_1 \xrightarrow{\partial_1} C_0
\end{aligned}\]</p><p>In this chain complex framework:</p><ul><li>Standard parity checks are: <span>$\partial_3 = H_Z^\top$</span>, and <span>$\partial_2 = H_X$</span></li><li>Metachecks correspond to: <span>$\partial_4 = M_Z^\top$</span>, and <span>$\partial_1 = M_X$</span></li></ul><p><strong>Syndrome Validation</strong></p><p>The matrices <code>M_X</code> and <code>M_Z</code> enforce syndrome validity via boundary conditions from the chain complex:</p><p class="math-container">\[\begin{aligned}
M_Xs_X = 0 \quad &amp;\text{for X-syndromes } (s_X \in C_1) \\
M_Zs_Z = 0 \quad &amp;\text{for Z-syndromes } (s_Z \in C_3)
\end{aligned}\]</p><p>See also: <a href="#QECCore.metacheck_matrix_x"><code>metacheck_matrix_x</code></a>, <a href="#QECCore.metacheck_matrix_z"><code>metacheck_matrix_z</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/interface.jl#L191-L446">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.metacheck_matrix_x" href="#QECCore.metacheck_matrix_x"><code>QECCore.metacheck_matrix_x</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">metacheck_matrix_x(c::AbstractCSSCode)</code></pre><p>Returns the X-metacheck matrix (<span>$M_X = \partial_{i-1}$</span>) for a CSS code defined by a <a href="https://en.wikipedia.org/wiki/Chain_complex">chain complex</a> of length <code>l ≥ 4</code>, where qubits are placed on <code>i</code>-cells with <span>$1 &lt; i &lt; l−1$</span>.</p><p>This matrix acts on X-syndromes (measurement outcomes from X-type stabilizers that detect Z-errors, obtained via <a href="#QECCore.parity_matrix_x"><code>parity_matrix_x</code></a> and enforces the constraint <span>$M_X s_X = 0$</span>, ensuring syndromes <span>$s_X$</span> are valid codewords of a classical <em>metacode</em>.</p><div class="admonition is-info" id="Note-a3cc960013cffbd4"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a3cc960013cffbd4" title="Permalink"></a></header><div class="admonition-body"><p>For an introduction to <a href="https://en.wikipedia.org/wiki/Chain_complex">chain complexes</a> in quantum error correction and the role of metachecks in single-shot QEC, see the documentation for <a href="#QECCore.metacheck_matrix"><code>metacheck_matrix</code></a>.</p></div></div><p><strong>Example: 4D surface code</strong></p><p>In the 5-term chain complex used for the 4D surface code:</p><p class="math-container">\[\begin{aligned}
C_4 \xrightarrow{\partial_4} C_3 \xrightarrow{\partial_3} C_2 \xrightarrow{\partial_2} C_1 \xrightarrow{\partial_1} C_0
\end{aligned}\]</p><p>the metacheck matrix <span>$M_X = \partial_1$</span> obtained via <a href="#QECCore.metacheck_matrix_x"><code>metacheck_matrix_x</code></a> satisfies the following:</p><ul><li>Acts on X-syndromes: <span>$s_X \in C_1$</span>.</li><li>It enforces <span>$M_Xs_X = 0$</span>, i.e. only valid syndromes lie in <span>$\ker M_X$</span>.</li><li>It satisfies the boundary condition <span>$M_XH_X = 0$</span> (i.e., <span>$\partial_1 \partial_2 = 0$</span>)  where <span>$H_Z$</span> and <span>$M_Z$</span> are obtained via <a href="#QECCore.parity_matrix_x"><code>parity_matrix_x</code></a> and <a href="#QECCore.metacheck_matrix_x"><code>metacheck_matrix_x</code></a> respectively.</li></ul><p>See also: <a href="#QECCore.metacheck_matrix_z"><code>metacheck_matrix_z</code></a>, <a href="#QECCore.metacheck_matrix"><code>metacheck_matrix</code></a>, <a href="#QECCore.parity_matrix_x"><code>parity_matrix_x</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/interface.jl#L120-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.metacheck_matrix_z" href="#QECCore.metacheck_matrix_z"><code>QECCore.metacheck_matrix_z</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">metacheck_matrix_z(c::AbstractCSSCode)</code></pre><p>Returns the Z-metacheck matrix (<span>$M_Z = \partial_{i+2}^\top$</span>) for a CSS code defined by a chain complex of length <code>l ≥ 4</code>, where qubits are placed on <code>i</code>-cells (<code>1 &lt; i &lt; l−1</code>).</p><p>This matrix acts on Z-syndromes (measurement outcomes from Z-type stabilizers that detect X-errors, obtained via <a href="#QECCore.parity_matrix_z"><code>parity_matrix_z</code></a> and enforces the constraint <span>$M_Z s_Z = 0$</span>, ensuring syndromes <span>$s_Z$</span> are valid codewords of a classical <em>metacode</em>.</p><div class="admonition is-info" id="Note-fe3a7f5465475fc8"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-fe3a7f5465475fc8" title="Permalink"></a></header><div class="admonition-body"><p>For an introduction to chain complexes in quantum error correction and the role of metachecks in single-shot QEC, see the documentation for <a href="#QECCore.metacheck_matrix"><code>metacheck_matrix</code></a>.</p></div></div><p><strong>Example: 4D Surface Code</strong></p><p>In the <code>5</code>-term chain complex used for the <code>4D</code> surface code:</p><p class="math-container">\[\begin{aligned}
C_4 \xrightarrow{\partial_4} C_3 \xrightarrow{\partial_3} C_2 \xrightarrow{\partial_2} C_1 \xrightarrow{\partial_1} C_0
\end{aligned}\]</p><p>the metacheck matrix <span>$M_Z = \partial_4$</span> obtained via <a href="#QECCore.metacheck_matrix_z"><code>metacheck_matrix_z</code></a> satisfies the following:</p><ul><li>Acts on Z-syndromes: <span>$s_Z \in C_3$</span>,</li><li>It enforces <span>$M_Zs_Z = 0$</span>, i.e. only valid syndromes lie in <span>$\ker M_Z$</span>.</li><li>It satisfies the boundary condition <span>$H_Z^\topM_Z^\top = 0$</span> (i.e., <span>$\partial_3 \partial_4 = 0$</span>) where <span>$H_Z$</span> and <span>$M_Z$</span> are obtained via <a href="#QECCore.parity_matrix_z"><code>parity_matrix_z</code></a> and <a href="#QECCore.metacheck_matrix_z"><code>metacheck_matrix_z</code></a> respectively.</li></ul><p>See also: <a href="#QECCore.metacheck_matrix_x"><code>metacheck_matrix_x</code></a>, <a href="#QECCore.metacheck_matrix"><code>metacheck_matrix</code></a>, <a href="#QECCore.parity_matrix_z"><code>parity_matrix_z</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/interface.jl#L156-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.parity_matrix" href="#QECCore.parity_matrix"><code>QECCore.parity_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parity_matrix(c::AbstractECC)</code></pre><p>The parity check matrix of a error correction code in the form of <code>(X|Z)</code>. The size of the matrix is <code>(code_s, 2*code_n)</code>. <code>code_s</code> is the number of stabilizers, and <code>code_n</code> is the number of physical qubits. Each row of the matrix is a stabilizer. The first <code>code_n</code> columns represent whether this stabilizer contains a X operator on the physical qubit, and the last <code>code_n</code> columns represent whether this stabilizer contains a Z operator on the physical qubit.</p><p>See also: <a href="#QECCore.parity_matrix_x"><code>parity_matrix_x</code></a> and <a href="#QECCore.parity_matrix_z"><code>parity_matrix_z</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/interface.jl#L22-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.parity_matrix_x" href="#QECCore.parity_matrix_x"><code>QECCore.parity_matrix_x</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parity_matrix_x(c::AbstractCSSCode)</code></pre><p>Parity check boolean matrix of a code (only the X entries in the tableau, i.e. the checks for Z errors). Only CSS codes have this method.</p><p>See also: <a href="#QECCore.parity_matrix"><code>parity_matrix</code></a> and <a href="#QECCore.parity_matrix_z"><code>parity_matrix_z</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/interface.jl#L38-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.parity_matrix_z" href="#QECCore.parity_matrix_z"><code>QECCore.parity_matrix_z</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parity_matrix_z(c::AbstractCSSCode)</code></pre><p>Parity check boolean matrix of a code (only the Z entries in the tableau, i.e. the checks for X errors). Only CSS codes have this method.</p><p>See also: <a href="#QECCore.parity_matrix"><code>parity_matrix</code></a> and <a href="#QECCore.parity_matrix_x"><code>parity_matrix_x</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/interface.jl#L48-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.random_TillichZemor_code-Tuple{Random.AbstractRNG, Int64, Int64, Int64}" href="#QECCore.random_TillichZemor_code-Tuple{Random.AbstractRNG, Int64, Int64, Int64}"><code>QECCore.random_TillichZemor_code</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The <strong>random Tillich Zémor code</strong> is a quantum LDPC code constructed using the hypergraph product of two randomized classical <strong>(n, m, r)-Structured LDPC</strong> seed codes.</p><p>The parity-check matrix <span>$H = [C \mid M]$</span> is generated by combining a deterministic circulant core <span>$C$</span> of size <span>$m \times m$</span> with column weight <span>$2$</span> and a randomized matrix <span>$M$</span> of size <span>$m \times (n-m)$</span>. Each column of <span>$M$</span> contains exactly <span>$r \geq 3$</span> nonzero entries, which are placed uniformly at random while ensuring that no row of M is entirely zero. This construction ensures a structured yet partially randomized design for the seed parity-check matrix <span>$H = [C \mid M]$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/tillichzemor.jl#L212-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.rate-Tuple{Any}" href="#QECCore.rate-Tuple{Any}"><code>QECCore.rate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rate(c::AbstractECC)</code></pre><p>The rate of a error correction code.</p><p>See also: <a href="#QECCore.code_n-Tuple{AbstractQECC}"><code>code_n</code></a> and <a href="#QECCore.code_k"><code>code_k</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/interface.jl#L91-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.search_self_orthogonal_rm_codes-Tuple{Int64}" href="#QECCore.search_self_orthogonal_rm_codes-Tuple{Int64}"><code>QECCore.search_self_orthogonal_rm_codes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Search for parameters <code>(r,m)</code> of <em>self-orthogonal</em> <code>Reed-Muller</code> codes where the code <code>RM(r,m)</code> satisfies <span>$H \times H^\top \equiv 0 \pmod{2}$</span>. Skips the trivial case <code>RM(0,1)</code> which produces a code with <code>k=0</code> logical qubits.</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford; using QuantumClifford.ECC; using QECCore: search_self_orthogonal_rm_codes; # hide

julia&gt; search_self_orthogonal_rm_codes(6)
12-element Vector{Tuple{Int64, Int64}}:
 (1, 2)
 (1, 3)
 (2, 3)
 (2, 4)
 (3, 4)
 (2, 5)
 (3, 5)
 (4, 5)
 (3, 6)
 (4, 6)
 (5, 6)</code></pre><p>Here is an example using a <em>self-orthogonal</em> classical <code>RM(3,5)</code> seed code to demonstrate the generalization of the <code>Delfosse-Reichardt</code> construction.</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford; using QuantumClifford.ECC; # hide

julia&gt; p = 2; r = 3; m = 5;

julia&gt; c = parity_checks(DelfosseReichardt(p, r, m))
+ XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX________________________________
+ ________________________________XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
+ XXXXXXXXXXXXXXXX________________XXXXXXXXXXXXXXXX________________
+ XXXXXXXX________XXXXXXXX________XXXXXXXX________XXXXXXXX________
+ XXXX____XXXX____XXXX____XXXX____XXXX____XXXX____XXXX____XXXX____
+ XX__XX__XX__XX__XX__XX__XX__XX__XX__XX__XX__XX__XX__XX__XX__XX__
+ X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_
+ ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ________________________________
+ ________________________________ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
+ ZZZZZZZZZZZZZZZZ________________ZZZZZZZZZZZZZZZZ________________
+ ZZZZZZZZ________ZZZZZZZZ________ZZZZZZZZ________ZZZZZZZZ________
+ ZZZZ____ZZZZ____ZZZZ____ZZZZ____ZZZZ____ZZZZ____ZZZZ____ZZZZ____
+ ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__
+ Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_

julia&gt; code_n(c), code_k(c)
(64, 50)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/lib/QECCore/src/codes/quantum/delfosse_reichardt_code.jl#L102-L153">source</a></section></article><h2 id="Implemented-in-an-extension-requiring-Hecke.jl"><a class="docs-heading-anchor" href="#Implemented-in-an-extension-requiring-Hecke.jl">Implemented in an extension requiring <code>Hecke.jl</code></a><a id="Implemented-in-an-extension-requiring-Hecke.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Implemented-in-an-extension-requiring-Hecke.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordHeckeExt.ExtendedGeneralizedBicycleCode" href="#QuantumCliffordHeckeExt.ExtendedGeneralizedBicycleCode"><code>QuantumCliffordHeckeExt.ExtendedGeneralizedBicycleCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ExtendedGeneralizedBicycleCode &lt;: AbstractCSSCode</code></pre><p>The extended generalized bicycle code is a family of quantum LDPC codes generated through <em>algebraic extension</em> of a base <a href="#QuantumCliffordHeckeExt.GeneralizedBicycleCode"><code>GeneralizedBicycleCode</code></a>. Starting with initial generating polynomials <span>$a(x), b(x) \in \mathbb{F}_2^{\langle\ell\rangle}$</span>, the extended GB codes are constructed by polynomial multiplication, where for each extension step <span>$m$</span>, an extension polynomial </p><p class="math-container">\[\begin{aligned}
p^{(m)}(x) \in \mathbb{F}_2^{\langle\kappa_m\ell\rangle}
\end{aligned}\]</p><p>is selected to produce extended polynomials:</p><p class="math-container">\[\begin{aligned}
a^{(m)}(x) &amp;= p^{(m)}(x)a(x), \\
b^{(m)}(x) &amp;= p^{(m)}(x)b(x)
\end{aligned}\]</p><p>These extended polynomials are then used to form <span>$\kappa_m\ell \times \kappa_m\ell$</span> circulant matrices <span>$A_m$</span> and <span>$B_m$</span>, which are combined into a parity-check matrix <span>$H_m$</span> with block structure:</p><p class="math-container">\[\begin{aligned}
H_m = \begin{pmatrix} 
A_m \mid B_m &amp; 0 \\
0 &amp; B_m^\top \mid A_m^\top 
\end{pmatrix} 
\end{aligned}\]</p><p>while maintaining logical dimension:</p><p class="math-container">\[\begin{aligned}
k_m = 2\deg\left(\gcd\left(a^{(m)}, b^{(m)}, x^{\kappa_m\ell}-1\right)\right)
\end{aligned}\]</p><p>that are always bounded below by the base code dimension <code>k</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: polynomial_ring, GF, one, gen; using QuantumClifford.ECC;

julia&gt; R, x = polynomial_ring(GF(2), &quot;x&quot;);

julia&gt; l = 5;

julia&gt; a = 1 + x^4;

julia&gt; b = 1 + x + x^2 + x^4;

julia&gt; c = GeneralizedBicycleCode(a, b, l);

julia&gt; import HiGHS;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(10, 2, 3)

julia&gt; m, p = 4, one(R);

julia&gt; new_code = ExtendedGeneralizedBicycleCode(c, m, p);

julia&gt; code_n(new_code), code_k(new_code), distance(new_code, DistanceMIPAlgorithm(solver=HiGHS))
(40, 2, 5)

julia&gt; m, p = 4, 1 + x;

julia&gt; new_code = ExtendedGeneralizedBicycleCode(c, m, p);

julia&gt; code_n(new_code), code_k(new_code), distance(new_code, DistanceMIPAlgorithm(solver=HiGHS))
(40, 4, 5)</code></pre><div class="admonition is-info" id="Note-8ff62b182e95757d"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-8ff62b182e95757d" title="Permalink"></a></header><div class="admonition-body"><p>(<a href="../references/#koukoulekidis2024smallquantumcodesalgebraic">Koukoulekidis <em>et al.</em>, 2024</a>) establishes that <code>ℓ = 5</code> is the minimal lift size required to achieve quantum error-correcting codes with a minimum distance of <code>d ≥ 3</code>.</p></div></div><p><strong>Fields</strong></p><ul><li><p><code>base_code::AbstractCSSCode</code>: The base generalized bicycle code to extend.</p></li><li><p><code>m::Int64</code>: The extension index (m ≥ 1)</p></li><li><p><code>p::Nemo.FqPolyRingElem</code>: The extension polynomial ∈ 𝔽₂[((m-1)ℓ +1)].</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordHeckeExt/extended_generalized_bicycle.jl#L1-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordHeckeExt.GeneralizedBicycleCode" href="#QuantumCliffordHeckeExt.GeneralizedBicycleCode"><code>QuantumCliffordHeckeExt.GeneralizedBicycleCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GeneralizedBicycleCode &lt;: AbstractCSSCode</code></pre><p>Generalized bicycle codes ((<a href="../references/#koukoulekidis2024smallquantumcodesalgebraic">Koukoulekidis <em>et al.</em>, 2024</a>))</p><p>A generalized bicycle quantum LDPC code constructed from two polynomials in <span>$\mathbb{F}_2[x]/(x^l - 1)$</span>.</p><p>Here is an example of a [[10, 2, 3]] GB code from the Appendix B of (<a href="../references/#koukoulekidis2024smallquantumcodesalgebraic">Koukoulekidis <em>et al.</em>, 2024</a>) with lift size of 5 build out of two polymonials in <span>$\mathbb{F}_2[x]/(x^l - 1)$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: polynomial_ring, GF; using QuantumClifford.ECC;

julia&gt; R, x = polynomial_ring(GF(2), &quot;x&quot;);

julia&gt; l = 5;

julia&gt; a = 1 + x^4;

julia&gt; b = 1 + x + x^2 + x^4;

julia&gt; c = GeneralizedBicycleCode(a, b, l);

julia&gt; import HiGHS;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(10, 2, 3)</code></pre><p>Here is an example of a [[12, 2, 3]] GB code from the Appendix B of (<a href="../references/#koukoulekidis2024smallquantumcodesalgebraic">Koukoulekidis <em>et al.</em>, 2024</a>) with lift size of 6 build out of two polymonials in <span>$\mathbb{F}_2[x]/(x^l - 1)$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: polynomial_ring, GF; using QuantumClifford.ECC;

julia&gt; R, x = polynomial_ring(GF(2), &quot;x&quot;);

julia&gt; l = 6;

julia&gt; a = 1 + x + x^2 + x^5;

julia&gt; b = 1 + x + x^3 + x^5;

julia&gt; c = GeneralizedBicycleCode(a, b, l);

julia&gt; import HiGHS;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(12, 2, 3)</code></pre><p>See also: <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a></p><p><strong>Fields</strong></p><ul><li><p><code>a::Nemo.FqPolyRingElem</code>: First generator polynomial in 𝔽₂[x]/(xˡ - 1).</p></li><li><p><code>b::Nemo.FqPolyRingElem</code>: Second generator polynomial in 𝔽₂[x]/(xˡ - 1).</p></li><li><p><code>l::Int64</code>: The lift size which corresponds to dimension of circulant matrices.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordHeckeExt/generalized_bicycle.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordHeckeExt.GeneralizedHyperGraphProductCode" href="#QuantumCliffordHeckeExt.GeneralizedHyperGraphProductCode"><code>QuantumCliffordHeckeExt.GeneralizedHyperGraphProductCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GeneralizedHyperGraphProductCode &lt;: AbstractCSSCode</code></pre><p>A Generalized Hypergraph Product (GHP) CSS code introduced in (<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>).</p><p>The GHP code is constructed from a matrix <span>$A \in M_{m \times n}(R)$</span>, where <span>$R \subseteq M_\ell(\mathbb{F}_2)$</span> is a ring of binary circulant matrices, and a binary matrix <span>$b \in M_\ell(\mathbb{F}_2)$</span> such that every element of <span>$R$</span> commutes with <span>$b$</span>. The code is defined by the block parity-check matrices:</p><p class="math-container">\[\begin{aligned}
    H_X = \begin{bmatrix} A &amp; b \cdot I_m \end{bmatrix}, \quad
    H_Z = \begin{bmatrix} b^T \cdot I_n &amp; A^* \end{bmatrix}
\end{aligned}\]</p><p>where <span>$A^*$</span> is the transpose of <span>$A$</span> with each entry polynomial-reversed modulo <span>$x^\ell - 1$</span>, and <span>$I_m, I_n$</span> are identity matrices over <span>$R$</span>.</p><p>Here is an example of <code>[[882, 24, 18 ≤ d ≤ 24]]</code> code from Appendix B of (<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: polynomial_ring, GF, quo, matrix; using QuantumClifford.ECC;

julia&gt; R, x = polynomial_ring(GF(2), :x);

julia&gt; l = 63; n = 7;

julia&gt; S, _ =  quo(R, x^l - 1);

julia&gt; A = matrix(S, n, n,
           [x^27  0     0     0     0     1     x^54
            x^54  x^27  0     0     0     0     1
            1     x^54  x^27  0     0     0     0
            0     1     x^54  x^27  0     0     0
            0     0     1     x^54  x^27  0     0
            0     0     0     1     x^54  x^27  0
            0     0     0     0     1     x^54  x^27]);

julia&gt; b = S(1 + x + x^6);

julia&gt; c = GeneralizedHyperGraphProductCode(A, b, l);

julia&gt; code_n(c), code_k(c)
(882, 24)</code></pre><p>Here is an example of <code>[[1270, 28, 16 ≤ d ≤ 46]]</code> code from Appendix B of (<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: polynomial_ring, GF, quo, matrix; using QuantumClifford.ECC;

julia&gt; R, x = polynomial_ring(GF(2), :x);

julia&gt; l = 127; n = 5;

julia&gt; S, _ =  quo(R, x^l - 1);

julia&gt; A = matrix(S, n, n,
           [1     0     x^51  x^52  0
            0     1     0     x^111 x^20
            1     0     x^98  0     x^122
            1     x^80  0     x^119 0 
            0     1     x^5   0     x^106]);

julia&gt; b = S(1 + x + x^7);

julia&gt; c = GeneralizedHyperGraphProductCode(A, b, l);

julia&gt; code_n(c), code_k(c)
(1270, 28)</code></pre><p><strong>Fields</strong></p><ul><li><p><code>A::AbstractAlgebra.Generic.MatSpaceElem{AbstractAlgebra.Generic.EuclideanRingResidueRingElem{Nemo.FqPolyRingElem}}</code>: The matrix <span>$A \in M_{n \times n}(R)$</span>, where <span>$R = \mathbb{F}_2[x]/(x^\ell - 1)$</span>. Each entry in <code>A</code> represents a polynomial modulo <span>$x^\ell - 1$</span>, defining a circulant block.</p></li><li><p><code>b::AbstractAlgebra.Generic.EuclideanRingResidueRingElem{Nemo.FqPolyRingElem}</code>: The polynomial <span>$b(x) \in R$</span>, generating a binary circulant matrix that commutes with all elements of <code>R</code>.</p></li><li><p><code>l::Int64</code>: The number of rows and columns in each binary circulant block.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordHeckeExt/generalized_hypergraph_product.jl#L1-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordHeckeExt.LPCode" href="#QuantumCliffordHeckeExt.LPCode"><code>QuantumCliffordHeckeExt.LPCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LPCode &lt;: AbstractCSSCode</code></pre><p>Lifted product codes ((<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>), (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>))</p><p>A lifted product code is defined by the hypergraph product of a base matrices <code>A</code> and the conjugate of another base matrix <code>B&#39;</code>. Here, the hypergraph product is taken over a group algebra, of which the base matrices are consisting.</p><p>The binary parity check matrices are obtained by applying <code>A_repr</code> and <code>B_repr</code> representation maps to each element of the base matrices. These linear transformations convert group algebra elements to their matrix representations while preserving the CSS orthogonality condition.</p><p><strong>Mathematical Framework</strong></p><p>Given classical parity-check matrices:</p><ul><li><p><span>$A \in \mathbb{F}_q^{m_a \times n_a}$</span></p></li><li><p><span>$B \in \mathbb{F}_q^{m_b \times n_b}$</span></p></li></ul><p>The lifted product construction produces quantum CSS codes with parity-check matrices:</p><p class="math-container">\[\begin{aligned}
    H_X &amp;= [A \otimes I_{m_b}, -I_{m_a} \otimes B] \\
    H_Z &amp;= [I_{n_a} \otimes B^*, A^* \otimes I_{n_b}]
\end{aligned}\]</p><p><strong>Commutative Group Algebra</strong></p><p>When <code>R</code> is <em>commutative</em>, a single representation suffices since all elements naturally commute. Here <span>$\rho(a) = \lambda(a)$</span> for all <span>$a \in R$</span>.</p><p><strong>Non-Commutative Group Algebra</strong></p><p>When <code>R</code> is <em>non-commutative</em>, distinct representations are essential:</p><ul><li><p><code>A_repr</code> implements the right regular representation: <span>$\rho(a)x = xa$</span></p></li><li><p><code>B_repr</code> implements the left regular representation: <span>$\lambda(b)x = bx$</span></p></li></ul><p>These ensure the critical commutation relation:</p><p class="math-container">\[\begin{aligned}
    \rho(a)\lambda(b) = \lambda(b)\rho(a)
\end{aligned}\]</p><p>which follows from the <em>associative</em> property:</p><p class="math-container">\[\begin{aligned}
    \rho(a)\lambda(b)(x) = b(xa) = (bx)a = \lambda(b)\rho(a)(x)
\end{aligned}\]</p><p><strong>Constructors</strong></p><p>Multiple constructors are available:</p><ol><li><p>Two base matrices of group algebra elements.</p></li><li><p>Two lifted codes, whose base matrices are for quantum code construction.</p></li><li><p>Two base matrices of group elements, where each group element will be considered as a group algebra element by assigning a unit coefficient.</p></li><li><p>Two base matrices of integers, where each integer represent the shift of a cyclic permutation. The order of the cyclic permutation should be specified.</p></li></ol><p>Below is a list of all constructors:</p><pre><code class="language-julia hljs">LPCode(A, B; GA, A_repr, B_repr, repr)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/38ca4c1a518bc41543b7a7632f8852225e12edd7//ext/QuantumCliffordHeckeExt/lifted_product.jl#L158"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted_product.jl:158</code></a>.</p><pre><code class="language-julia hljs">LPCode(c₁, c₂; GA, A_repr, B_repr, repr)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/38ca4c1a518bc41543b7a7632f8852225e12edd7//ext/QuantumCliffordHeckeExt/lifted_product.jl#L175"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted_product.jl:175</code></a>.</p><pre><code class="language-julia hljs">LPCode(A, B; GA)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/38ca4c1a518bc41543b7a7632f8852225e12edd7//ext/QuantumCliffordHeckeExt/lifted_product.jl#L195"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted_product.jl:195</code></a>.</p><pre><code class="language-julia hljs">LPCode(group_elem_array1, group_elem_array2; GA)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/38ca4c1a518bc41543b7a7632f8852225e12edd7//ext/QuantumCliffordHeckeExt/lifted_product.jl#L203"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted_product.jl:203</code></a>.</p><pre><code class="language-julia hljs">LPCode(shift_array1, shift_array2, l; GA)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/38ca4c1a518bc41543b7a7632f8852225e12edd7//ext/QuantumCliffordHeckeExt/lifted_product.jl#L211"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted_product.jl:211</code></a>.</p><p><strong>Examples</strong></p><p>A [[882, 24, d ≤ 24]] code from Appendix B of (<a href="../references/#roffe2023bias">Roffe <em>et al.</em>, 2023</a>). We use the 1st constructor to generate the code and check its length and dimension. During the construction, we do arithmetic operations to get the group algebra elements in base matrices <code>A</code> and <code>B</code>. Here <code>x</code> is the generator of the group algebra, i.e., offset-1 cyclic permutation, and <code>GA(1)</code> is the unit element.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; import LinearAlgebra: diagind; using QuantumClifford.ECC;

julia&gt; l = 63; GA = group_algebra(GF(2), abelian_group(l)); x = gens(GA)[];

julia&gt; A = zeros(GA, 7, 7);

julia&gt; A[diagind(A)] .= x^27;

julia&gt; A[diagind(A, -1)] .= x^54;

julia&gt; A[diagind(A, 6)] .= x^54;

julia&gt; A[diagind(A, -2)] .= GA(1);

julia&gt; A[diagind(A, 5)] .= GA(1);

julia&gt; B = reshape([1 + x + x^6], (1, 1));

julia&gt; c1 = LPCode(A, B);

julia&gt; code_n(c1), code_k(c1)
(882, 24)</code></pre><p>A [[175, 19, d ≤ 10]] code from Eq. (18) in Appendix A of (<a href="../references/#raveendran2022finite">Raveendran <em>et al.</em>, 2022</a>), following the 4th constructor.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke; using QuantumClifford.ECC;

julia&gt; base_matrix = [0 0 0 0; 0 1 2 5; 0 6 3 1]; l = 7;

julia&gt; c2 = LPCode(base_matrix, l .- base_matrix&#39;, l);

julia&gt; code_n(c2), code_k(c2)
(175, 19)</code></pre><p><strong>Code subfamilies and convenience constructors for them</strong></p><ul><li>When the base matrices of the <code>LPCode</code> are 1×1, the code is called a two-block group-algebra code <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>.</li><li>When the base matrices of the <code>LPCode</code> are 1×1 and their elements are sums of cyclic permutations, the code is called a generalized bicycle code <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>.</li><li>When the two matrices are adjoint to each other, the code is called a bicycle code <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>.</li></ul><p><strong>The representation function</strong></p><p>We use the default representation function <code>Hecke.representation_matrix</code> to convert a <code>GF(2)</code>-group algebra element to a binary matrix. The default representation, provided by <code>Hecke</code>, is the permutation representation.</p><p>We also accept a custom representation function as detailed in <a href="#QuantumCliffordHeckeExt.LiftedCode"><code>LiftedCode</code></a>.</p><p>See also: <a href="#QuantumCliffordHeckeExt.LiftedCode"><code>LiftedCode</code></a>, <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.haah_cubic_codes"><code>haah_cubic_codes</code></a>.</p><p>All fields:</p><ul><li><p><code>A::Union{LinearAlgebra.Adjoint{&lt;:Hecke.GroupAlgebraElem, &lt;:Matrix{&lt;:Hecke.GroupAlgebraElem}}, Matrix{&lt;:Hecke.GroupAlgebraElem}}</code>: the first base matrix of the code, whose elements are in a group algebra.</p></li><li><p><code>B::Union{LinearAlgebra.Adjoint{&lt;:Hecke.GroupAlgebraElem, &lt;:Matrix{&lt;:Hecke.GroupAlgebraElem}}, Matrix{&lt;:Hecke.GroupAlgebraElem}}</code>: the second base matrix of the code, whose elements are in the same group algebra as <code>A</code>.</p></li><li><p><code>GA::Hecke.GroupAlgebra</code>: the group algebra for which elements in <code>A</code> and <code>B</code> are from.</p></li><li><p><code>A_repr::Function</code>: a function that converts a group algebra element to a binary matrix for <code>A</code>; default to be the right regular representation for <code>GF(2)</code>-algebra.</p></li><li><p><code>B_repr::Function</code>: a function that converts a group algebra element to a binary matrix for B; default to be the left regular representation for <code>GF(2)</code>-algebra.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordHeckeExt/lifted_product.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordHeckeExt.LaCross" href="#QuantumCliffordHeckeExt.LaCross"><code>QuantumCliffordHeckeExt.LaCross</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LaCross &lt;: AbstractCSSCode</code></pre><p>The <strong>La-cross</strong> code is a quantum LDPC code constructed using the hypergraph product of two classical seed LDPC codes. It is characterized by its parity check matrix <code>H</code>, which is derived from <strong>circulant</strong> matrices with <em>specific</em> properties. These codes were introduced in (<a href="../references/#pecorari2025high">Pecorari <em>et al.</em>, 2025</a>).</p><p>The La-cross code has two families, distinguished by their boundary conditions:</p><ul><li><strong>Periodic</strong> boundary (<code>full_rank = false</code>):</li></ul><p class="math-container">\[\begin{aligned}
\left[\left[2n^2, 2k^2, d \right]\right]
\end{aligned}\]</p><ul><li><strong>Open</strong> boundary (<code>full_rank = true</code>): </li></ul><p class="math-container">\[\begin{aligned}
\left[\left[(n - k)^2 + n^2, k^2, d \right]\right]
\end{aligned}\]</p><div class="admonition is-info" id="Note-53d8e7ea10d62145"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-53d8e7ea10d62145" title="Permalink"></a></header><div class="admonition-body"><p>When <code>H</code> is square and circulant (<code>full_rank=false</code>), classical checks connect opposite endpoints of the <code>length-n</code> classical code and give rise to a quantum code with stabilizers connecting opposite array boundaries, i.e. with <strong>periodic boundary conditions</strong>. On the contrary, <strong>rectangular</strong> parity-check matrices in <span>$\mathbb{F}_2^{(n−k)×n}$</span> give rise to a quantum code with stabilizers stretching up to the array extent, i.e. with <strong>open boundary conditions</strong>.</p></div></div><p><strong>Cyclic Codes and Circulant Matrices</strong></p><p>A <strong>cyclic code</strong> is a linear code in which codewords remain valid under cyclic shifts. A <strong>circulant matrix</strong> is a square matrix where each row is a cyclic shift of the first row. When the parity-check matrix <code>H</code> is circulant, the code is fully determined by its first row:</p><p class="math-container">\[\begin{aligned}
H = \text{circ}(c_0, c_1, \dots, c_k, 0, \dots, 0) \in \mathbb{F}_2^{n \times n}.
\end{aligned}\]</p><p>The elements <span>$c_i$</span> (for <span>$i = 0, 1, \dots, k$</span>) correspond to the coefficients of a <span>$degree-k$</span> polynomial:</p><p class="math-container">\[\begin{aligned}
h(x) = 1 + \sum_{i=1}^{k} c_i x^i \in \mathbb{F}_2[x]/(x^n - 1).
\end{aligned}\]</p><p>This establishes a mapping between <span>$\mathbb{F}_2^n$</span> and the quotient ring <span>$\mathbb{F}_2[x]/(x^n - 1)$</span>, where cyclic shifts in <span>$\mathbb{F}_2^n$</span> correspond to multiplications by <code>x</code> in the polynomial ring. Since multiplication by <code>x</code> preserves the ideal structure of <span>$\mathbb{F}_2[x]/(x^n - 1)$</span>, cyclic codes correspond to ideals in this ring. These ideals are in one-to-one correspondence with unitary <span>$mod-2$</span> divisors of <span>$x^n - 1$</span> with a leading coefficient of 1. Consequently, the fundamental building blocks of cyclic codes correspond to the factorization of <span>$x^n - 1$</span>.</p><div class="admonition is-info" id="Note-8129c2ecc6b7952c"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-8129c2ecc6b7952c" title="Permalink"></a></header><div class="admonition-body"><p>For <code>k = 1</code>, the generator polynomial <span>$h(x) = 1 + x$</span> defines the <strong>repetition code</strong>.</p></div></div><p><strong>Polynomial Representation</strong></p><p>The first row of a circulant matrix <span>$H = \text{circ}(c_0, c_1, c_2, \dots, c_{n-1})$</span> can be mapped to the coefficients of a polynomial <span>$h(x)$</span>. For instance, if the first row is <span>$[1, 1, 0, 1]$</span>, the polynomial is: <span>$h(x) = 1 + x + x^3$</span>. This polynomial-based representation aids in the analysis and design of cyclic codes. For our implementation of La-cross codes, we leverage <code>Hecke.polynomial_ring</code> to work directly with polynomial rings rather than manipulating coefficient arrays explicitly.</p><div class="admonition is-info" id="Note-de2b566ba6c895d"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-de2b566ba6c895d" title="Permalink"></a></header><div class="admonition-body"><p>The <strong>next-to-next-to-nearest neighbor</strong> connectivity implies the use of a <em>degree-3</em> seed polynomial <span>$h(x) = 1 + x + x^2 + x^3$</span> in the ring <span>$\mathbb{F}_2[x]/(x^n - 1)$</span> for a specific code length <code>n</code>. Additionally, the condition of low stabilizer weight requires the polynomial <span>$1 + x + x^3$</span>.</p></div></div><p><strong>[[2n², 2k², d]] La-cross Code</strong></p><p>Here is <code>[[98, 18, 4]]</code> La-cross code from with <span>$h(x) = 1 + x + x^3$</span>, <code>n = 7</code>, and <code>k = 3</code> from Appendix A of (<a href="../references/#pecorari2025high">Pecorari <em>et al.</em>, 2025</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford; using QuantumClifford.ECC; # hide

julia&gt; import Hecke: GF, polynomial_ring;

julia&gt; n = 7; k = 3; F = GF(2);

julia&gt; R, x = polynomial_ring(F, &quot;x&quot;);

julia&gt; h = 1 + x + x^k;

julia&gt; c = LaCross(n, h, false);

julia&gt; import HiGHS;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(98, 18, 4)</code></pre><p><strong>[[(n - k)² + n², k², d]] La-cross Code</strong></p><p>Here is <code>[[65, 9, 4]]</code> La-cross code from with <span>$h(x) = 1 + x + x^3$</span>, <code>n = 7</code>, <code>k = 3</code> and full rank seed <em>rectangular</em> circulant matrix from Appendix A of (<a href="../references/#pecorari2025high">Pecorari <em>et al.</em>, 2025</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; c = LaCross(n, h, true);

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(65, 9, 4)</code></pre><p>Here is <code>[[400, 16, 8]]</code> La-cross code from with <span>$h(x) = 1 + x + x^4$</span>, <code>n = 16</code>, <code>k = 4</code> from (<a href="../references/#pecorari2025high">Pecorari <em>et al.</em>, 2025</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; n = 16; k = 4;

julia&gt; R, x = polynomial_ring(F, &quot;x&quot;);

julia&gt; h = 1 + x + x^k;

julia&gt; full_rank = true;

julia&gt; c = LaCross(n, h, full_rank);

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(400, 16, 8)</code></pre><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/lacross">entry for this family</a>.</p><p><strong>Fields</strong></p><ul><li><p><code>n::Int64</code>: The block length of the classical seed code.</p></li><li><p><code>h::Nemo.FqPolyRingElem</code>: The seed vector is represented with a degree-<code>n</code> polynomial of the form <span>$h(x) = \sum_{i=0}^{n-1} c_i x^i$</span>.</p></li><li><p><code>full_rank::Bool</code>: A flag indicating whether to use the full-rank rectangular matrix (<code>true</code>) or the original circulant matrix (<code>false</code>).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordHeckeExt/lacross.jl#L1-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordHeckeExt.LiftedCode" href="#QuantumCliffordHeckeExt.LiftedCode"><code>QuantumCliffordHeckeExt.LiftedCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LiftedCode &lt;: AbstractCECC</code></pre><p>Classical codes lifted over a group algebra, used for lifted product code construction ((<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>), (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>))</p><p>The parity-check matrix is constructed by applying <code>repr</code> to each element of <code>A</code>, which is mathematically a linear map from a group algebra element to a binary matrix. The size of the parity check matrix will enlarged with each element of <code>A</code> being inflated into a matrix. The procedure is called a lift (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>).</p><p><strong>Constructors</strong></p><p>A lifted code can be constructed via the following approaches:</p><ol><li><p>A matrix of group algebra elements.</p></li><li><p>A matrix of group elements, where a group element will be considered as a group algebra element by assigning a unit coefficient.</p></li><li><p>A matrix of integers, where each integer represent the shift of a cyclic permutation. The order of the cyclic permutation should be specified.</p></li></ol><p>The default <code>GA</code> is the group algebra of <code>A[1, 1]</code>, the default representation <code>repr</code> is the permutation representation.</p><p>Below is a list of all constructors:</p><pre><code class="language-julia hljs">LiftedCode(A; GA, repr)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/38ca4c1a518bc41543b7a7632f8852225e12edd7//ext/QuantumCliffordHeckeExt/lifted.jl#L58"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted.jl:58</code></a>.</p><pre><code class="language-julia hljs">LiftedCode(A; GA)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/38ca4c1a518bc41543b7a7632f8852225e12edd7//ext/QuantumCliffordHeckeExt/lifted.jl#L68"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted.jl:68</code></a>.</p><pre><code class="language-julia hljs">LiftedCode(group_elem_array; GA, repr)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/38ca4c1a518bc41543b7a7632f8852225e12edd7//ext/QuantumCliffordHeckeExt/lifted.jl#L74"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted.jl:74</code></a>.</p><pre><code class="language-julia hljs">LiftedCode(shift_array, l; GA, repr)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/38ca4c1a518bc41543b7a7632f8852225e12edd7//ext/QuantumCliffordHeckeExt/lifted.jl#L87"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted.jl:87</code></a>.</p><p><strong>The representation function <code>repr</code></strong></p><p>We use the default representation function <code>Hecke.representation_matrix</code> to convert a <code>GF(2)</code>-group algebra element to a binary matrix. The default representation, provided by <code>Hecke</code>, is the permutation representation.</p><p>We also accept a custom representation function (the <code>repr</code> field of the constructor). Whatever the representation, the matrix elements need to be convertible to Integers (e.g. permit <code>lift(ZZ, ...)</code>). Such a customization would be useful to reduce the number of bits required by the code construction.</p><p>For example, if we use a D4 group for lifting, our default representation will be <code>8×8</code> permutation matrices, where 8 is the group&#39;s order. However, we can find a <code>4×4</code> matrix representation for the group, e.g. by using the typical <a href="https://en.wikipedia.org/wiki/Dihedral_group"><code>2×2</code> representation</a> and converting it into binary representation by replacing &quot;1&quot; with the Pauli I, and &quot;-1&quot; with the Pauli X matrix.</p><p>See also: <a href="#QuantumClifford.ECC.LPCode-Tuple"><code>QuantumClifford.ECC.LPCode</code></a>.</p><p>All fields:</p><ul><li><p><code>A::Union{LinearAlgebra.Adjoint{&lt;:Hecke.GroupAlgebraElem, &lt;:Matrix{&lt;:Hecke.GroupAlgebraElem}}, Matrix{&lt;:Hecke.GroupAlgebraElem}}</code>: the base matrix of the code, whose elements are in a group algebra.</p></li><li><p><code>GA::Hecke.GroupAlgebra</code>: the group algebra for which elements in <code>A</code> are from.</p></li><li><p><code>repr::Function</code>: a function that converts a group algebra element to a binary matrix; default to be the permutation representation for GF(2)-algebra.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordHeckeExt/lifted.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.bicycle_codes-Tuple{Array{Int64}, Int64}" href="#QuantumClifford.ECC.bicycle_codes-Tuple{Array{Int64}, Int64}"><code>QuantumClifford.ECC.bicycle_codes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bicycle_codes(a_shifts::Array{Int64}, l::Int64) -&gt; Any
</code></pre><p>Bicycle codes are a special case of generalized bicycle codes, where <code>a</code> and <code>b</code> are conjugate to each other. The order of the cyclic group is <code>l</code>, and the shifts <code>a_shifts</code> and <code>b_shifts</code> are reverse to each other. Thus you need to provide only the <code>a_shifts</code> and the rest of the conversions and conjugations are taken care of.</p><p>See also: <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.haah_cubic_codes"><code>haah_cubic_codes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordHeckeExt/lifted_product.jl#L446">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.generalized_bicycle_codes-Tuple{Array{Int64}, Array{Int64}, Int64}" href="#QuantumClifford.ECC.generalized_bicycle_codes-Tuple{Array{Int64}, Array{Int64}, Int64}"><code>QuantumClifford.ECC.generalized_bicycle_codes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generalized_bicycle_codes(
    a_shifts::Array{Int64},
    b_shifts::Array{Int64},
    l::Int64
) -&gt; Any
</code></pre><p>Generalized bicycle codes, which are a special case of <em>abelian</em> 2GBA codes (and therefore of lifted product codes). Here the group is chosen as the cyclic group of order <code>l</code>, and the base matrices <code>a</code> and <code>b</code> are the sum of the group algebra elements corresponding to the shifts <code>a_shifts</code> and <code>b_shifts</code>.</p><p>Behind the scenes, the shifts are converted to the corresponding group algebra elements and piped to <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>.</p><p>See also: <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>.</p><p><strong>Examples</strong></p><p>A [[254, 28, 14 ≤ d ≤ 20]] code from (A1) in Appendix B of (<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke; using QuantumClifford.ECC

julia&gt; c = generalized_bicycle_codes([0, 15, 20, 28, 66], [0, 58, 59, 100, 121], 127);

julia&gt; code_n(c), code_k(c)
(254, 28)</code></pre><p>An [[70, 8, 10]] <em>abelian</em> 2BGA code from Table 1 of (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>), with cyclic group of order <code>l = 35</code>, illustrates that <em>abelian</em> 2BGA codes can be viewed as GB codes.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke; using QuantumClifford.ECC

julia&gt; l = 35;

julia&gt; c1 = generalized_bicycle_codes([0, 15, 16, 18], [0, 1, 24, 27], l);

julia&gt; code_n(c1), code_k(c1)
(70, 8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordHeckeExt/lifted_product.jl#L401">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.haah_cubic_codes-Tuple{Array{Int64}, Array{Int64}, Int64}" href="#QuantumClifford.ECC.haah_cubic_codes-Tuple{Array{Int64}, Array{Int64}, Int64}"><code>QuantumClifford.ECC.haah_cubic_codes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">haah_cubic_codes(
    a_shifts::Array{Int64},
    b_shifts::Array{Int64},
    l::Int64
) -&gt; Any
</code></pre><p>Haah’s cubic codes (<a href="../references/#haah2011local">Haah, 2011</a>) can be viewed as generalized bicycle (GB) codes with the group <code>G = Cₗ × Cₗ × Cₗ</code>, where <code>l</code> denotes the lattice size. In particular, a GB code with the group <code>G = ℤ₃ˣ³</code> corresponds to a cubic code.</p><p>Behind the scenes, this function is just a simple shortcut for preparing the group <code>G</code>, before piping the arguments to <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>.</p><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/haah_cubic">entry for this family</a>.</p><p>See also: <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke; using QuantumClifford.ECC;

julia&gt; c = haah_cubic_codes([0, 15, 20, 28, 66], [0, 58, 59, 100, 121], 6);

julia&gt; code_n(c), code_k(c)
(432, 8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordHeckeExt/lifted_product.jl#L462">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.haah_cubic_codes-Tuple{Int64}" href="#QuantumClifford.ECC.haah_cubic_codes-Tuple{Int64}"><code>QuantumClifford.ECC.haah_cubic_codes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Haah’s cubic code is defined as <span>$\text{LP}(1 + x + y + z, 1 + xy + xz + yz)$</span> where <span>$\text{LP}$</span> is the lifted product code, and <code>x</code>, <code>y</code>, <code>z</code> are elements of the ring <span>$R = \mathbb{F}_2[x, y, z] / (x^L - 1, y^L - 1, z^L - 1)$</span>. Here <span>$\mathbb{F}_2$</span> is the finite field of order <code>2</code> and <code>L</code> is the lattice size. The ring <span>$R$</span> is the group algebra <span>$\mathbb{F}_qG$</span> of a finite group <code>G</code>, where <span>$G = (C_L)^3$</span> and <span>$C_L$</span> is the cyclic group of order <code>L</code>. This method of Haah&#39;s cubic code construction is outlined in Appendix B of (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>).</p><p>Here is an example of a <code>[[1024, 30, 13 ≤ d ≤ 32]]</code> Haah&#39;s cubic code from Appendix B, code D of (<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>) on the <code>8 × 8 × 8</code> Lattice.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke; using QuantumClifford.ECC;

julia&gt; l = 8;

julia&gt; c = haah_cubic_codes(l);

julia&gt; code_n(c), code_k(c)
(1024, 30)</code></pre><p>See also: <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.honeycomb_color_codes"><code>honeycomb_color_codes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordHeckeExt/lifted_product.jl#L494-L519">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.honeycomb_color_codes-Tuple{Int64, Int64}" href="#QuantumClifford.ECC.honeycomb_color_codes-Tuple{Int64, Int64}"><code>QuantumClifford.ECC.honeycomb_color_codes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The honeycomb color codes (<a href="../references/#eberhardt2024logical">Eberhardt and Steffan, 2024</a>) are exactly the Bivariate Bicycle (BB) codes defined by the polynomials <code>c = 1 + x + xy</code> and <code>d = 1 + y + xy</code>, provided that both <code>ℓ</code> and <code>m</code> are divisible by three. This <code>6.6.6</code> code is an example of BB code, as it represents a special case.</p><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/triangular_color">entry for this family</a>.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke; using QuantumClifford.ECC;

julia&gt; ℓ = 9; m = 6;

julia&gt; c = honeycomb_color_codes(ℓ, m);

julia&gt; code_n(c), code_k(c)
(108, 4)</code></pre><p>See also: <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.honeycomb_color_codes"><code>honeycomb_color_codes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordHeckeExt/lifted_product.jl#L528-L549">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.two_block_group_algebra_codes-Tuple{Hecke.GroupAlgebraElem, Hecke.GroupAlgebraElem}" href="#QuantumClifford.ECC.two_block_group_algebra_codes-Tuple{Hecke.GroupAlgebraElem, Hecke.GroupAlgebraElem}"><code>QuantumClifford.ECC.two_block_group_algebra_codes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">two_block_group_algebra_codes(
    a::Hecke.GroupAlgebraElem,
    b::Hecke.GroupAlgebraElem
) -&gt; Any
</code></pre><p>Two-block group algebra (2BGA) codes, which are a special case of lifted product codes from two group algebra elements <code>a</code> and <code>b</code>, used as <code>1×1</code> base matrices. To build them, you pick a group and specific generators for that group, then you pick two polynomials made of the group generators, and then, behind the scenes, these two polynomials <code>a</code> and <code>b</code> are piped to the lifted product code constructor as the elements of <code>1×1</code> matrices.</p><p>See also: <a href="#QuantumCliffordHeckeExt.LPCode"><code>LPCode</code></a>, <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.haah_cubic_codes"><code>haah_cubic_codes</code></a>, <a href="#QuantumClifford.ECC.honeycomb_color_codes"><code>honeycomb_color_codes</code></a>.</p><p><strong>Examples of 2BGA code subfamilies</strong></p><p><strong><code>C₄ x C₂</code></strong></p><p>Here is an example of a [[56, 28, 2]] 2BGA code from Table 2 of (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>) build out of polymonials of generators of the direct product <code>C₄ × C₂</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; using QuantumClifford.ECC;

julia&gt; GA = group_algebra(GF(2), abelian_group([14,2]));

julia&gt; x, s = gens(GA);

julia&gt; A = 1 + x^7;

julia&gt; B = 1 + x^7 + s + x^8 + s*x^7 + x;

julia&gt; c = two_block_group_algebra_codes(A,B);

julia&gt; import HiGHS;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(56, 28, 2)</code></pre><p><strong>Bivariate Bicycle codes</strong></p><p>Bivariate Bicycle codes are a class of Abelian 2BGA codes formed by the direct product of two cyclic groups <code>ℤₗ × ℤₘ</code>. The parameters <code>l</code> and <code>m</code> represent the orders of the first and second cyclic groups, respectively.</p><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/qcga">entry for this family</a>.</p><p>A [[756, 16, ≤ 34]] code from Table 3 of (<a href="../references/#bravyi2024high">Bravyi <em>et al.</em>, 2024</a>):</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; using QuantumClifford.ECC;

julia&gt; l=21; m=18;

julia&gt; GA = group_algebra(GF(2), abelian_group([l, m]));

julia&gt; x, y = gens(GA);

julia&gt; A = x^3 + y^10 + y^17;

julia&gt; B = y^5 + x^3  + x^19;

julia&gt; c = two_block_group_algebra_codes(A,B);

julia&gt; code_n(c), code_k(c)
(756, 16)</code></pre><p><strong>Multivariate Bicycle code</strong></p><p>The group algebra of the qubit multivariate bicycle (MB) code with r variables is <code>𝔽₂[𝐺ᵣ]</code>, where <code>𝐺ᵣ = ℤ/l₁ × ℤ/l₂ × ... × ℤ/lᵣ</code>.</p><p>A [[48, 4, 6]] Weight-6 TB-QLDPC code from Appendix A Table 2 of (<a href="../references/#voss2024multivariatebicyclecodes">Voss <em>et al.</em>, 2024</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; using QuantumClifford.ECC;

julia&gt; l=4; m=6;

julia&gt; GA = group_algebra(GF(2), abelian_group([l, m]));

julia&gt; x, y = gens(GA);

julia&gt; z = x*y;

julia&gt; A = x^3 + y^5;

julia&gt; B = x + z^5 + y^5 + y^2;

julia&gt; c = two_block_group_algebra_codes(A, B);

julia&gt; import HiGHS

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(48, 4, 6)</code></pre><p><strong>Coprime Bivariate Bicycle code</strong></p><p>The coprime bivariate bicycle (BB) codes are defined by two polynomials <code>𝑎(𝑥,𝑦)</code> and <code>𝑏(𝑥,𝑦)</code>, where <code>𝑙</code> and <code>𝑚</code> are coprime, and can be expressed as univariate polynomials <code>𝑎(𝜋)</code> and <code>𝑏(𝜋)</code>, with generator <code>𝜋 = 𝑥𝑦</code>. They can be viewed as a special case of Lifted Product construction based on abelian group <code>ℤₗ x ℤₘ</code> where <code>ℤⱼ</code> cyclic group of order <code>j</code>.</p><p>[[108, 12, 6]] coprime-bivariate bicycle (BB) code from Table 2 of (<a href="../references/#wang2024coprime">Wang and Mueller, 2024</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; using QuantumClifford.ECC;

julia&gt; l=2; m=27;

julia&gt; GA = group_algebra(GF(2), abelian_group([l*m]));

julia&gt; 𝜋 = gens(GA)[1];

julia&gt; A = 𝜋^2 + 𝜋^5  + 𝜋^44;

julia&gt; B = 𝜋^8 + 𝜋^14 + 𝜋^47;

julia&gt; c = two_block_group_algebra_codes(A, B);

julia&gt; import HiGHS

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(108, 12, 6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordHeckeExt/lifted_product.jl#L269">source</a></section></article><h2 id="Implemented-in-an-extension-requiring-Oscar.jl"><a class="docs-heading-anchor" href="#Implemented-in-an-extension-requiring-Oscar.jl">Implemented in an extension requiring <code>Oscar.jl</code></a><a id="Implemented-in-an-extension-requiring-Oscar.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Implemented-in-an-extension-requiring-Oscar.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordOscarExt.BivariateBicycleCode" href="#QuantumCliffordOscarExt.BivariateBicycleCode"><code>QuantumCliffordOscarExt.BivariateBicycleCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct BivariateBicycleCode &lt;: AbstractCSSCode</code></pre><p>Bivariate Bicycle codes are CSS codes constructed using the <em>quotient ring</em> <span>$R = \mathbb{F}_2[x, y] / \langle x^\ell - 1, y^m - 1 \rangle$</span>.</p><p><strong>Quotient Ring Formalism</strong></p><p>We begin with the polynomial ring <span>$\mathbb{F}_2[x, y]$</span>, which is the ring of polynomials in two variables, x and y, with coefficients in the field <span>$\mathbb{F}_2$</span>. The operations are standard polynomial addition and multiplication.</p><p>An <a href="https://en.wikipedia.org/wiki/Ideal_(ring_theory)">ideal</a> is the ring-theoretic analogue of a <a href="https://en.wikipedia.org/wiki/Normal_subgroup">normal subgroup</a> from group theory. Just as normal subgroups enable the construction of quotient groups, ideals allow us to form quotient rings.</p><p>For a subset I of a ring R to be an ideal, it must satisfy the following properties:</p><ul><li><span>$(I, +) \leq (R, +)$</span></li><li><span>$y \in R, i \in I: i \cdot y \in I$</span></li><li><span>$x \in R, i \in I: x \cdot i \in I$</span></li></ul><p>Once we have an ideal, we can construct the quotient ring R/I, whose elements are the cosets themselves. The operations are defined by adding or multiplying these cosets together. It is important to note that an ideal is not a subring because it typically does not contain the multiplicative identity. If an ideal contains 1, it must be the entire ring.</p><p>We consider the specific ideal generated by two polynomials enforcing periodic boundary conditions:</p><p class="math-container">\[\begin{aligned}
J = \langle x^\ell - 1, y^m - 1 \rangle = { p(x,y)(x^ll - 1) + q(x,y)(y^m - 1) \mid p, q \in \mathbb{F}_2[x,y]}
\end{aligned}\]</p><p>is a subset of a ring that is closed under addition and under multiplication by any element of the ring (see Definition 10.28 and 10.39) from (<a href="../references/#ernst2016inquiry">Ernst, 2016</a>). The set I is the ideal generated by the two polynomials <span>$x^\ell - 1$</span> and <span>$y^m - 1$</span> (see Definition 10.45) from (<a href="../references/#ernst2016inquiry">Ernst, 2016</a>). This ideal enforces <em>wrapping around</em> in both spatial dimensions: <span>$x^\ell - 1$</span> creates periodic boundary conditions in the x-direction and <span>$y^m - 1$</span> creates periodic boundary conditions in the y-direction.</p><p>Formally, to verify that <span>$J$</span> satisfies the <em>ideal</em> requirements, the properties of J are as follows:</p><ul><li><span>$(J, +) \leq mathbb{F}_2[x, y], +)$</span></li></ul><p>For any <span>$f(x,y) \in \mathbb{F}_2[x, y]$</span> and any <span>$j(x,y) \in J$</span>:</p><ul><li><span>$f(x,y) \cdot j(x,y) \in J$</span></li><li><span>$j(x,y) \cdot f(x,y) \in J$</span></li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford.ECC;

julia&gt; F₂ = GF(2);

julia&gt; R, (x, y) = polynomial_ring(F₂, [:x, :y]);

julia&gt; ℓ, m = 4, 3
(4, 3)

julia&gt; J = ideal(R, [x^ℓ - 1, y^m - 1])
Ideal generated by
  x^4 + 1
  y^3 + 1

julia&gt; x*(x^ℓ - 1) + y*(y^m - 1) ∈ J
true

julia&gt; (x^2 + y)*(x^ℓ - 1) + (x*y + 1)*(y^m - 1) ∈ J
true

julia&gt; 0*(x^ℓ - 1) + 0*(y^m - 1) ∈ J
true</code></pre><p>The quotient ring <span>$R = \mathbb{F}_2[x, y] / I$</span> is formed by taking the set of <a href="https://en.wikipedia.org/wiki/Coset">cosets</a> <span>$f + I$</span>. In this ring, two polynomials are considered the same if their difference is in I. The operations are defined by:</p><p class="math-container">\[\begin{aligned}
(f + I) + (g + I) = (f + g) + I, \quad (f + I)(g + I) = (fg) + I
\end{aligned}\]</p><p>This imposes the relations <span>$x^\ell = 1$</span> and <span>$y^m = 1$</span>. The operations of addition and multiplication are performed modulo the ideal I. See Theorem 10.44 of (<a href="../references/#ernst2016inquiry">Ernst, 2016</a>) for more details.</p><pre><code class="language-julia-repl hljs">julia&gt; Q, proj = quo(R, J);

julia&gt; x_Q, y_Q = proj(x), proj(y);

julia&gt; zero_Q, one_Q = Q(0), Q(1);

julia&gt; x_Q^ℓ == one_Q
true

julia&gt; y_Q^m == one_Q
true

julia&gt; x_Q^ℓ - one_Q == zero_Q
true

julia&gt; y_Q^m - one_Q == zero_Q
true</code></pre><p>As a vector space over <span>$\mathbb{F}_2$</span>, R has dimension <span>$\ell m$</span> with basis</p><p class="math-container">\[\begin{aligned}
{ x^i y^j : 0 \le i &lt; \ell, 0 \le j &lt; m}
\end{aligned}\]</p><pre><code class="language-julia-repl hljs">julia&gt; basis_elems = [x_Q^i*y_Q^j for i in 0:ℓ-1, j in 0:m-1]
4×3 Matrix{MPolyQuoRingElem{FqMPolyRingElem}}:
 1    y      y^2
 x    x*y    x*y^2
 x^2  x^2*y  x^2*y^2
 x^3  x^3*y  x^3*y^2

julia&gt; length(unique(basis_elems)) == ℓ*m
true</code></pre><p>There is an injective ring homomorphism from <span>$R$</span> to <span>$\mathbb{F}_2^{\ell m \times \ell m}$</span> given by <span>$x \mapsto S_\ell \otimes I_m$</span> and <span>$y \mapsto I_k \otimes S_m$</span>, where <span>$S_k$</span> is the cyclic shift matrix of size <span>$k \times k$</span> (<a href="../references/#eberhardt2024logical">Eberhardt and Steffan, 2024</a>). This homomorphism allows us to work with either the polynomial quotient ring or explicit circulant matrix formulation. We implement the polynomial quotient ring formalism.</p><p><strong>Examples</strong></p><p>Here is the <code>[[54, 8, 6]]</code> from Table 1 (<a href="../references/#wang2024coprime">Wang and Mueller, 2024</a>)</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford.ECC;

julia&gt; l=3; m=9;

julia&gt; R, (x, y) = polynomial_ring(GF(2), [:x, :y]);

julia&gt; I = ideal(R, [x^l-1, y^m-1]);

julia&gt; S, _ = quo(R, I);

julia&gt; A = S(1 + y^2 + y^4);

julia&gt; B = S(y^3 + x + x^2);

julia&gt; c = BivariateBicycleCode(l, m, A, B);

julia&gt; code_n(c), code_k(c)
(54, 8)</code></pre><p>Here is the <code>[[72, 12, 6]]</code> from Table 3 of (<a href="../references/#bravyi2024high">Bravyi <em>et al.</em>, 2024</a>)</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford.ECC;

julia&gt; l=6; m=6;

julia&gt; R, (x, y) = polynomial_ring(GF(2), [:x, :y]);

julia&gt; I = ideal(R, [x^l-1, y^m-1]);

julia&gt; S, _ = quo(R, I);

julia&gt; A = S(x^3 + y + y^2);

julia&gt; B = S(y^3 + x + x^2);

julia&gt; c = BivariateBicycleCode(l, m, A, B);

julia&gt; code_n(c), code_k(c)
(72, 12)</code></pre><p>Here is the <code>[[756, 16, ≤ 34]]</code> from Table 3 of (<a href="../references/#bravyi2024high">Bravyi <em>et al.</em>, 2024</a>)</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford.ECC;

julia&gt; l=21; m=18;

julia&gt; R, (x, y) = polynomial_ring(GF(2), [:x, :y]);

julia&gt; I = ideal(R, [x^l-1, y^m-1]);

julia&gt; S, _ = quo(R, I);

julia&gt; A = S(x^3 + y^10 + y^17);

julia&gt; B = S(y^5 + x^3 + x^19);

julia&gt; c = BivariateBicycleCode(l, m, A, B);

julia&gt; code_n(c), code_k(c)
(756, 16)</code></pre><p>Here is the <code>[[128, 14, 12]]</code> from Table 1 (<a href="../references/#eberhardt2024logical">Eberhardt and Steffan, 2024</a>)</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford.ECC;

julia&gt; l=8; m=8;

julia&gt; R, (x, y) = polynomial_ring(GF(2), [:x, :y]);

julia&gt; I = ideal(R, [x^l-1, y^m-1]);

julia&gt; S, _ = quo(R, I);

julia&gt; A = S(x^2 + y + y^3 + y^4);

julia&gt; B = S(y^2 + x + x^3 + x^4);

julia&gt; c = BivariateBicycleCode(l, m, A, B);

julia&gt; code_n(c), code_k(c)
(128, 14)</code></pre><p><strong>Relationships to other QECCs</strong></p><p>This implementation uses the polynomial quotient ring formalism. The same codes can be constructed  using various other approaches:</p><div class="admonition is-info" id="Note-63a1043721a27f14"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-63a1043721a27f14" title="Permalink"></a></header><div class="admonition-body"><p>In the discussion below, we consider the <code>[[72, 12, 6]]</code> Bivariate bicycle code as introduced in (<a href="../references/#bravyi2024high">Bravyi <em>et al.</em>, 2024</a>). For a detailed explanation of the <em>isomorphisms</em> connecting group algebra of cyclic groups, multivariate quotient rings, and circulant matrix representations, see <code>GeneralizedCirculantBivariateBicycle</code>.</p></div></div><ul><li><code>GeneralizedCirculantBivariateBicycle</code>: Circulant matrix formulation - Instead of polynomials, we provide the <em>monomial</em> terms as lists of tuples:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford.ECC;

julia&gt; ℓ = 6;

julia&gt; m = 6;

julia&gt; A = [(:x, 3), (:y, 1), (:y, 2)];

julia&gt; B = [(:y, 3), (:x, 1), (:x, 2)];

julia&gt; c = GeneralizedCirculantBivariateBicycle(ℓ, m, A, B);

julia&gt; import HiGHS;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(72, 12, 6)</code></pre><ul><li><code>LPCode</code>: Bivariate Bicycle codes are children of <em>abelian</em> <a href="https://errorcorrectionzoo.org/c/abelian_lifted_product">Lifted Product</a> codes. We provide the <span>$1 x 1$</span> matrix of group algebra elements:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford.ECC;

julia&gt; ℓ = 6;

julia&gt; m = 6;

julia&gt; GA = group_algebra(GF(2), abelian_group([ℓ, m]));

julia&gt; x, y = gens(GA);

julia&gt; A = reshape([x^3 + y + y^2], (1, 1));

julia&gt; B = reshape([y^3 + x + x^2], (1, 1));

julia&gt; c = LPCode(A, B);

julia&gt; import HiGHS;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(72, 12, 6)</code></pre><ul><li><code>two_block_group_algebra_codes</code>:  Bivaraite Bicycle codes are a subfamily of <em>abelian</em> <a href="https://errorcorrectionzoo.org/c/2bga">2BGA</a> codes, which themselves are instances of <a href="https://errorcorrectionzoo.org/c/abelian_lifted_product">Lifted Product</a> codes.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford.ECC;

julia&gt; ℓ=6; m=6;

julia&gt; GA = group_algebra(GF(2), abelian_group([ℓ, m]));

julia&gt; x, y = gens(GA);

julia&gt; A = x^3 + y + y^2;

julia&gt; B = y^3 + x + x^2;

julia&gt; c = two_block_group_algebra_codes(A,B);

julia&gt; import HiGHS;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(72, 12, 6)</code></pre><ul><li><p><code>generalized_bicycle_codes</code> and <code>GeneralizedBicycleCode</code>: Bivariate Bicycle codes are siblings of <a href="https://errorcorrectionzoo.org/c/generalized_bicycle">generalized bicycle</a> codes - both are children of <a href="https://errorcorrectionzoo.org/c/2bga">2BGA</a> codes.</p></li><li><p><code>bicycle_codes</code>: The <a href="https://errorcorrectionzoo.org/c/bicycle">bicycle</a> codes are children of (https://errorcorrectionzoo.org/c/generalized_bicycle) codes.</p></li><li><p><code>ExtendedGeneralizedBicycleCode</code>: These codes are constructed through <em>algebraic extension</em> of <a href="https://errorcorrectionzoo.org/c/generalized_bicycle">generalized bicycle</a> codes.</p></li></ul><p><strong>Fields</strong></p><ul><li><p><code>ℓ::Int64</code>: Order of the first abelian group in <span>$\mathbb{F}_2[\mathbb{Z}_\ell \times \mathbb{Z}_m]$</span></p></li><li><p><code>m::Int64</code>: Order of the second abelian group in <span>$\mathbb{F}_2[\mathbb{Z}_\ell \times \mathbb{Z}_m]$</span></p></li><li><p><code>c::Oscar.MPolyQuoRingElem</code>: First bivariate polynomial in quotient ring <span>$\frac{\mathbb{F}_2[x, y]}{\langle x^\ell-1, y^m-1 \rangle}$</span></p></li><li><p><code>d::Oscar.MPolyQuoRingElem</code>: Second bivariate polynomial in quotient ring <span>$\frac{\mathbb{F}_2[x, y]}{\langle x^\ell-1, y^m-1 \rangle}$</span></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordOscarExt/bivariate_bicycle.jl#L1-L310">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordOscarExt.DDimensionalSurfaceCode" href="#QuantumCliffordOscarExt.DDimensionalSurfaceCode"><code>QuantumCliffordOscarExt.DDimensionalSurfaceCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DDimensionalSurfaceCode &lt;: QuantumCliffordOscarExt.DDimensionalCode</code></pre><p>Constructs the <code>D</code>-dimensional surface code using <a href="https://en.wikipedia.org/wiki/Chain_complex">chain complexes</a> and <span>$\mathbb{F}_2$</span>-<a href="https://en.wikipedia.org/wiki/Homology_(mathematics)">homology</a>.</p><p><strong>Homological Algebra Foundations of Quantum Error Correction</strong></p><p>The theory of chain complexes over <span>$\mathbb{F}_2$</span> provides a unified framework for understanding error-correcting codes, where classical <span>$[n, k, d]$</span> codes correspond to <code>2</code>-term complexes and quantum CSS codes arise naturally as <code>3</code>-term complexes satisfying the commutativity condition <span>$H_Z^T H_X = 0$</span>. The homological framework reveals that:</p><ul><li>Quantum CSS codes arise from chain complexes where boundary operators correspond to parity checks.</li><li>Logical operators correspond to homology classes.</li><li>Higher-dimensional codes can be constructed through products of complexes.</li></ul><p><strong>Chain Complex Structure</strong></p><p>A <strong>chain complex</strong> <span>$C$</span> of length <span>$n$</span> is a sequence of finite-dimensional vector spaces <span>$C_j$</span> over <span>$\mathbb{F}_2$</span> connected by boundary operators that are linear transformations <span>$\partial_j \colon C_j \to C_{j-1}$</span>:</p><p class="math-container">\[\begin{aligned}
C : \{0\} \longrightarrow C_n \xrightarrow{\partial_n} C_{n-1} \xrightarrow{\partial_{n-1}} \cdots \xrightarrow{\partial_2} C_1 \xrightarrow{\partial_1} C_0 \longrightarrow \{0\}
\end{aligned}\]</p><p>with boundary operators satisfying <span>$\partial_i \circ \partial_{i+1} = 0$</span> (equivalently, <span>$\text{im}\, \partial_{j+1} \subseteq \ker \partial_j)$</span>.We define:</p><ul><li><strong>i-chains</strong>: Elements of <span>$C_i$</span></li><li><strong>i-cycles</strong>: <span>$Z_i(C) := \ker \partial_i$</span></li><li><strong>i-boundaries</strong>: <span>$B_i(C) := \mathrm{im} \partial_{i+1}$</span></li><li><strong>i-th homology</strong>: <span>$H_i(C) := Z_i(C)/B_i(C)$</span></li></ul><p><strong>Cohomology of the Dual Complex</strong></p><p>Given a chain complex <span>$C$</span> with boundary operators <span>$\partial_j$</span>, its <strong>cochain complex</strong> <span>$\widetilde{C}$</span> is the <em>dual</em> sequence with coboundary maps <span>$\delta^i = \partial_{i+1}^T$</span>:</p><p class="math-container">\[\begin{aligned}
\widetilde{C} : \{0\} \longleftarrow C_0^* \xleftarrow{\partial_1^T} C_1^* \xleftarrow{\partial_2^T} \cdots \xleftarrow{\partial_n^T} C_n^* \longleftarrow \{0\}
\end{aligned}\]</p><p>where</p><ul><li><strong>i-cocycles</strong>: <span>$Z^i(\widetilde{C}) := \ker \partial_{i+1}^T$</span></li><li><strong>i-coboundaries</strong>: <span>$B^i(\widetilde{C}) := \mathrm{im} \partial_i^T$</span></li><li><strong>i-th cohomology</strong>: <span>$H^i(\widetilde{C}) := Z^i(\widetilde{C})/B^i(\widetilde{C})$</span></li></ul><div class="admonition is-info" id="Note-3c01cf920dde9e4e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-3c01cf920dde9e4e" title="Permalink"></a></header><div class="admonition-body"><p>The cohomology group <span>$H^i(\widetilde{C}) = H(\partial_{i+1}^T, \partial_i^T)$</span> has the same rank as the homology group <span>$H_i(C)$</span> and corresponds to <span>$X$</span>-type logical operators in the CSS code <span>$CSS(\partial_i, \partial_{i+1}^T)$</span>, while <span>$H_i(C)$</span> corresponds to <span>$Z$</span>-type operators. </p></div></div><p><strong>Classical Codes via Chain Complexes and <span>$\mathbb{F_2}$</span> Homology</strong></p><p>An <span>$[n,k,d]$</span> classical code corresponds to a <code>2</code>-term complex:</p><p class="math-container">\[\begin{aligned}
\{0\} \longrightarrow C_1 \xrightarrow{\partial_1 = H} C_0 \longrightarrow \{0\}
\end{aligned}\]</p><p>where</p><ul><li><span>$C_1 = \mathbb{F}_2^n$</span> (codeword space)</li><li><span>$C_0 = \mathbb{F}_2^{n-k}$</span> (syndrome space)</li><li><span>$H$</span> is the parity check matrix</li></ul><p><strong>Quantum CSS Codes via Chain Complexes and <span>$\mathbb{F_2}$</span> Homology</strong></p><p>Quantum CSS codes extend this to <code>3</code>-term complexes:</p><p class="math-container">\[\begin{aligned}
\{0\} \longrightarrow C_2 \xrightarrow{\partial_2 = H_Z^T} C_1 \xrightarrow{\partial_1 = H_X} C_0 \longrightarrow \{0\}
\end{aligned}\]</p><p>where</p><ul><li><span>$C_1 = \mathbb{F}_2^n$</span> (physical qubits)</li><li><span>$C_2 = \mathbb{F}_2^{m_Z}$</span> (<code>Z</code>-stabilizers)</li><li><span>$C_0 = \mathbb{F}_2^{m_X}$</span> (<code>X</code>-stabilizers)</li></ul><p>with the condition <span>$\partial_1 \partial_2 = H_Z^TH_X = 0$</span> ensuring that CSS orthogonality is satisfied.</p><p>For any chain complex, selecting two consecutive boundary operators defines a valid CSS code. When qubits are identified with the space <span>$C_i$</span>, the code parameters are:</p><ul><li>number of physical qubits: <span>$n = \dim C_i$</span></li><li>number of logical qubits: <span>$k = \dim H_i(C) = \dim H^i(C)$</span></li><li>code distance: <span>$d = \min\{\text{wt}(v) | v \in (H_i(C) \cup H^i(C))\backslash\{0\}\}$</span></li></ul><div class="admonition is-info" id="Note-ca96f98a47dc6e01"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ca96f98a47dc6e01" title="Permalink"></a></header><div class="admonition-body"><p>Quantum error-correcting codes, which are represented as <code>3</code>-term chain complexes, can be constructed by applying the homological or hypergraph product to two <code>2</code>-term chain complexes.</p></div></div><p>For a detailed explanation, see the ECC Zoo&#39;s writeup on the  <a href="https://errorcorrectionzoo.org/c/qubit_css#defterm-Qubit_20XCSS-to-homology_20Xcorrespondence">CSS-to-homology correspondence</a>.</p><p><strong>D-dimensional Surface Code ((<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>), (<a href="../references/#Zeng_2019">Zeng and Pryadko, 2019</a>))</strong></p><p>We provide an explicit construction of the <code>D</code>-dimensional surface code within the framework of chain complexes and homology over <span>$\mathbb{F_2}$</span>.</p><p>The quantum code is obtained by applying the homological product (or hypergraph product) to two <code>2</code>-term chain complexes. Our construction relies on taking the hypergraph product of these complexes.</p><p><strong>Double Complex</strong></p><p>Given chain complexes <code>C</code> and <code>D</code>, we construct a <a href="https://en.wikipedia.org/wiki/Double_complex">double complex</a> derived from the tensor product of two <code>2</code>-term chain complexes:</p><p class="math-container">\[\begin{aligned}
C \boxtimes D \quad \text{with} \quad \partial_i^v = \partial_i^C \otimes I_{D_i} \quad \text{and} \quad \partial_i^h = I_{C_i} \otimes \partial_i^D
\end{aligned}\]</p><p><strong>Total Complex</strong></p><p>The total complex is derived from a double complex by taking the direct sum of vector spaces and boundary maps that share the same dimension:</p><p class="math-container">\[\begin{aligned}
\text{Tot}(C \boxtimes D)_i = \bigoplus_{i=j+k} C_j \otimes D_k = E_i
\end{aligned}\]</p><p>with boundary maps:</p><p class="math-container">\[\begin{aligned}
\partial_i^E = \bigoplus_{i=j+k} \partial_j^v \oplus \partial_k^h
\end{aligned}\]</p><p>The resulting chain complex, called the tensor product of <span>$C$</span> and <span>$D$</span>, <span>$C ⊗ D$</span>, enables the construction of a CSS code when selecting any three consecutive terms in its sequence.</p><p><strong>Subfamilies</strong></p><p><strong>[[L² + (L − 1)², 1, L]] 2D Surface Code</strong></p><p>The <code>2D</code> surface code is constructed using the hypergraph product of two repetition codes.Thus, we obtain a new <code>3</code>-term chain complex:</p><p class="math-container">\[\begin{aligned}
E_2 \xrightarrow{\partial_2^E} E_1 \xrightarrow{\partial_1^E} E_0
\end{aligned}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; D = 2; L = 2;

julia&gt; c = DDimensionalSurfaceCode(D, L);

julia&gt; code = parity_checks(c)
+ X_X_X
+ _X_XX
+ ZZ__Z
+ __ZZZ

julia&gt; import HiGHS; import JuMP;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(5, 1, 2)</code></pre><p>When <code>L = 4</code>, we get <code>[[25,1, 4]]</code> <code>2D</code> surface code from (<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; D = 2; L = 4;

julia&gt; c = DDimensionalSurfaceCode(D, L);

julia&gt; code = parity_checks(c)
+ X___X___________X________
+ _X___X__________XX_______
+ __X___X__________XX______
+ ___X___X__________X______
+ ____X___X__________X_____
+ _____X___X_________XX____
+ ______X___X_________XX___
+ _______X___X_________X___
+ ________X___X_________X__
+ _________X___X________XX_
+ __________X___X________XX
+ ___________X___X________X
+ ZZ______________Z________
+ _ZZ______________Z_______
+ __ZZ______________Z______
+ ____ZZ__________Z__Z_____
+ _____ZZ__________Z__Z____
+ ______ZZ__________Z__Z___
+ ________ZZ_________Z__Z__
+ _________ZZ_________Z__Z_
+ __________ZZ_________Z__Z
+ ____________ZZ________Z__
+ _____________ZZ________Z_
+ ______________ZZ________Z

julia&gt; import HiGHS; import JuMP;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(25, 1, 4)</code></pre><p><strong>Chain Complex</strong></p><p>The construction is as follows:</p><p class="math-container">\[\begin{aligned}
C = \left( C_1 \xrightarrow{\partial} C_0 \right) \quad \text{and} \quad D = \left( D_1 \xrightarrow{\partial^T} D_0 \right)
\end{aligned}\]</p><p>where <span>$\partial$</span> is the <span>$(L-1) \times L$</span> parity check matrix:</p><p class="math-container">\[\begin{aligned}
H = \begin{pmatrix}
1 &amp; 1 &amp; &amp; \\
 &amp; 1 &amp; \ddots &amp; \\
 &amp; &amp; \ddots &amp; 1 \\
 &amp; &amp; &amp; 1
\end{pmatrix}
\end{aligned}\]</p><p><strong>[[L³ + 2L(L − 1)², 1, min(L, L²)]] 3D Surface Code</strong></p><p>The <code>3D</code> surface code is obtained by taking the hypergraph product of a <code>2D</code> surface code with a repetition code. Thus, we obtain a new <code>4</code>-term chain complex:</p><p class="math-container">\[\begin{aligned}
F_3 \xrightarrow{\partial_3^F} F_2 \xrightarrow{\partial_2^F} F_1 \xrightarrow{\partial_1^F} F_0
\end{aligned}\]</p><p><strong>Metachecks</strong></p><ul><li><strong>Z-type</strong> metachecks: <span>$M_Z^T = \partial_3^F$</span></li></ul><p><strong>Example</strong></p><p>Here is an example of <code>[[12, 1, 2]]</code> <code>3D</code> Surface code with <code>L = 2</code> from (<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; D = 3; L = 2;

julia&gt; c = DDimensionalSurfaceCode(D, L);

julia&gt; code = parity_checks(c)
+ XX__X_____X_
+ __XXX______X
+ _____XX__XX_
+ _______XXX_X
+ Z_Z_Z_______
+ _Z_ZZ_______
+ _____Z_Z_Z__
+ ______Z_ZZ__
+ Z____Z____Z_
+ _Z____Z___Z_
+ __Z____Z___Z
+ ___Z____Z__Z
+ ____Z____ZZZ

julia&gt; code_n(c), code_k(c)
(12, 1)</code></pre><div class="admonition is-info" id="Note-94c7314feaf01b9a"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-94c7314feaf01b9a" title="Permalink"></a></header><div class="admonition-body"><p>For the <code>3D</code> surface code, there is an asymmetry between the <code>Z</code>- and <code>X</code>-bases (<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>). Specifically, the <code>Z</code>-distance (<span>$d_Z$</span>) is <code>4</code>, whereas the <code>X</code>-distance (<span>$d_X$</span>) is <code>2</code>. As a result, the code has the parameters <code>[[12, 1, 2]]</code>.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; import HiGHS; import JuMP;

julia&gt; dz = distance(c, DistanceMIPAlgorithm(solver=HiGHS, logical_operator_type=:Z))
4

julia&gt; dx = distance(c, DistanceMIPAlgorithm(solver=HiGHS, logical_operator_type=:X))
2</code></pre><p><strong>[[6L⁴ − 12L³ + 10L² − 4L + 1, 1, L²]] 4D Surface Code</strong></p><p>The <code>4D</code> surface code is constructed by taking the hypergraph product of a <code>3D</code> surface code with a repetition code.  Thus, we obtain a new <code>5</code>-term chain complex:</p><p class="math-container">\[\begin{aligned}
G_4 \xrightarrow{\partial_4^G} G_3 \xrightarrow{\partial_3^G} G_2 \xrightarrow{\partial_2^G} G_1 \xrightarrow{\partial_1^G} G_0
\end{aligned}\]</p><p><strong>[[33, 1, 4]]</strong></p><p>Here is an example of <code>[[33, 1, 4]]</code> <code>4D</code> Surface code with <code>L = 2</code> from (<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; D = 4; L = 2;

julia&gt; c = DDimensionalSurfaceCode(D, L);

julia&gt; import HiGHS; import JuMP;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(33, 1, 4)</code></pre><p><strong>Metachecks</strong></p><p>Both X and Z-type metachecks available:</p><ul><li><span>$M_Z^T = \partial_4^G$</span></li><li><span>$M_X = \partial_1^G$</span></li></ul><p>To obtain surface codes of greater dimensionality, we alternate between <code>C</code> and <code>D</code> and then form a product with the chain complex representing the <code>DDimensionalSurfaceCode</code> (<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>).</p><div class="admonition is-info" id="Note-193447362def1bcd"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-193447362def1bcd" title="Permalink"></a></header><div class="admonition-body"><p>The procedure described above for the <code>DDimensionalSurfaceCode</code> can alternatively be performed using an <code>L × L</code> repetition code and only the chain complex <code>C</code>. In this case, the result would be the <code>DDimensionalToricCode</code>.</p></div></div><p>See also: <a href="#QuantumCliffordOscarExt.DDimensionalToricCode"><code>DDimensionalToricCode</code></a></p><p><strong>Fields</strong></p><ul><li><p><code>D::Int64</code>: Dimension of the Surface code (must be ≥ 2).</p></li><li><p><code>L::Int64</code>: Size parameter determining the <code>D</code>-dimensional Surface code family, constructed via hypergraph product of <code>(L - 1) × L</code> repetition code chain complexes.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordOscarExt/d_dimensional_codes.jl#L38-L392">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordOscarExt.DDimensionalToricCode" href="#QuantumCliffordOscarExt.DDimensionalToricCode"><code>QuantumCliffordOscarExt.DDimensionalToricCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DDimensionalToricCode &lt;: QuantumCliffordOscarExt.DDimensionalCode</code></pre><p><strong>D-dimensional Toric Code ((<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>), (<a href="../references/#Zeng_2019">Zeng and Pryadko, 2019</a>))</strong></p><p>The <code>D</code>-dimensional toric code is obtained by taking the <strong>iterated tensor product</strong> of a single chain complex:</p><p class="math-container">\[\begin{aligned}
C = \left( \mathbb{F}_2^L \xrightarrow{H} \mathbb{F}_2^L \right)
\end{aligned}\]</p><p>where <code>H</code> is the <span>$L \times L$</span> parity check matrix of the repetition code. The total complex is built by taking the tensor product <span>$C^{\otimes D}$</span> and forming the associated total complex via direct sums.</p><div class="admonition is-info" id="Note-4954fe07e16013c7"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4954fe07e16013c7" title="Permalink"></a></header><div class="admonition-body"><p>D-dimensional toric code construction differs from the surface code as we use the full <span>$L \times L$</span> repetition code (rather than <span>$(L-1) \times L$</span>). The tensor products with identical complexes (rather than alternating complexes) are used.</p></div></div><p><strong>Subfamilies</strong></p><p><strong>[[2L², 2, L]] 2D Toric Code</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; D = 2; L = 2;

julia&gt; c = DDimensionalToricCode(D, L);

julia&gt; code = parity_checks(c)
+ X_X_XX__
+ _X_XXX__
+ X_X___XX
+ _X_X__XX
+ ZZ__Z_Z_
+ ZZ___Z_Z
+ __ZZZ_Z_
+ __ZZ_Z_Z

julia&gt; import HiGHS; import JuMP;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(8, 2, 2)</code></pre><p><strong>[[3L³, 3, min(L, L²)]] 3D Toric Code</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; D = 3; L = 2;

julia&gt; c = DDimensionalToricCode(D, L);

julia&gt; import HiGHS; import JuMP;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(24, 3, 2)</code></pre><p><strong>[[6L⁴, 6, L²]] 4D Toric Code</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; D = 4; L = 2;

julia&gt; c = DDimensionalToricCode(D, L);

julia&gt; import HiGHS; import JuMP;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(96, 6, 4)</code></pre><p>See also: <a href="#QuantumCliffordOscarExt.DDimensionalSurfaceCode"><code>DDimensionalSurfaceCode</code></a></p><p><strong>Fields</strong></p><ul><li><p><code>D::Int64</code>: Dimension of the Toric code (must be ≥ 2).</p></li><li><p><code>L::Int64</code>: Size parameter determining the <code>D</code>-dimensional Toric code family, constructed via hypergraph product of <code>L × L</code> repetition code chain complexes.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordOscarExt/d_dimensional_codes.jl#L446-L528">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordOscarExt.DoubleHomologicalProductCode" href="#QuantumCliffordOscarExt.DoubleHomologicalProductCode"><code>QuantumCliffordOscarExt.DoubleHomologicalProductCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Constructs the <em>Double Homological Product code</em> from (<a href="../references/#Campbell_2019">Campbell, 2019</a>).</p><p><strong>4-term Chain Complex</strong></p><p>To construct a quantum error-correcting code with <em>metachecks</em>, we require a length-4 chain complex. This can be built by taking the <em>homological product</em> of two length-2 chain complexes.</p><p>The length-4 chain complex, structured as:  </p><p class="math-container">\[\begin{aligned}
\breve{C}_{-2} \xrightarrow{\breve{\delta}_{-2}} \breve{C}_{-1} \xrightarrow{\breve{\delta}_{-1}} \breve{C}_0 \xrightarrow{\breve{\delta}_0} \breve{C}_1 \xrightarrow{\breve{\delta}_1} \breve{C}_2
\end{aligned}\]</p><p>The homological product of two 2D chain complexes produces this length-4 complex, following the general rule:  </p><p class="math-container">\[\begin{aligned}
\breve{C}_m = \bigoplus_{i - j = m} \tilde{C}_i \otimes \tilde{C}_j
\end{aligned}\]</p><p>The boundary maps are represented as block matrices and are defined as:  </p><p class="math-container">\[\begin{align}
\breve{\delta}_{-2} &amp;= \begin{pmatrix} 
I \otimes \tilde{\delta}_0^T \\ 
\tilde{\delta}_{-1} \otimes I 
\end{pmatrix} \\
\breve{\delta}_{-1} &amp;= \begin{pmatrix} 
I \otimes \tilde{\delta}_{-1}^T &amp; 0 \\
\tilde{\delta}_{-1} \otimes I &amp; I \otimes \tilde{\delta}_0^T \\
0 &amp; \tilde{\delta}_0 \otimes I 
\end{pmatrix} \\
\breve{\delta}_0 &amp;= \begin{pmatrix} 
\tilde{\delta}_{-1} \otimes I &amp; I \otimes \tilde{\delta}_{-1}^T &amp; 0 \\
0 &amp; \tilde{\delta}_0 \otimes I &amp; I \otimes \tilde{\delta}_0^T 
\end{pmatrix} \\
\breve{\delta}_1 &amp;= \begin{pmatrix} 
\tilde{\delta}_0 \otimes I &amp; I \otimes \tilde{\delta}_{-1}^T 
\end{pmatrix}
\end{align}\]</p><p>The condition <span>$\breve{\delta}_{j+1} \breve{\delta}_j = 0$</span> holds for all j, which follows from the corresponding property of the <span>$\tilde{\delta}$</span> matrices.  </p><p><strong>Example</strong></p><p>Here is <code>[[241, 1, 9]]</code> double homological product code from Table I of (<a href="../references/#Campbell_2019">Campbell, 2019</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC; using QECCore;

julia&gt; δ = [1 1 0;
            0 1 1];

julia&gt; c = DoubleHomologicalProductCode(δ);

julia&gt; import HiGHS; import JuMP;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(241, 1, 9)</code></pre><p><strong>Fields</strong></p><ul><li><code>H::AbstractMatrix</code>: The parity-check matrix of a classical error-correcting code.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordOscarExt/homological_product_codes.jl#L220-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordOscarExt.GeneralizedToricCode" href="#QuantumCliffordOscarExt.GeneralizedToricCode"><code>QuantumCliffordOscarExt.GeneralizedToricCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GeneralizedToricCode &lt;: AbstractCSSCode</code></pre><p>The generalized toric code is specified by two <a href="https://en.wikipedia.org/wiki/Laurent_polynomial">Laurent polynomials</a> <span>$f(x,y)$</span> and <span>$g(x,y)$</span> over <span>$\mathbb{F}_2$</span>. These polynomials encode the local stabilizers of the X and Z-type operators. The parameters (α, β, γ) define the geometry of the underlying twisted torus:</p><ul><li><span>$\alpha$</span>: vertical period from lattice vector <span>$a_1 = (0, \alpha)$</span></li><li><span>$\beta$</span>: horizontal extent from lattice vector <span>$a_2 = (\beta, \gamma)$</span></li><li><span>$\gamma$</span>: vertical shift applied when wrapping horizontally</li></ul><p><strong>Laurent Polynomial Formalism</strong></p><p>Any two-dimensional translation-invariant Pauli stabilizer code over <span>$\mathbb{Z}_2$</span> qubits that satisfies the topological order condition can be transformed via a finite-depth quantum circuit into a direct sum of Kitaev toric codes ((<a href="../references/#liang2025generalizedtoriccodestwisted">Liang <em>et al.</em>, 2025</a>), (<a href="../references/#Liang_2024">Liang <em>et al.</em>, 2024</a>)).</p><p>(<a href="../references/#liang2025generalizedtoriccodestwisted">Liang <em>et al.</em>, 2025</a>) employ a ring-theoretic approach within the framework of topological order to study two-dimensional topological CSS codes using <a href="https://en.wikipedia.org/wiki/Laurent_polynomial">Laurent polynomial</a> formalism. This technique allows for efficient construction of new quantum LDPC codes.</p><div class="admonition is-info" id="Note-fb7a2dc6f478b8b8"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-fb7a2dc6f478b8b8" title="Permalink"></a></header><div class="admonition-body"><p>The use of <em>twisted tori</em> enables stabilizers with more <em>localized</em> support compared to prior methods.  </p></div></div><p>By leveraging Laurent polynomial rings, (<a href="../references/#liang2025generalizedtoriccodestwisted">Liang <em>et al.</em>, 2025</a>) derive the topological order associated with Pauli stabilizer codes. Extending this framework, it introduces a <em>ring-theoretic</em> method that simplifies computations for CSS codes. Specifically, <em>Gröbner basis</em> techniques are utilized to classify <a href="https://en.wikipedia.org/wiki/Anyon">anyons</a> in these topological orders (<a href="../references/#liang2025generalizedtoriccodestwisted">Liang <em>et al.</em>, 2025</a>).  </p><p>For simplicity, (<a href="../references/#liang2025generalizedtoriccodestwisted">Liang <em>et al.</em>, 2025</a>) focus on the <em>square lattice</em>. On the square lattice, a unit cell consisting of two edges, representing their Pauli operators as 4-dimensional vectors:  </p><p class="math-container">\[\begin{aligned}
X_1 = \begin{bmatrix} 1 \\ 0 \\ 0 \\ 0 \end{bmatrix}, \quad
X_2 = \begin{bmatrix} 0 \\ 1 \\ 0 \\ 0 \end{bmatrix}, \quad
Z_1 = \begin{bmatrix} 0 \\ 0 \\ 1 \\ 0 \end{bmatrix}, \quad
Z_2 = \begin{bmatrix} 0 \\ 0 \\ 0 \\ 1 \end{bmatrix}
\end{aligned}\]</p><p>Translated Pauli operators are obtained by multiplying these basis vectors by the monomial <span>$x^n y^m$</span> (where n, m may be negative), implementing a shift of n steps in the x-direction and m steps in the y-direction. In this formalism, the product of two Pauli operators corresponds to the sum of their 4-dimensional vectors.  </p><p>The Pauli operator vectors form a <a href="https://en.wikipedia.org/wiki/Module_(mathematics)">module</a> over the Laurent polynomial ring <span>$R = \mathbb{Z}_2[x, y, x^{-1}, y^{-1}]$</span>.  </p><p>The translation-invariant <span>$\mathbb{Z}_2$</span> CSS code with stabilizers expressed as:  </p><p class="math-container">\[\begin{aligned}
A_v = \begin{bmatrix} f(x, y) \\ g(x, y) \\ \hline 0 \\ 0 \end{bmatrix}, \quad
B_p = \begin{bmatrix} 0 \\ 0 \\ \hline \overline{g}(x, y) \\ \overline{f}(x, y) \end{bmatrix}
\end{aligned}\]</p><p>where <span>$\overline{x^n y^m} := x^{-n} y^{-m}$</span>. <span>$A_v$</span> and <span>$B_p$</span> denote the X and Z stabilizer generators, respectively, forming the stabilizer group <span>$S$</span>. Specifically, <span>$S$</span> is generated by all lattice translations of <span>$A_v$</span> and <span>$B_p$</span>, i.e., the set of operators <span>${x^n y^m A_v, x^n y^m B_p \mid n, m \in \mathbb{Z}}$</span> (<a href="../references/#liang2025generalizedtoriccodestwisted">Liang <em>et al.</em>, 2025</a>).</p><p>Utilizing Laurent polynomial formalism, (<a href="../references/#liang2025generalizedtoriccodestwisted">Liang <em>et al.</em>, 2025</a>) introduces the <strong>generalized toric code</strong>, a subclass of bivariate bicycle codes, defined by:  </p><p class="math-container">\[\begin{aligned}
f(x, y) = 1 + x + x^a y^b, \quad 
g(x, y) = 1 + y + x^c y^d
\end{aligned}\]</p><p><strong>Topological Order Condition</strong></p><p>A key condition (<a href="../references/#liang2025generalizedtoriccodestwisted">Liang <em>et al.</em>, 2025</a>) for these polynomials is:  </p><p class="math-container">\[\begin{aligned}
\langle f(x, y) \rangle \cap \langle g(x, y) \rangle = \langle f(x, y) g(x, y) \rangle
\end{aligned}\]</p><p>where <span>$\langle p(x, y) \rangle$</span> denotes the <a href="https://en.wikipedia.org/wiki/Ideal_(ring_theory)">ideal</a> in R generated by <span>$p(x, y)$</span>. This implies that <span>$f(x, y)$</span> and <span>$g(x, y)$</span> are coprime.  </p><p>Consider the <code>[[396, 8, ≤ 26]]</code> Generalized Toric Code from Table IV of (<a href="../references/#liang2025generalizedtoriccodestwisted">Liang <em>et al.</em>, 2025</a>). The TO condition is proved using <span>$Oscar.jl$</span> as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; R, (x, y, x⁻¹, y⁻¹) = polynomial_ring(GF(2), [:x, :y, :x⁻¹, :y⁻¹]);

julia&gt; rels = [x*x⁻¹ - 1, y*y⁻¹ - 1];

julia&gt; R_q = quo(R, rels)[1];

julia&gt; f = 1 + x + x⁻¹*y⁻¹^3;

julia&gt; g = 1 + y + x^3*y⁻¹;

julia&gt; I = ideal(R_q, [f]);

julia&gt; J = ideal(R_q, [g]);

julia&gt; I_cap_J = intersect(I, J);

julia&gt; I_times_J = ideal(R_q, [f*g]);

julia&gt; I_cap_J == I_times_J
true

julia&gt; is_coprime(f, g)
true</code></pre><p><strong>Gröbner basis Computation</strong></p><p>A useful computational technique involves computing the Gröbner basis for the polynomials <span>$f&#39;(x, y) = xf(x, y)$</span> and <span>$g&#39;(x, y) = yg(x, y)$</span> to ensure non-negative exponents. Alternatively, one may introduce auxiliary variables <span>$\overline{x}, \overline{y}$</span> to represent <span>$x^{-1}, y^{-1}$</span> and include the relations <span>$\overline{x}x - 1$</span> and <span>$\overline{y}y - 1$</span> in the Gröbner basis computation (<a href="../references/#liang2025generalizedtoriccodestwisted">Liang <em>et al.</em>, 2025</a>).</p><p><strong>Example</strong></p><p>Here is an example of computing the maximum logical dimension of Example 5 (−1, −4, 4, −1)-generalized toric code from (<a href="../references/#liang2025generalizedtoriccodestwisted">Liang <em>et al.</em>, 2025</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford.ECC: max_xy_exponents;

julia&gt; R, (x, y) = polynomial_ring(GF(2), [&quot;x&quot;, &quot;y&quot;]);

julia&gt; f = x*y^4 + x^2*y^4 + 1;

julia&gt; g = y + y^2 + x^4;

julia&gt; I = ideal(R, [f, g]);

julia&gt; G = groebner_basis(I, ordering=lex([x,y])) # Eq. 51
Gröbner basis with elements
  1: y^20 + y^17 + 1
  2: x + y^16 + y^13 + y^12 + y^9 + y^2 + y
with respect to the ordering
  lex([x, y])

julia&gt; H = groebner_basis(I, ordering=lex([y,x])) # Eq. 54
Gröbner basis with elements
  1: x^20 + x^18 + x^2 + x + 1
  2: y + x^18 + x^17 + x^8 + x^4 + 1
with respect to the ordering
  lex([y, x])

julia&gt; a, b = max_xy_exponents(G);

julia&gt; all_monomials = [x^i * y^j for i in 0:a-1 for j in 0:b-1] # Eq. 52
20-element Vector{FqMPolyRingElem}:
 1
 y
 y^2
 y^3
 y^4
 y^5
 y^6
 y^7
 y^8
 y^9
 y^10
 y^11
 y^12
 y^13
 y^14
 y^15
 y^16
 y^17
 y^18
 y^19

julia&gt; k_max = 2*length(all_monomials)
40</code></pre><p><strong>Parity Checks</strong></p><p>The total number of physical qubits is <span>$n = 2*\alpha\beta$</span>, corresponding to horizontal and vertical edges in each unit cell. The parity-check matrices <span>$H_X$</span> and <span>$H_Z$</span> are constructed following approach in Appendix B of (<a href="../references/#liang2025generalizedtoriccodestwisted">Liang <em>et al.</em>, 2025</a>). Qubits are indexed row-by-row: for each <code>y</code>-coordinate, horizontal edges are listed first, then vertical edges. Stabilizers are generated by translating the <em>origin</em> stabilizer, defined by the monomial supports of <code>f</code> and <code>g</code>, across all <span>$(l_x, l_y)$</span> in <span>$0 ≤ l_x &lt; \beta$</span>, <span>$0 ≤ l_y &lt; \alpha$</span>. Translations obey twisted boundary conditions determined by <span>$(\alpha, \beta, \gamma)$</span>, ensuring the matrices retain a generalized cyclic structure.</p><p>The notable cases of Generalized toric codes include:</p><p><strong>Kitaev Toric Code</strong></p><p>The Kitaev Toric code is defined by the Laurent polynomials <span>$f(x, y) = 1 + x$</span> and <span>$g(x, y) = 1 + y$</span>. The only independent monomial is 1, as all other monomials <span>$x^a y^b$</span> can be expressed as:  </p><p class="math-container">\[\begin{aligned}
    x^a y^b = a_1 + p(x, y)f(x, y) + q(x, y)g(x, y)
\end{aligned}\]</p><p>where <span>$a_1 \in \mathbb{Z}_2$</span> and <span>$p(x, y), q(x, y) \in R$</span>. For instance: <span>$x^2 = 1 + (1 + x)(1 + x)$</span>. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; R, (x,y) = laurent_polynomial_ring(GF(2), [:x, :y]);

julia&gt; f = 1 + x;

julia&gt; g = 1 + y;

julia&gt; α1 = (0, 6);

julia&gt; α2 = (3, 3);

julia&gt; c = GeneralizedToricCode(f, g, α1, α2);

julia&gt; code_n(c), code_k(c)
(36, 2)</code></pre><p><strong>Color Code</strong></p><p>The Color code is defined by the Laurent polynomials <span>$f(x, y) = 1 + x + xy$</span> and <span>$g(x, y) = 1 + y + xy$</span>. The independent monomials are 1 and x. Other monomials follow:</p><p class="math-container">\[\begin{aligned}
    x^a y^b = a_1 + a_x x + p(x, y)f(x, y) + q(x, y)g(x, y)
\end{aligned}\]</p><p>The code has <span>$k_{\text{max}} = 4$</span>, reflecting its structure as a direct sum of two Kitaev codes.  </p><div class="admonition is-info" id="Note-9ee5eadc562d800c"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-9ee5eadc562d800c" title="Permalink"></a></header><div class="admonition-body"><p>For simple polynomials, independent monomials can be identified manually. However, a systematic approach using <strong>Gröbner basis</strong> is necessary for general cases.  </p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; R, (x, y) = laurent_polynomial_ring(GF(2), [:x, :y]);

julia&gt; f = 1 + x + x*y;

julia&gt; g = 1 + y + x*y;

julia&gt; α1 = (0, 6);

julia&gt; α2 = (3, 3);

julia&gt; c = GeneralizedToricCode(f, g, α1, α2);

julia&gt; code_n(c), code_k(c)
(36, 4)</code></pre><p><strong><span>$(-1, 3, 3, -1)$</span>-Generalized Toric Code</strong></p><p>The <span>$(-1, 3, 3, -1)$</span>-Generalized Toric code corresponds to stabilizers in the Gross code and <span>$(3, 3)$</span>-BB code. The Laurent polynomials are:</p><p class="math-container">\[\begin{aligned}
    f(x, y) = 1 + x + x^{-1}y^3, \quad g(x, y) = 1 + y + x^3 y^{-1},  
\end{aligned}\]</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; R, (x, y) = laurent_polynomial_ring(GF(2), [:x, :y]);

julia&gt; f = 1 + x + x^-1*y^3;

julia&gt; g = 1 + y + x^3*y^-1;

julia&gt; α1 = (0, 12);

julia&gt; α2 = (6, 0);

julia&gt; c = GeneralizedToricCode(f, g, α1, α2);

julia&gt; code_n(c), code_k(c)
(144, 12)</code></pre><p><strong><span>$(-1, -3, 3, -1)$</span>-Generalized Toric Code</strong></p><p>The <span>$(-1, -3, 3, -1)$</span>-Generalized Toric code corresponds to the (3, -3)-BB code. The Laurent polynomials are:</p><p class="math-container">\[\begin{aligned} 
    f(x, y) = 1 + x + x^{-1}y^{-3}, \quad g(x, y) = 1 + y + x^3 y^{-1}.  
\end{aligned}\]</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; R, (x, y) = laurent_polynomial_ring(GF(2), [:x, :y]);

julia&gt; f = 1 + x + x^-1*y^-3;

julia&gt; g = 1 + y + x^3*y^-1;

julia&gt; α1 = (0, 12);

julia&gt; α2 = (6, 0);

julia&gt; c = GeneralizedToricCode(f, g, α1, α2);

julia&gt; code_n(c), code_k(c)
(144, 12)</code></pre><p><strong>Example from Tables I-IV of (<a href="../references/#liang2025generalizedtoriccodestwisted">Liang <em>et al.</em>, 2025</a>)</strong></p><p>Here is an example of <code>[[396, 8, ≤ 26]]</code> Generalized Toric Code from Table IV of (<a href="../references/#liang2025generalizedtoriccodestwisted">Liang <em>et al.</em>, 2025</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; R, (x,y) = laurent_polynomial_ring(GF(2), [:x, :y]);

julia&gt; f = 1 + x + x^-1*y^-3;

julia&gt; g = 1 + y + x^3*y^-1;

julia&gt; α1 = (0, 66);

julia&gt; α2 = (3, 18);

julia&gt; c = GeneralizedToricCode(f, g, α1, α2);

julia&gt; code_n(c), code_k(c)
(396, 8)</code></pre><p>Here is an example of <code>[[292, 18, 8]]</code> Generalized Toric Code from Appendix B of (<a href="../references/#liang2025generalizedtoriccodestwisted">Liang <em>et al.</em>, 2025</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC;

julia&gt; R, (x,y) = laurent_polynomial_ring(GF(2), [:x, :y]);

julia&gt; f = 1 + x + y^2;

julia&gt; g = 1 + y + x^-4*y;

julia&gt; α1 = (0, 73);

julia&gt; α2 = (2, 32);

julia&gt; c = GeneralizedToricCode(f, g, α1, α2);

julia&gt; code_n(c), code_k(c)
(292, 18)</code></pre><p><strong>Fields</strong></p><ul><li><p><code>f::AbstractAlgebra.Generic.LaurentMPolyWrap</code>: Laurent polynomial over <span>$\mathbb{F}_2$</span> defining horizontal–edge action of the X-type stabilizer</p></li><li><p><code>g::AbstractAlgebra.Generic.LaurentMPolyWrap</code>: Laurent polynomial over <span>$\mathbb{F}_2$</span> defining vertical–edge action of the X-type stabilizer</p></li><li><p><code>a1::Tuple{Int64, Int64}</code>: First lattice vector <span>$\mathbf{a}_1 = (p_1, q_1)$</span>, from which <span>$(\alpha, \beta, \gamma)$</span> can be computed so that <span>$a_1 = (0, \alpha)$</span> represents the same <em>generic</em> twisted torus under a unimodular transformation.</p></li><li><p><code>a2::Tuple{Int64, Int64}</code>: Second lattice vector <span>$\mathbf{a}_2 = (p_2, q_2)$</span>, from which <span>$(\alpha, \beta, \gamma)$</span> can be computed so that <span>$a_2 = (\beta, \gamma)$</span> represents the same <em>generic</em> twisted torus under a unimodular transformation.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordOscarExt/generalized_toric.jl#L1-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordOscarExt.HomologicalProductCode" href="#QuantumCliffordOscarExt.HomologicalProductCode"><code>QuantumCliffordOscarExt.HomologicalProductCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct HomologicalProductCode{T&lt;:AbstractAlgebra.MatElem} &lt;: AbstractCSSCode</code></pre><p>Constructs a D-dimensional CSS quantum code (D ≥ 2) from D classical parity-check matrices via iterated <em>homological</em> products.</p><p>Several interpretations of the homological product exist. For example, (<a href="../references/#bravyi2013homologicalproductcodes">Bravyi and Hastings, 2013</a>) employ a simplified version known as the <em>single-sector</em> homological product. In contrast, the <code>HomologicalProductCode</code> adopts a more conventional definition, which (<a href="../references/#bravyi2013homologicalproductcodes">Bravyi and Hastings, 2013</a>) would refer to as the <em>multi-sector</em> homological product.</p><p>The term &quot;homological product codes&quot; can broadly encompass various constructions involving the product of quantum codes ((<a href="../references/#bravyi2013homologicalproductcodes">Bravyi and Hastings, 2013</a>), (<a href="../references/#Campbell_2019">Campbell, 2019</a>)). However, <code>HomologicalProductCode</code> focuses specifically on a particular subset—namely, the product of classical codes, which can also be described as length-<code>1</code> chain complexes (sometimes called high-dimensional hypergraph product codes (<a href="../references/#Zeng_2019">Zeng and Pryadko, 2019</a>)).</p><p><strong>Product Complex</strong></p><p>Given <span>$D$</span> chain complexes <span>$\{\mathcal{B}^i\}_{i\in[D]}$</span>, where <span>$\mathcal{B}^i = \{\{B^i_{x_i}\}_{x_i}, \{\partial^i_{x_i}\}_{x_i}\}$</span>, the <span>$D$</span>-dimensional product complex is defined as:</p><p class="math-container">\[\begin{aligned}
\mathcal{D} = \{\{D_{\vec{x}}\}_{\vec{x}=(x_1,\dots,x_D)^T \in \mathbb{Z}^D}, \{\partial^i_{\vec{x}}: D_{\vec{x}} \to D_{\vec{x}-\vec{e}_i}\}_{i\in[D],\vec{x}\in\mathbb{Z}^D}\} := \text{Prod}(\{\mathcal{B}^i\}_{i\in[D]})
\end{aligned}\]</p><p>the tensor product of these chain complexes, where:</p><p class="math-container">\[\begin{aligned}
D_{\vec{x}} := \bigotimes_{i=1}^D B^i_{x_i}, \\
\partial^i_{\vec{x}} := \bigotimes_{j=1}^D (\partial^j_{x_j})^{\delta_{i,j}}
\end{aligned}\]</p><p>where <span>$\delta_{i,j}$</span> is the Kronecker delta function and <span>$(\partial^j_{x_j})^0$</span> is defined as the identity map (<a href="../references/#xu2024fastparallelizablelogicalcomputation">Xu <em>et al.</em>, 2024</a>).</p><p>A product complex is a high-dimensional generalization of the chain complex.</p><p><strong>Total Complex</strong></p><p>The <span>$\mathcal{D}$</span>-product complex is constructed from <span>$D$</span> base chain complexes with vector spaces <span>$\{D_{\vec{x}}\}_{\vec{x}}$</span> and boundary maps <span>$\{\partial^i_{\vec{x}}\}_{i\in[D],\vec{x}}$</span>. It&#39;s total chain complex <span>$\mathcal{T} = \{\{T_k\}_k, \{\delta_k\}_k\} := \text{Tot}(\mathcal{D})$</span> as follows:</p><p class="math-container">\[\begin{aligned}
T_k := \bigoplus_{|\vec{x}|=k} D_{\vec{x}}
\end{aligned}\]</p><p>and the boundary maps:</p><p class="math-container">\[\begin{aligned}
\delta_k\left(\bigoplus_{|\vec{x}|=k} a_{\vec{x}}\right) = \sum_{|\vec{x}|=k} \left(\bigoplus_{|\vec{y}|=k-1} \partial_{\vec{y},\vec{x}} a_{\vec{x}}\right)
\end{aligned}\]</p><p>for any <span>$a_{\vec{x}} \in D_{\vec{x}}$</span>, and</p><p class="math-container">\[\begin{aligned}
\partial_{\vec{y},\vec{x}} := 
\begin{cases} 
\partial^i_{\vec{x}} &amp; \text{if } \vec{x} - \vec{y} = \vec{e}_i \text{ for some } i \in [D], \\
0 &amp; \text{otherwise.}
\end{cases}
\end{aligned}\]</p><div class="admonition is-info" id="Note-bc9e0240e3f9f7a1"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-bc9e0240e3f9f7a1" title="Permalink"></a></header><div class="admonition-body"><p>The total complex is obtained by projecting the <span>$D$</span>-dimensional complex along the &quot;diagonal&quot; direction. Once a total chain complex is derived from a product complex (with length greater than 2), a quantum code can be defined from a length-2  subcomplex (<a href="../references/#xu2024fastparallelizablelogicalcomputation">Xu <em>et al.</em>, 2024</a>).</p></div></div><p>(<a href="../references/#xu2024fastparallelizablelogicalcomputation">Xu <em>et al.</em>, 2024</a>) focuses on product complexes with length-1 base complexes <span>$\{\mathcal{C}^i\}_{i\in[D]}}$</span> (classical codes). In this case, the total complex <span>$\mathcal{T} = \text{Tot}(\text{Prod}(\{\mathcal{C}^i\}_{i\in[D]}))$</span> has length <span>$D$</span>:</p><p class="math-container">\[\begin{aligned}
T_D \xrightarrow{\delta_D} T_{D-1} \xrightarrow{\delta_{D-1}} \cdots \xrightarrow{\delta_1} T_0
\end{aligned}\]</p><p>(<a href="../references/#xu2024fastparallelizablelogicalcomputation">Xu <em>et al.</em>, 2024</a>) considers dimensions <span>$D = 2, 3, 4$</span>.</p><ul><li>For <span>$D = 2$</span>, the standard hypergraph product code is obtained, with planar surface codes as a special case (<a href="../references/#xu2024fastparallelizablelogicalcomputation">Xu <em>et al.</em>, 2024</a>).</li><li>For <span>$D = 3$</span> and <span>$D = 4$</span>, the construction yields 3D and 4D homological product codes, with 3D surface/toric codes serving as specific instances (<a href="../references/#xu2024fastparallelizablelogicalcomputation">Xu <em>et al.</em>, 2024</a>).</li></ul><p><strong>Examples</strong></p><p>Here is a 3D Homological product code from (<a href="../references/#Quintavalle_2021">Quintavalle <em>et al.</em>, 2021</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC; using QECCore;

julia&gt; δ = matrix(GF(2), parity_matrix(RepCode(3)));

julia&gt; c = HomologicalProductCode([δ,δ,δ]);

julia&gt; import HiGHS; import JuMP;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(81, 3, 3)</code></pre><p>Here is the <code>[[117, 9, 4]]</code> Homological product code construct from classical quasi-cyclic code from Table III of (<a href="../references/#xu2024fastparallelizablelogicalcomputation">Xu <em>et al.</em>, 2024</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC; using QECCore;

julia&gt; R, x = polynomial_ring(GF(2), &quot;x&quot;);

julia&gt; l = 3;

julia&gt; H = matrix(R, 2, 3, [x^2 x^2 x^2;
                            x   x^2  0]);

julia&gt; c = HomologicalProductCode([H,transpose(H)], l);

julia&gt; import HiGHS; import JuMP;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(117, 9, 4)</code></pre><p>Here is a Homological product of <code>(3,4)</code>-classical LDPC codes.</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QuantumClifford.ECC; using QECCore;

julia&gt; μ = 2; wc = 3; wr = 4;

julia&gt; c = GallagerLDPC(μ, wc, wr);

julia&gt; H = matrix(GF(2), parity_matrix(c));

julia&gt; c = HomologicalProductCode([H,transpose(H)]);

julia&gt; import HiGHS; import JuMP;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(100, 20, 2)</code></pre><p><strong>Fields</strong></p><ul><li><code>boundary_maps::Vector{T} where T&lt;:AbstractAlgebra.MatElem</code>: A length-<code>D</code> vector of parity-check matrices of classical error-correcting codes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordOscarExt/homological_product_codes.jl#L1-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordOscarExt.TrivariateTricycleCode" href="#QuantumCliffordOscarExt.TrivariateTricycleCode"><code>QuantumCliffordOscarExt.TrivariateTricycleCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct TrivariateTricycleCode &lt;: AbstractCSSCode</code></pre><p>A quantum CSS code constructed from three trivariate polynomials over a finite field from (<a href="../references/#jacob2025singleshotdecodingfaulttolerantgates">Jacob <em>et al.</em>, 2025</a>).</p><p>(<a href="../references/#jacob2025singleshotdecodingfaulttolerantgates">Jacob <em>et al.</em>, 2025</a>) first define arbitrary 3-block group algebra codes (for an <em>abelian</em> group G. The group algebra <span>$\mathbb{F}_2[G]$</span> consists of formal sums of the form <span>$\sum_{g \in G} a_g g$</span>, with <span>$a_g \in \mathbb{F}_2$</span>.</p><p>For a 3-block code, we consider the three length-1 chain complexes:</p><p class="math-container">\[\begin{aligned}
A_1 \xrightarrow{\quad a \quad} A_0, \quad
B_1 \xrightarrow{\quad b \quad} B_0, \quad
C_1 \xrightarrow{\quad c \quad} C_0,
\end{aligned}\]</p><p>where <span>$A_i, B_i, C_i = \mathbb{F}_2[G]$</span> and the boundary maps <span>$a, b, c \in \mathbb{F}_2[G]$</span>.</p><p>The tensor (balanced) product complex is formed from these three complexes using the <em>isomorphism</em> <span>$\mathbb{F}_2[G] \otimes_G \mathbb{F}_2[G] \simeq \mathbb{F}_2[G]$</span> which is used to simplify the general definition. The resulting tensor product complex is:</p><p class="math-container">\[\begin{aligned}
A_1 \otimes_G B_1 \otimes_G C_1
\xrightarrow{\quad \partial_3 \quad}
\bigoplus_{i+j+k=2} A_i \otimes_G B_j \otimes_G C_k
\xrightarrow{\quad \partial_2 \quad}
\bigoplus_{i+j+k=1} A_i \otimes_G B_j \otimes_G C_k
\xrightarrow{\quad \partial_1 \quad} A_0 \otimes_G B_0 \otimes_G C_0
\end{aligned}\]</p><p>The boundary maps can be written explicitly in terms of a, b, and c as:</p><p class="math-container">\[\begin{aligned}
\partial_3 &amp;= \begin{bmatrix} a \\ b \\ c \end{bmatrix} \\
\partial_2 &amp;= \begin{bmatrix}
0 &amp; c &amp; b \\
c &amp; 0 &amp; a \\
b &amp; a &amp; 0
\end{bmatrix} \\
\partial_1 &amp;= \begin{bmatrix} a &amp; b &amp; c \end{bmatrix}
\end{aligned}\]</p><p>The trivariate tricycle codes from this complex by considering <span>$G = \Z_\ell \times \Z_m \times \Z_p$</span> for integers <span>$\ell$</span>, m, and p. The following matrices which generate this group:</p><p class="math-container">\[\begin{aligned}
x &amp;= S_\ell \otimes I_m \otimes I_p \\
y &amp;= I_\ell \otimes S_m \otimes I_p \\
z &amp;= I_\ell \otimes I_m \otimes S_p
\end{aligned}\]</p><p>where <span>$S_n$</span> is the <span>$n \times n$</span> cyclic shift matrix with elements <span>$(S_n)_{i,j} = \delta_{i, j \oplus 1}$</span> and <span>$\oplus$</span> denotes addition modulo n.</p><p>We consider A, B, and C to be be polynomials in the non-commuting variables x, y, and z. An initial symmetric choice is:</p><p class="math-container">\[\begin{aligned}
A &amp;= A_1 + A_2 + A_3 \\
B &amp;= B_1 + B_2 + B_3 \\
C &amp;= C_1 + C_2 + C_3
\end{aligned}\]</p><p>though this restriction can be relaxed (<a href="../references/#jacob2025singleshotdecodingfaulttolerantgates">Jacob <em>et al.</em>, 2025</a>).</p><p>We then define the parity-check matrices for the CSS code as:</p><p class="math-container">\[\begin{aligned}
H_X \equiv \partial_1, \quad H_Z = \partial_2^\top, \quad M_Z = \partial_3^\top,
\end{aligned}\]</p><p>where <span>$H_X$</span> and <span>$H_Z$</span> are the <span>$X$</span> and <span>$Z$</span> stabilizer generators, and <span>$M_Z$</span> is a matrix of meta-checks encoding the redundancy in the <span>$Z$</span> checks. It can be verified that:</p><p class="math-container">\[\begin{aligned}
H_XH_Z^\top = 0 \quad \text{and} \quad M_ZH_Z = 0.
\end{aligned}\]</p><p>This results in the chain complex structure:</p><p class="math-container">\[\begin{aligned}
C_M \xleftarrow{\quad M_Z \quad} C_Z \xleftarrow{\quad H_Z \quad} Q \xrightarrow{\quad H_X \quad} C_X
\end{aligned}\]</p><p>where the vector spaces over <span>$\mathbb{F}_2[G]$</span>.</p><p>The matrices are given by:</p><p class="math-container">\[\begin{aligned}
M_Z &amp;= \begin{bmatrix} A^\top &amp; B^\top &amp; C^\top \end{bmatrix} \\
H_Z &amp;= \begin{bmatrix}
0 &amp; C^\top &amp; B^\top \\
C^\top &amp; 0 &amp; A^\top \\
B^\top &amp; A^\top &amp; 0
\end{bmatrix} \\
H_X &amp;= \begin{bmatrix} A &amp; B &amp; C \end{bmatrix}
\end{aligned}\]</p><div class="admonition is-info" id="Note-821e446862ccdb3f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-821e446862ccdb3f" title="Permalink"></a></header><div class="admonition-body"><p>We leverage the isomorphism between the group algebra <span>$\mathbb{F}_2[\mathbb{Z}_\ell \times \mathbb{Z}_m \times \mathbb{Z}_p]$</span> and the multivariate polynomial quotient ring <span>$\frac{\mathbb{F}_2[x, y, z]}{\langle x^\ell-1, y^m-1, z^p-1 \rangle}$</span> to introduce a novel realization of the Trivariate Tricycle codes of (<a href="../references/#jacob2025singleshotdecodingfaulttolerantgates">Jacob <em>et al.</em>, 2025</a>).</p></div></div><p>The generalization of the <a href="#QuantumCliffordOscarExt.TrivariateTricycleCode"><code>TrivariateTricycleCode</code></a> codes to an arbitrary number of groups (Λ ≥ 3) remains a conjecture; for details, see Section 5.3.2, <em>Product of Λ ≥ 3 group algebra codes</em> of (<a href="../references/#breuckmann2024cupsgatesicohomology">Breuckmann <em>et al.</em>, 2024</a>). The parity-check and metacheck matrices for the <a href="#QuantumCliffordOscarExt.TrivariateTricycleCode"><code>TrivariateTricycleCode</code></a> codes—which are equivalent to the boundary maps of the underlying 3-term chain complex, see equation 2, 3, and 4 of (<a href="../references/#jacob2025singleshotdecodingfaulttolerantgates">Jacob <em>et al.</em>, 2025</a>)—are constructed explicitly in (<a href="../references/#breuckmann2024cupsgatesicohomology">Breuckmann <em>et al.</em>, 2024</a>). These matrices serve as the fundamental building blocks and provide the key theoretical insight underlying this family of quantum codes.</p><p><strong>Examples</strong></p><p>Here is the <code>[[72, 6, 6]]</code> trivariate tricycle code from Table I from (<a href="../references/#jacob2025singleshotdecodingfaulttolerantgates">Jacob <em>et al.</em>, 2025</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford.ECC;

julia&gt; l, m, p = 4, 3, 2;

julia&gt; R, (x, y, z) = polynomial_ring(GF(2), [:x, :y, :z]);

julia&gt; I = ideal(R, [x^l - 1, y^m - 1, z^p - 1]);

julia&gt; S, _ = quo(R, I);

julia&gt; A = S(1 + y + x*y^2);

julia&gt; B = S(1 + y*z + x^2*y^2);

julia&gt; C = S(1 + x*y^2*z + x^2*y);

julia&gt; c = TrivariateTricycleCode(l, m, p, A, B, C);

julia&gt; code_n(c), code_k(c)
(72, 6)</code></pre><p>Here is the <code>[[432, 12, 12]]</code> trivariate tricycle code from Table I from (<a href="../references/#jacob2025singleshotdecodingfaulttolerantgates">Jacob <em>et al.</em>, 2025</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford.ECC;

julia&gt; l, m, p = 6, 6, 4;

julia&gt; R, (x, y, z) = polynomial_ring(GF(2), [:x, :y, :z]);

julia&gt; I = ideal(R, [x^l - 1, y^m - 1, z^p - 1]);

julia&gt; S, _ = quo(R, I);

julia&gt; A = S(1 + x*y*z^3 + x^3*y^4*z^2);

julia&gt; B = S(1 + x^3*y*z^2 + x^3*y^2*z^3);

julia&gt; C = S(1 + x^4*y^3*z^3 + x^5*z^2);

julia&gt; c = TrivariateTricycleCode(l, m, p, A, B, C);

julia&gt; code_n(c), code_k(c)
(432, 12)</code></pre><p><strong>Fields</strong></p><ul><li><p><code>l::Int64</code>: Order of the first abelian group in <span>$\mathbb{F}_2[\mathbb{Z}_\ell \times \mathbb{Z}_m \times \mathbb{Z}_p]$</span></p></li><li><p><code>m::Int64</code>: Order of the second abelian group in <span>$\mathbb{F}_2[\mathbb{Z}_\ell \times \mathbb{Z}_m \times \mathbb{Z}_p]$</span></p></li><li><p><code>p::Int64</code>: Order of the third abelian group in <span>$\mathbb{F}_2[\mathbb{Z}_\ell \times \mathbb{Z}_m \times \mathbb{Z}_p]$</span></p></li><li><p><code>A::Oscar.MPolyQuoRingElem{Nemo.FqMPolyRingElem}</code>: First trivariate polynomial in quotient ring <span>$\frac{\mathbb{F}_2[x, y, z]}{\langle x^\ell-1, y^m-1, z^p-1 \rangle}$</span></p></li><li><p><code>B::Oscar.MPolyQuoRingElem{Nemo.FqMPolyRingElem}</code>: Second trivariate polynomial in quotient ring <span>$\frac{\mathbb{F}_2[x, y, z]}{\langle x^\ell-1, y^m-1, z^p-1 \rangle}$</span></p></li><li><p><code>C::Oscar.MPolyQuoRingElem{Nemo.FqMPolyRingElem}</code>: Third trivariate polynomial in quotient ring <span>$\frac{\mathbb{F}_2[x, y, z]}{\langle x^\ell-1, y^m-1, z^p-1 \rangle}$</span></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordOscarExt/trivariate_tricycle.jl#L1-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.boundary_maps-Tuple{QuantumCliffordOscarExt.DDimensionalSurfaceCode}" href="#QuantumClifford.ECC.boundary_maps-Tuple{QuantumCliffordOscarExt.DDimensionalSurfaceCode}"><code>QuantumClifford.ECC.boundary_maps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns all boundary maps of the chain complex, including both <em>parity check</em> and <em>metacheck</em> matrices.</p><p>Here are the boundary maps of <code>[[12, 1, 2]]</code> <code>3D</code> Surface code with <code>L = 2</code> from (<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using Oscar; using QuantumClifford; using QECCore;

julia&gt; using QuantumClifford.ECC: DDimensionalSurfaceCode, boundary_maps, metacheck_matrix_z;

julia&gt; D = 3; L = 2;

julia&gt; c = DDimensionalSurfaceCode(D, L);

julia&gt; Mz, Hz, Hx = boundary_maps(c);</code></pre><p>The parity check matrices of <code>[[12, 1, 2]]</code> <code>3D</code> Surface code are</p><pre><code class="language-julia-repl hljs">julia&gt; Hx
4×12 Matrix{Int64}:
 1  1  0  0  1  0  0  0  0  0  1  0
 0  0  1  1  1  0  0  0  0  0  0  1
 0  0  0  0  0  1  1  0  0  1  1  0
 0  0  0  0  0  0  0  1  1  1  0  1</code></pre><div class="admonition is-info" id="Note-90f36e89c3a2e8f9"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-90f36e89c3a2e8f9" title="Permalink"></a></header><div class="admonition-body"><p>For <code>3D</code> and higher-dimensional codes, <code>Oscar</code> returns <code>Z</code>-type parity check matrix as transpose (<span>$H_Z^T$</span>). We transpose it to convert it back to <span>$H_Z$</span>. See <code>B3</code>, page <code>11</code> of (<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>).</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; Hz&#39;
9×12 adjoint(::Matrix{Int64}) with eltype Int64:
 1  0  1  0  1  0  0  0  0  0  0  0
 0  1  0  1  1  0  0  0  0  0  0  0
 0  0  0  0  0  1  0  1  0  1  0  0
 0  0  0  0  0  0  1  0  1  1  0  0
 1  0  0  0  0  1  0  0  0  0  1  0
 0  1  0  0  0  0  1  0  0  0  1  0
 0  0  1  0  0  0  0  1  0  0  0  1
 0  0  0  1  0  0  0  0  1  0  0  1
 0  0  0  0  1  0  0  0  0  1  1  1</code></pre><p>Along with the <code>Z</code>- and <code>X</code>-type parity check matrices, we have a metacheck matrix specifically for the <code>Z</code>-type checks. The classical code derived from this metacheck matrix has a distance of <code>d = 2</code> meaning it can identify (but not correct) a single error in the <code>Z</code>-type syndrome measurements. See page <code>12</code> of (<a href="../references/#Berthusen_2024">Berthusen <em>et al.</em>, 2024</a>) for details.</p><pre><code class="language-julia-repl hljs">julia&gt; Mz&#39;
2×9 adjoint(::Matrix{Int64}) with eltype Int64:
 1  0  1  0  1  0  1  0  1
 0  1  0  1  0  1  0  1  1</code></pre><p>We can use <code>metacheck_matrix_z</code> directly instead of using <code>boundary_maps</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; metacheck_matrix_z(c)
2×9 Matrix{Int64}:
 1  0  1  0  1  0  1  0  1
 0  1  0  1  0  1  0  1  1</code></pre><p><strong>Metachecks in CSS Codes</strong></p><p>The parity-check matrices <span>$M_Z$</span> and <span>$M_X$</span> are called <em>metachecks</em> in CSS codes. These matrices emerge from the constraints imposed by boundary maps, which satisfy the condition <span>$\partial_{i+1} \partial_i = 0$</span>. This guarantees that:</p><p class="math-container">\[\begin{aligned}
M_Z H_Z = 0 \quad \text{and} \quad M_X H_X = 0,
\end{aligned}\]</p><p>meaning that:</p><ul><li>Valid <span>$Z$</span>-type syndromes must be in <span>$\ker M_Z$</span></li><li>Valid <span>$X$</span>-type syndromes must be in <span>$\ker M_X$</span></li></ul><p>When measurement errors occur, they distort the syndrome vector <span>$\mathbf{s}$</span>, generating a detectable <em>metasyndrome</em>. By examining <span>$\mathbf{m}$</span>, we can identify and correct errors in <span>$\mathbf{s}$</span> before proceeding with standard decoding. This technique is called <em>syndrome repair decoding</em> (<a href="../references/#Higgott_2023">Higgott and Breuckmann, 2023</a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordOscarExt/d_dimensional_codes.jl#L643">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.twobga_from_direct_product-Tuple{Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}}, Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}}, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}" href="#QuantumClifford.ECC.twobga_from_direct_product-Tuple{Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}}, Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}}, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}"><code>QuantumClifford.ECC.twobga_from_direct_product</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">twobga_from_direct_product(
    a_elts::Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}},
    b_elts::Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}},
    F2G::Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}
) -&gt; Any
</code></pre><p>Constructing two block group algebra codes by specifying the direct product to be used. See also the more general <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>.</p><p>Two block group algebra codes are constructed by choosing a group (and specific generators), then choosing two polynomials made out of these generators, then piping these two polynomials as the elements of <code>1×1</code> matrices to the lifted product code constructors.</p><p>The Hecke library, for which we already have an extension, provides for a fairly easy way to construct such polynomials for many abelian and small groups. See <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a> for those capabilities.</p><p>However, more esoteric groups can be specified as the direct product of other groups. To support arbitrary direct products we use Oscar, which builds upon Hecke. Oscar supports the <strong>direct product</strong> operation between two or more arbitrary <strong>general</strong> groups, including non-abelian groups such as <code>alternating_group</code>, <code>dihedral_group</code>, <code>symmetric_group</code>, and even arbitrary finitely presented groups (e.g., <code>free_group</code>). This capability is not available in <code>Hecke.jl</code>. The 2BGA codes discovered in (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>) rely on direct products of two or more <em>general</em> groups, which necessitate the use of <code>Oscar.direct_product</code>.</p><p>This particular function is nothing more than a simple wrapper that takes care of argument conversions. Of note, the polynomials here are given as lists of monomials.</p><p>Of course, if you are comfortable with Oscar, you can use <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a> directly.</p><p>See also: <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.twobga_from_fp_group"><code>twobga_from_fp_group</code></a></p><p><strong>Examples</strong></p><p>The [[56, 28, 2]] abelian 2BGA code from Appendix C, Table II in (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>) can be constructed using the direct product of two cyclic groups. Specifically, the group <code>C₂₈</code> of order <code>l = 28</code> can be represented as <code>C₁₄ × C₂</code>, where the first group has order <code>m = 14</code> and the second group has order <code>n = 2</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; import Oscar: cyclic_group, small_group_identification, describe, order

julia&gt; import Hecke: gens, quo, group_algebra, GF, one, direct_product, sub

julia&gt; using QuantumClifford, QuantumClifford.ECC

julia&gt; m = 14; n = 2;

julia&gt; C₁₄ = cyclic_group(m);

julia&gt; C₂ = cyclic_group(n);

julia&gt; G = direct_product(C₁₄, C₂);

julia&gt; GA = group_algebra(GF(2), G);

julia&gt; x, s = gens(GA)[1], gens(GA)[3];

julia&gt; a = [one(GA), x^7];

julia&gt; b = [one(GA), x^7, s, x^8, s * x^7, x];

julia&gt; c = twobga_from_direct_product(a, b, GA);

julia&gt; order(G)
28

julia&gt; code_n(c), code_k(c)
(56, 28)

julia&gt; describe(G), small_group_identification(G)
(&quot;C14 x C2&quot;, (28, 4))</code></pre><div class="admonition is-danger" id="Danger-b4691122f7d248bb"><header class="admonition-header">Danger<a class="admonition-anchor" href="#Danger-b4691122f7d248bb" title="Permalink"></a></header><div class="admonition-body"><p>When using the direct product, there isn&#39;t necessarily a unique set of generators. It is essential to verify that Oscar is providing you with the generators you expect, e.g. for a cycling group that you have the presentation <code>Cₘ = ⟨x, s | xᵐ = s² = xsx⁻¹s⁻¹ = 1⟩</code>. For situations where the generators provided by Oscar are not the ones you want, you can also use <a href="#QuantumClifford.ECC.twobga_from_fp_group"><code>twobga_from_fp_group</code></a> where you specify the group presentation directly.</p></div></div><p>As a verification that you have the correct generators, <code>Oscar.sub</code> can be used to determine if <code>H</code> is a subgroup of <code>G</code> and to confirm that both <code>C₁₄</code> and <code>C₂</code> are subgroups of <code>C₂₈</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; order(gens(G)[1])
14

julia&gt; order(gens(G)[3])
2

julia&gt; x^14 == s^2 == x * s * x^-1 * s^-1
true

julia&gt; H, _  = sub(G, [gens(G)[1], gens(G)[3]]);

julia&gt; H == G
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordOscarExt/direct_product.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.twobga_from_fp_group-Tuple{Vector{Oscar.FPGroupElem}, Vector{Oscar.FPGroupElem}, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.FPGroup, Oscar.FPGroupElem}}" href="#QuantumClifford.ECC.twobga_from_fp_group-Tuple{Vector{Oscar.FPGroupElem}, Vector{Oscar.FPGroupElem}, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.FPGroup, Oscar.FPGroupElem}}"><code>QuantumClifford.ECC.twobga_from_fp_group</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">twobga_from_fp_group(
    a_elts::Vector{Oscar.FPGroupElem},
    b_elts::Vector{Oscar.FPGroupElem},
    F2G::Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.FPGroup, Oscar.FPGroupElem}
) -&gt; Any
</code></pre><p>Constructing two block group algebra codes by specifying the group presentation.</p><p>Two block group algebra codes are constructed by choosing a group (and specific generators), then choosing two polynomials made out of these generators, then piping these two polynomials as the elements of <code>1×1</code> matrices to the lifted product code constructors.</p><p>The Hecke library, for which we already have an extension, provides for a fairly easy way to construct such polynomials for many abelian and small groups. See <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a> for those capabilities.</p><p>However, more esoteric groups are usually specified by a group presentation <code>⟨S | R⟩</code>, where <code>S</code> is a set of generators and <code>R</code> is the relations those generators obey. To support arbitrary group presentations we use Oscar, which builds upon Hecke. We use <code>Oscar.free_group</code> and <code>quo</code> in order to first prepare the free group generated by <code>S</code>, and then the group obeying also the relations <code>R</code>, i.e. the <code>⟨S | R⟩</code> <a href="https://en.wikipedia.org/wiki/Presentation_of_a_group">presentation</a>.</p><p>After that point we proceed as usual, creating two polynomials of generators and piping them to <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>.</p><p>This particular function is nothing more than a simple wrapper that takes care of argument conversions. Of note, the polynomials here are given as lists of monomials.</p><p>Of course, if you are comfortable with Oscar, you can use <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a> directly.</p><p>See also: <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.twobga_from_direct_product"><code>twobga_from_direct_product</code></a></p><p><strong>Examples</strong></p><p>The [[96, 12, 10]] 2BGA code from Table I in (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>) has the group presentation <code>⟨r, s | s⁶ = r⁸ = r⁻¹srs = 1⟩</code> (the group <code>C₂ × (C₃ ⋉ C₈)</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; import Oscar: free_group, small_group_identification, describe, order

julia&gt; import Hecke: gens, quo, group_algebra, GF, one

julia&gt; using QuantumClifford, QuantumClifford.ECC

julia&gt; F = free_group([&quot;r&quot;, &quot;s&quot;]);

julia&gt; r, s = gens(F); # generators

julia&gt; G, = quo(F, [s^6, r^8, r^(-1) * s * r * s]);  # relations

julia&gt; GA = group_algebra(GF(2), G);

julia&gt; r, s = gens(G);

julia&gt; a = [one(G), r, s^3 * r^2, s^2 * r^3];

julia&gt; b = [one(G), r, s^4 * r^6, s^5 * r^3];

julia&gt; c = twobga_from_fp_group(a, b, GA);

julia&gt; order(G)
48

julia&gt; code_n(c), code_k(c)
(96, 12)

julia&gt; describe(G), small_group_identification(G)
(&quot;C2 x (C3 : C8)&quot;, (48, 9))</code></pre><p><strong>Cyclic Groups</strong></p><p>Cyclic groups with specific group presentations, given by <code>Cₘ = ⟨x, s | xᵐ = s² = xsx⁻¹s⁻¹ = 1⟩</code>, where the order is <code>2m</code> as seen in Table II of (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>).</p><p>The [[56, 28, 2]] abelian 2BGA code from Appendix C, Table II in (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>) is constructed using the group presentation <code>⟨x, s | xs = sx, xᵐ = s² = 1⟩</code> (the cyclic group <code>C₂₈ = C₁₄ × C₂</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; m = 14;

julia&gt; F = free_group([&quot;x&quot;, &quot;s&quot;]);

julia&gt; x, s = gens(F); # generators

julia&gt; G, = quo(F, [x^m, s^2, x * s * x^-1 * s^-1]); # relations

julia&gt; GA = group_algebra(GF(2), G);

julia&gt; x, s = gens(G);

julia&gt; a = [one(G), x^7];

julia&gt; b = [one(G), x^7, s, x^8, s * x^7, x];

julia&gt; c = twobga_from_fp_group(a, b, GA);

julia&gt; order(G)
28

julia&gt; code_n(c), code_k(c)
(56, 28)

julia&gt; describe(G), small_group_identification(G)
(&quot;C14 x C2&quot;, (28, 4))</code></pre><p><strong>Dihedral Groups</strong></p><p>Dihedral (non-abelian) groups with group presentations given by <code>Dₘ = ⟨r, s | rᵐ = s² = (rs)² = 1⟩</code>, where the order is <code>2m</code>.</p><p>The [[24, 8, 3]] 2BGA code from Appendix C, Table III in (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>) is constructed by specifying a group presentation below (giving the group <code>D₆ = C₆ ⋉ C₂</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; m = 6;

julia&gt; F = free_group([&quot;r&quot;, &quot;s&quot;]);

julia&gt; r, s = gens(F); # generators

julia&gt; G, = quo(F, [r^m, s^2, (r*s)^2]); # relations

julia&gt; GA = group_algebra(GF(2), G);

julia&gt; r, s = gens(G);

julia&gt; a = [one(G), r^4];

julia&gt; b = [one(G), s*r^4, r^3, r^4, s*r^2, r];

julia&gt; c = twobga_from_fp_group(a, b, GA);

julia&gt; order(G)
12

julia&gt; code_n(c), code_k(c)
(24, 8)

julia&gt; describe(G), small_group_identification(G)
(&quot;D12&quot;, (12, 4))</code></pre><div class="admonition is-info" id="Note-9792205551ac43e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-9792205551ac43e" title="Permalink"></a></header><div class="admonition-body"><p>Notice how in all of these construction we are specifying a group presentation. We are explicitly <strong>not</strong> picking a group by name and getting its &quot;canonical&quot; generators, as we do not a priori know whether Oscar would give us the generating set we need (generating sets are not unique).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordOscarExt/group_presentation.jl#L1">source</a></section></article><h2 id="Implemented-in-an-extension-requiring-JuMP.jl"><a class="docs-heading-anchor" href="#Implemented-in-an-extension-requiring-JuMP.jl">Implemented in an extension requiring <code>JuMP.jl</code></a><a id="Implemented-in-an-extension-requiring-JuMP.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Implemented-in-an-extension-requiring-JuMP.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.distance-Tuple{AbstractECC, DistanceMIPAlgorithm}" href="#QECCore.distance-Tuple{AbstractECC, DistanceMIPAlgorithm}"><code>QECCore.distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance(
    code::AbstractECC,
    alg::DistanceMIPAlgorithm
) -&gt; Any
</code></pre><p>Compute the distance of a code using mixed integer programming. See <a href="#QuantumClifford.ECC.DistanceMIPAlgorithm"><code>QuantumClifford.ECC.DistanceMIPAlgorithm</code></a> for configuration options.</p><p>Specifically, it computes the minimum distance of a Calderbank-Shor-Steane code by solving two independent <strong>Mixed Integer Programs</strong> for X-type (<span>$d_X$</span>) and Z-type (<span>$d_Z$</span>) distances. The code distance is <span>$d = \min(d_X, d_Z)$</span>.</p><p><strong>Background on Minimum Distance</strong></p><p>For <em>classical</em> codes, the minimum distance, which measures a code&#39;s error-correcting capability, is equivalent to its minimum weight. This can be computed by generating all possible codewords from combinations of the generator matrix rows, calculating their weights, and finding the smallest. While accurate, this method takes exponential time. Vardy (<a href="../references/#vardy1997intractability">Vardy, 1997</a>) demonstrated that computing the minimum distance is <em>NP-hard</em>, and the corresponding decision problem is <em>NP-complete</em>, making polynomial-time algorithms unlikely.</p><p>For <em>quantum</em> codes, classical intuition does not always apply. The minimum distance is given by the minimum weight of a non-trivial logical operator. This is generally unrelated to the minimum distance of the corresponding stabilizer code when viewed as a classical, additive code. White and Grassl (<a href="../references/#white2006new">White and Grassl, 2006</a>) proposed mapping quantum codes to higher-dimensional classical linear codes. This mapping allows the minimum distance of the quantum additive code to be inferred from that of the classical linear code but increases parameters from <code>n</code> to <code>3n</code> and <code>d</code> to <code>2d</code>, adding complexity. Furthermore, once a minimal weight vector is identified, it is essential to verify whether it belongs to the Pauli group <code>𝒫ₙ</code> over <code>n</code> qubits (<a href="../references/#Sabo_2022smk">Sabo, 2022</a>).</p><div class="admonition is-info" id="Note-c371603342d50d66"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c371603342d50d66" title="Permalink"></a></header><div class="admonition-body"><p>The minimum distance problem for quantum codes is <em>NP-hard</em>, and this hardness extends to multiplicative and additive approximations, even when restricted to stabilizer or CSS codes, with the result established through a reduction from classical problems in the CWS framework using a 4-cycle free graph (<a href="../references/#kapshikar2023hardness">Kapshikar and Kundu, 2023</a>). Despite this, methods that improve on brute-force approaches are actively explored.</p></div></div><p>For a more in-depth background on minimum distance, see Chapter 3 of (<a href="../references/#Sabo_2022smk">Sabo, 2022</a>).</p><p><strong>Quantum Error Correction and Code Distance</strong></p><p>The foundation of quantum error correction lies in protecting logical quantum information from physical errors by encoding it across multiple qubits. A quantum code&#39;s performance is fundamentally characterized by its distance (<code>d</code>), which quantifies the code&#39;s ability to detect and correct errors. Practically, the distance represents the minimum number of physical qubit errors required to cause an undetectable logical error - one that corrupts encoded information while evading the code&#39;s error detection mechanisms.</p><p><strong>Fundamentals of Quantum Code Distance</strong></p><p>The distance <code>d</code> of a quantum error-correcting code represents its robustness against physical errors and is defined as (<a href="../references/#qubitguide">Ekert <em>et al.</em>, undated</a>):</p><p class="math-container">\[\begin{aligned}
d = \min_{P \in N(S)\setminus S} \mathrm{wt}(P)
\end{aligned}\]</p><p>where:</p><ul><li><span>$N(S)$</span> denotes the <a href="https://en.wikipedia.org/wiki/Centralizer_and_normalizer">normalizer</a> of the stabilizer group <code>S</code>.</li><li><span>$\mathrm{wt}(P)$</span> represents the weight of Pauli operator P.</li><li>The minimization is taken over all logical operators that are not stabilizers.</li></ul><p>The distance reveals the essential property that it equals the smallest number of qubits that must be affected to produce a logical error undetectable by stabilizer measurements. The normalizer condition <span>$P \in N(S)$</span> ensures the operator commutes with all stabilizers, while <span>$P \notin S$</span> guarantees it performs a non-trivial logical operation (<a href="../references/#qubitguide">Ekert <em>et al.</em>, undated</a>).</p><p><strong>Mixed Integer Programming</strong></p><p>We compute the minimum code distance for CSS (Calderbank-Shor-Steane) codes by solving MIPs. </p><p>The distance is computed separately for X-type (<span>$d_X$</span>) and Z-type (<span>$d_Z$</span>) logical operators, then combined to give the true code distance: <span>$d = \min(d_X, d_Z)$</span>.</p><p><strong>X-type and Z-type Distances</strong></p><p>The X-type distance (<span>$d_X$</span>) and Z-type distance (<span>$d_Z$</span>) are defined as the minimum number of errors required to implement a non-trivial logical operator of the opposite type, subject to the following constraints: </p><ul><li>For <span>$d_X$</span> (where <span>$U = X$</span>), the errors are Z-type (phase flips), and the constraints involve the X-stabilizer matrix <span>$\mathbf{H_X}$</span> and X-logical operators <span>$\mathbf{L_X}$</span>. The error vector is denoted as <span>$\mathbf{e}_Z$</span>.</li><li>For <span>$d_Z$</span> (where <span>$U = Z$</span>), the errors are X-type (bit flips), with constraints given by the Z-stabilizer matrix <span>$\mathbf{H_Z}$</span> and Z-logical operators <span>$\mathbf{L_Z}$</span>, and the error vector is <span>$\mathbf{e}_X$</span>.  </li></ul><p class="math-container">\[\begin{aligned}
\text{Minimize} \quad &amp; \sum_{i=1}^n e_{V,i} \quad \text{(Hamming weight of errors)} \\
\text{Subject to} \quad &amp; \mathbf{H_U} \cdot \mathbf{e}_V \equiv \mathbf{0} \pmod{2} \quad \text{(Commutes with U-stabilizers)} \\
                      &amp; \mathbf{L_U} \cdot \mathbf{e}_V \equiv 1 \pmod{2} \quad \text{(Anti-commutes with U-logical)} \\
                      &amp; e_{V,i} \in \{0,1\} \quad \text{(Binary error variables)}
\end{aligned}\]</p><p><strong>Example</strong></p><p>A <code>[[40, 8, 5]]</code> 2BGA code with the minimum distance of <code>5</code> from Table 2 of (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; import HiGHS; import JuMP;

julia&gt; using QuantumClifford, QuantumClifford.ECC

julia&gt; l = 10; m = 2;

julia&gt; GA = group_algebra(GF(2), abelian_group([l,m]));

julia&gt; x, s = gens(GA);

julia&gt; A = 1 + x^6;

julia&gt; B = 1 + x^5 + s + x^6 + x + s*x^2;

julia&gt; c = two_block_group_algebra_codes(A,B);

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(40, 8, 5)</code></pre><p>A <code>[[48, 6, 8]]</code> GB code with the minimum distance of <code>8</code> from (A3) in Appendix B of (<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; l = 24;

julia&gt; c1 = generalized_bicycle_codes([0, 2, 8, 15], [0, 2, 12, 17], l);

julia&gt; code_n(c1), code_k(c1), distance(c1, DistanceMIPAlgorithm(solver=HiGHS))
(48, 6, 8)</code></pre><p><strong>Applications</strong></p><p>Mixed-integer programming (MIP) is applied in quantum error correction, notably for decoding and minimum distance computation. Some applications are as follows:</p><ul><li><p>The first usecase of the MIP approach was the code capacity Most Likely Error (MLE) decoder for color codes introduced in (<a href="../references/#landahl2011color">Landahl <em>et al.</em>, 2011</a>).</p></li><li><p>For all quantum LDPC codes presented in (<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>), the lower and upper bounds on the minimum distance was obtained by reduction to a mixed integer linear program and using the GNU Linear Programming Kit ((<a href="../references/#makhorin2008glpk">Makhorin, 2008</a>)).</p></li><li><p>For all the Bivariate Bicycle (BB) codes presented in (<a href="../references/#bravyi2024high">Bravyi <em>et al.</em>, 2024</a>), the code distance was calculated using the mixed integer programming approach.</p></li><li><p>(<a href="../references/#lacroix2024scaling">Lacroix <em>et al.</em>, 2024</a>) developed a MLE decoder that finds the most likely chain of Pauli errors given the observed error syndrome by solving a mixed-integer program using <code>HiGHS</code> package ((<a href="../references/#huangfu2018parallelizing">Huangfu and Hall, 2018</a>)).</p></li><li><p>(<a href="../references/#cain2025correlateddecodinglogicalalgorithms">Cain <em>et al.</em>, 2025</a>) formulate maximum-likelihood decoding as a mixed-integer program maximizing <span>$\prod_{j=1}^M p_j^{E_j}(1-p_j)^{1-E_j}$</span> (where binary variables <span>$E_j \in {0,1}$</span> indicate error occurrence) subject to syndrome constraints, solved optimally via MIP solvers despite its NP-hard complexity.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/38ca4c1a518bc41543b7a7632f8852225e12edd7/ext/QuantumCliffordJuMPExt/min_distance_mixed_integer_programming.jl#L1">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ECC_evaluating/">« Evaluating codes and decoders</a><a class="docs-footer-nextpage" href="../allops/">All Gates »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Thursday 30 October 2025 19:20">Thursday 30 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · QuantumClifford.jl</title><meta name="title" content="API · QuantumClifford.jl"/><meta property="og:title" content="API · QuantumClifford.jl"/><meta property="twitter:title" content="API · QuantumClifford.jl"/><meta name="description" content="Documentation for QuantumClifford.jl."/><meta property="og:description" content="Documentation for QuantumClifford.jl."/><meta property="twitter:description" content="Documentation for QuantumClifford.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumClifford.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">QuantumClifford.jl</a></li><li><span class="tocitem">Stabilizer Tableau Algebra</span><ul><li><a class="tocitem" href="../stab-algebra-manual/">Manual</a></li><li><a class="tocitem" href="../canonicalization/">Canonicalization</a></li><li><a class="tocitem" href="../mixed/">Mixed States</a></li><li><a class="tocitem" href="../graphs/">Graph States</a></li><li><a class="tocitem" href="../datastructures/">Datastructure Choice</a></li><li><a class="tocitem" href="../commonstates/">Useful States</a></li></ul></li><li><span class="tocitem">Noisy Circuits</span><ul><li><a class="tocitem" href="../noisycircuits/">Simulation of Noisy Circuits</a></li><li><a class="tocitem" href="../noisycircuits_mc/">Monte Carlo</a></li><li><a class="tocitem" href="../noisycircuits_perturb/">Perturbative Expansions</a></li><li><a class="tocitem" href="../ecc_example_sim/">ECC example</a></li><li><a class="tocitem" href="../noisycircuits_ops/">Circuit Operations</a></li><li><a class="tocitem" href="../noisycircuits_API/">API</a></li></ul></li><li><span class="tocitem">ECC compendium</span><ul><li><a class="tocitem" href="../ECC_evaluating/">Evaluating codes and decoders</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Implemented-in-an-extension-requiring-Hecke.jl"><span>Implemented in an extension requiring <code>Hecke.jl</code></span></a></li><li><a class="tocitem" href="#Implemented-in-an-extension-requiring-Oscar.jl"><span>Implemented in an extension requiring <code>Oscar.jl</code></span></a></li><li><a class="tocitem" href="#Implemented-in-an-extension-requiring-JuMP.jl"><span>Implemented in an extension requiring <code>JuMP.jl</code></span></a></li></ul></li></ul></li><li><a class="tocitem" href="../allops/">All Gates</a></li><li><a class="tocitem" href="../plotting/">Visualizations</a></li><li><a class="tocitem" href="../API/">API</a></li><li><a class="tocitem" href="../tutandpub/">Tutorials and Publications</a></li><li><a class="tocitem" href="../references/">Suggested Readings &amp; References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ECC compendium</a></li><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumSavory/QuantumClifford.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/master/docs/src/ECC_API.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Full-ECC-API-(autogenerated)"><a class="docs-heading-anchor" href="#Full-ECC-API-(autogenerated)">Full ECC API (autogenerated)</a><a id="Full-ECC-API-(autogenerated)-1"></a><a class="docs-heading-anchor-permalink" href="#Full-ECC-API-(autogenerated)" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.CircuitCode" href="#QuantumClifford.ECC.CircuitCode"><code>QuantumClifford.ECC.CircuitCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>CircuitCode</code> is defined by a given encoding circuit <code>circ</code>.</p><ul><li><code>n</code>: qubit number</li><li><code>circ</code>: the encoding circuit</li><li><code>encode_qubits</code>: the qubits to be encoded</li></ul><p>See also: <a href="#QuantumClifford.ECC.random_all_to_all_circuit_code"><code>random_all_to_all_circuit_code</code></a>, <a href="#QuantumClifford.ECC.random_brickwork_circuit_code"><code>random_brickwork_circuit_code</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/codes/random_circuit.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.CommutationCheckECCSetup" href="#QuantumClifford.ECC.CommutationCheckECCSetup"><code>QuantumClifford.ECC.CommutationCheckECCSetup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Configuration for ECC evaluator that does not simulate any ECC circuits, rather it simply checks the commutation of the parity check and the Pauli error.</p><p>This is much faster than any other simulation method, but it is incapable of noisy-circuit simulations and thus useless for fault-tolerance studies.</p><p>See also: <a href="#QuantumClifford.ECC.NaiveSyndromeECCSetup"><code>NaiveSyndromeECCSetup</code></a>, <a href="#QuantumClifford.ECC.ShorSyndromeECCSetup"><code>ShorSyndromeECCSetup</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/decoder_pipeline.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.Concat" href="#QuantumClifford.ECC.Concat"><code>QuantumClifford.ECC.Concat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Concat(c₁, c₂)</code> is a code concatenation of two quantum codes (<a href="../references/#knill1996concatenated">Knill and Laflamme, 1996</a>).</p><p>The inner code c₁ and the outer code c₂. The construction is the following: replace each qubit in code c₂ with logical qubits encoded by code c₁. The resulting code will have <code>n = n₁ × n₂</code> qubits and <code>k = k₁ × k₂</code> logical qubits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/codes/concat.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.DistanceMIPAlgorithm" href="#QuantumClifford.ECC.DistanceMIPAlgorithm"><code>QuantumClifford.ECC.DistanceMIPAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DistanceMIPAlgorithm &lt;: QECCore.AbstractDistanceAlg</code></pre><p>A Mixed Integer Programming (MIP) method for computing the code distance of CSS stabilizer codes by finding the minimum-weight non-trivial logical <a href="../API/#QuantumClifford.PauliOperator"><code>PauliOperator</code></a> (either <code>X</code>-type or <code>Z</code>-type). Used with <a href="#QECCore.distance-Tuple{QECCore.AbstractECC, QuantumClifford.ECC.DistanceMIPAlgorithm}"><code>distance</code></a> to select MIP as the method of finding the distance of a code.</p><div class="admonition is-info" id="Note-7ca4a67bd753bdc5"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-7ca4a67bd753bdc5" title="Permalink"></a></header><div class="admonition-body"><ul><li>Requires a <code>JuMP</code>-compatible MIP solver (e.g., <code>HiGHS</code>, <code>SCIP</code>).</li><li><code>X</code>-type and <code>Z</code>-type logical operators yield identical code distance results.</li><li>For stabilizer codes, the <code>X</code>-distance and <code>Z</code>-distance are equal.</li></ul></div></div><ul><li><p><code>logical_qubit</code>: index of the logical qubit to compute code distance for (nothing means compute for all logical qubits)</p></li><li><p><code>logical_operator_type</code>: type of logical operator to consider (:X or :Z, defaults to :X) - both types yield identical distance results for CSS stabilizer codes.</p></li><li><p><code>solver</code>: <code>JuMP</code>-compatible MIP solver (e.g., <code>HiGHS</code>, <code>SCIP</code>)</p></li><li><p><code>opt_summary</code>: when <code>true</code> (default=<code>false</code>), prints the MIP solver&#39;s solution summary</p></li><li><p><code>time_limit</code>: time limit (in seconds) for the MIP solver&#39;s execution (default=60.0)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/ECC.jl#L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.Gottesman" href="#QuantumClifford.ECC.Gottesman"><code>QuantumClifford.ECC.Gottesman</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The family of <code>[[2ʲ, 2ʲ - j - 2, 3]]</code> Gottesman codes, also known as quantum Hamming codes, as described in <a href="../references/#gottesman1997stabilizer">Gottesman&#39;s 1997 PhD thesis</a> and in (<a href="../references/#gottesman1996class">Gottesman, 1996</a>).</p><p>You might be interested in consulting (<a href="../references/#yu2013all">Yu <em>et al.</em>, 2013</a>) and (<a href="../references/#chao2018quantum">Chao and Reichardt, 2017</a>) as well.</p><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/quantum_hamming">entry for this family</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/codes/gottesman.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.NaiveSyndromeECCSetup" href="#QuantumClifford.ECC.NaiveSyndromeECCSetup"><code>QuantumClifford.ECC.NaiveSyndromeECCSetup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Configuration for ECC evaluator that runs the simplest syndrome measurement circuit.</p><p>The circuit is being simulated (as opposed to doing only a quick commutation check). This circuit would give poor performance if there is non-zero gate noise.</p><p>See also: <a href="#QuantumClifford.ECC.CommutationCheckECCSetup"><code>CommutationCheckECCSetup</code></a>, <a href="#QuantumClifford.ECC.ShorSyndromeECCSetup"><code>ShorSyndromeECCSetup</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/decoder_pipeline.jl#L46-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.QuantumReedMuller" href="#QuantumClifford.ECC.QuantumReedMuller"><code>QuantumClifford.ECC.QuantumReedMuller</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The family of <code>[[2ᵐ - 1, 1, 3]]</code> CSS Quantum-Reed-Muller codes, as discovered by Steane in his 1999 paper (<a href="../references/#steane1999quantum">Steane, 1999</a>).</p><p>Quantum codes are constructed from shortened Reed-Muller codes <code>RM(1, m)</code>, by removing the first row and column of the generator matrix <code>Gₘ</code>. Similarly, we can define truncated dual codes <code>RM(m - 2, m)</code> using the generator matrix <code>Hₘ</code> (<a href="../references/#anderson2014fault">Anderson <em>et al.</em>, 2014</a>). The quantum Reed-Muller codes <code>QRM(m)</code> derived from <code>RM(1, m)</code> are CSS codes. </p><p>Given that the stabilizers of the quantum code are defined through the generator matrix of the classical code, the minimum distance of the quantum code corresponds to the minimum distance of the dual classical code, which is <code>d = 3</code>, thus it can correct any single qubit error. Since one stabilizer from the original and one from the dual code are removed in the truncation process, the code parameters are <code>[[2ᵐ - 1, 1, 3]]</code>.</p><p>You might be interested in consulting (<a href="../references/#anderson2014fault">Anderson <em>et al.</em>, 2014</a>) and (<a href="../references/#campbell2012magic">Campbell <em>et al.</em>, 2012</a>) as well.</p><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/quantum_reed_muller">entry for this family</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/codes/quantumreedmuller.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.ShorSyndromeECCSetup" href="#QuantumClifford.ECC.ShorSyndromeECCSetup"><code>QuantumClifford.ECC.ShorSyndromeECCSetup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Configuration for ECC evaluators that simulate the Shor-style syndrome measurement (without a flag qubit).</p><p>The simulated circuit includes:</p><ul><li>perfect noiseless encoding (encoding and its fault tolerance are not being studied here)</li><li>one round of &quot;memory noise&quot; after the encoding but before the syndrome measurement</li><li>perfect preparation of entangled ancillary qubits</li><li>noisy Shor-style syndrome measurement (only two-qubit gate noise)</li><li>noiseless &quot;logical state measurement&quot; (providing the comparison data when evaluating the decoder)</li></ul><p>See also: <a href="#QuantumClifford.ECC.CommutationCheckECCSetup"><code>CommutationCheckECCSetup</code></a>, <a href="#QuantumClifford.ECC.NaiveSyndromeECCSetup"><code>NaiveSyndromeECCSetup</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/decoder_pipeline.jl#L62-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.TableDecoder" href="#QuantumClifford.ECC.TableDecoder"><code>QuantumClifford.ECC.TableDecoder</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A simple look-up table decoder for error correcting codes.</p><p>The lookup table contains only weight=1 errors, thus it is small, but at best it provides only for distance=3 decoding.</p><p>The size of the lookup table would grow exponentially quickly for higher distances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/decoder_pipeline.jl#L210-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.Triangular488" href="#QuantumClifford.ECC.Triangular488"><code>QuantumClifford.ECC.Triangular488</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Triangular code following the 4.8.8 tiling. Constructor take a distance d as input.</p><p><strong>Example</strong></p><p>Here is <code>[[17,1, 5]]</code> color code following the <code>4.8.8</code> tiling:</p><pre><code class="language-julia-repl hljs">julia&gt; import HiGHS; import JuMP; # hide

julia&gt; using QuantumClifford.ECC: Triangular666, DistanceMIPAlgorithm; # hide

julia&gt; c = Triangular488(5);

julia&gt; code = Stabilizer(c)
+ XXXX_____________
+ X_X_XX___________
+ __XX_XX__XX__XX__
+ ____XX__XX_______
+ ______XX__XX_____
+ _______X___X___XX
+ ________XX__XX___
+ __________XX__XX_
+ ZZZZ_____________
+ Z_Z_ZZ___________
+ __ZZ_ZZ__ZZ__ZZ__
+ ____ZZ__ZZ_______
+ ______ZZ__ZZ_____
+ _______Z___Z___ZZ
+ ________ZZ__ZZ___
+ __________ZZ__ZZ_

julia&gt; distance(c, DistanceMIPAlgorithm(solver=HiGHS))
5</code></pre><p>More information can be seen in (<a href="../references/#landahl2011color">Landahl <em>et al.</em>, 2011</a>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/codes/color_codes.jl#L6-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.Triangular666" href="#QuantumClifford.ECC.Triangular666"><code>QuantumClifford.ECC.Triangular666</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Triangular code following the 6.6.6 tiling. Constructor take a distance d as input.</p><p><strong>Example</strong></p><p>Here is <code>[[19,1, 5]]</code> color code following the <code>6.6.6</code> tiling:</p><pre><code class="language-julia-repl hljs">julia&gt; import HiGHS; import JuMP; # hide

julia&gt; using QuantumClifford.ECC: Triangular666, DistanceMIPAlgorithm; # hide

julia&gt; c = Triangular666(5);

julia&gt; code = Stabilizer(c)
+ XXXX_______________
+ _X_X_XX____________
+ __XXXX_XX__________
+ ____X__X__XX_______
+ _________X___X___XX
+ _____XX_XX__XX_____
+ _______XX__XX__XX__
+ __________XX__XX___
+ ____________XX__XX_
+ ZZZZ_______________
+ _Z_Z_ZZ____________
+ __ZZZZ_ZZ__________
+ ____Z__Z__ZZ_______
+ _________Z___Z___ZZ
+ _____ZZ_ZZ__ZZ_____
+ _______ZZ__ZZ__ZZ__
+ __________ZZ__ZZ___
+ ____________ZZ__ZZ_

julia&gt; distance(c, DistanceMIPAlgorithm(solver=HiGHS))
5</code></pre><p>More information can be seen in (<a href="../references/#landahl2011color">Landahl <em>et al.</em>, 2011</a>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/codes/color_codes.jl#L54-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.code_k-Tuple{Stabilizer}" href="#QECCore.code_k-Tuple{Stabilizer}"><code>QECCore.code_k</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The number of logical qubits in a code.</p><p>Note that when redundant rows exist in the parity check matrix, the number of logical qubits <code>code_k(c)</code> will be greater than <code>code_n(c) - code_s(c)</code>, where the difference equals the redundancy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/ECC.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.parity_matrix_x-Tuple{QECCore.AbstractECC}" href="#QECCore.parity_matrix_x-Tuple{QECCore.AbstractECC}"><code>QECCore.parity_matrix_x</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parity check boolean matrix of a code (only the X entries in the tableau, i.e. the checks for Z errors).</p><p>Only CSS codes have this method.</p><p>See also: <a href="#QuantumClifford.ECC.parity_checks"><code>parity_checks</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/ECC.jl#L46-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.parity_matrix_z-Tuple{QECCore.AbstractECC}" href="#QECCore.parity_matrix_z-Tuple{QECCore.AbstractECC}"><code>QECCore.parity_matrix_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parity check boolean matrix of a code (only the Z entries in the tableau, i.e. the checks for X errors).</p><p>Only CSS codes have this method.</p><p>See also: <a href="#QuantumClifford.ECC.parity_checks"><code>parity_checks</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/ECC.jl#L55-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.BeliefPropDecoder-Tuple" href="#QuantumClifford.ECC.BeliefPropDecoder-Tuple"><code>QuantumClifford.ECC.BeliefPropDecoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A simple Belief Propagation decoder built around tools from <code>LDPCDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/decoder_pipeline.jl#L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.BitFlipDecoder-Tuple" href="#QuantumClifford.ECC.BitFlipDecoder-Tuple"><code>QuantumClifford.ECC.BitFlipDecoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>An Iterative Bitflip decoder built around tools from <code>LDPCDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/decoder_pipeline.jl#L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.LPCode-Tuple" href="#QuantumClifford.ECC.LPCode-Tuple"><code>QuantumClifford.ECC.LPCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Lifted product codes ((<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>), (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>))</p><p>Implemented as a package extension with Hecke. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/codes/lifted_product.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.LiftedCode-Tuple" href="#QuantumClifford.ECC.LiftedCode-Tuple"><code>QuantumClifford.ECC.LiftedCode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Classical codes lifted over a group algebra, used for lifted product code construction ((<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>), (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>))</p><p>Implemented as a package extension with Hecke. Check the <a href="http://qc.quantumsavory.org/stable/ECC_API/">QuantumClifford documentation</a> for more details on that extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/codes/classical/lifted.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.PyBeliefPropDecoder-Tuple" href="#QuantumClifford.ECC.PyBeliefPropDecoder-Tuple"><code>QuantumClifford.ECC.PyBeliefPropDecoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A Belief Propagation decoder built around tools from the python package <code>ldpc</code> available from the julia package <code>PyQDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/decoder_pipeline.jl#L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.PyBeliefPropOSDecoder-Tuple" href="#QuantumClifford.ECC.PyBeliefPropOSDecoder-Tuple"><code>QuantumClifford.ECC.PyBeliefPropOSDecoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A Belief Propagation decoder with ordered statistics decoding, built around tools from the python package <code>ldpc</code> available from the julia package <code>PyQDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/decoder_pipeline.jl#L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.PyMatchingDecoder-Tuple" href="#QuantumClifford.ECC.PyMatchingDecoder-Tuple"><code>QuantumClifford.ECC.PyMatchingDecoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A perfect matching decoder built around tools from the python package <code>pymatching</code> available from the julia package <code>PyQDecoders.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/decoder_pipeline.jl#L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.bicycle_codes" href="#QuantumClifford.ECC.bicycle_codes"><code>QuantumClifford.ECC.bicycle_codes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Hecke. Check the docs for the <a href="http://qc.quantumsavory.org/stable/ECC_API/#Implemented-in-an-extension-requiring-Hecke.jl">Hecke extension</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/codes/lifted_product.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, QuantumClifford.ECC.AbstractECCSetup, Int64}" href="#QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, QuantumClifford.ECC.AbstractECCSetup, Int64}"><code>QuantumClifford.ECC.evaluate_decoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Evaluate the performance of a given decoder (e.g. <a href="#QuantumClifford.ECC.TableDecoder"><code>TableDecoder</code></a>) and a given style of running an ECC code (e.g. <a href="#QuantumClifford.ECC.ShorSyndromeECCSetup"><code>ShorSyndromeECCSetup</code></a>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/decoder_pipeline.jl#L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, Vararg{Any, 5}}" href="#QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, Vararg{Any, 5}}"><code>QuantumClifford.ECC.evaluate_decoder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Evaluate the performance of an error-correcting circuit.</p><p>This method requires you give the circuit that performs both syndrome measurements and (probably noiseless) logical state measurements. The faults matrix that translates an error vector into corresponding logical errors is necessary as well.</p><p>This is a relatively barebones method that assumes the user prepares necessary circuits, etc. It is a method that is used internally by more user-frienly methods providing automatic conversion of codes and noise models to the necessary noisy circuits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/decoder_pipeline.jl#L154-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.faults_matrix-Tuple{Stabilizer}" href="#QuantumClifford.ECC.faults_matrix-Tuple{Stabilizer}"><code>QuantumClifford.ECC.faults_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Error-to-logical-observable map (a.k.a. fault matrix) of a code.</p><p>For a code with n physical qubits and k logical qubits this function returns a 2k × 2n binary matrix O such that <code>O[i,j]</code> is true if the logical observable of index <code>i</code> is flipped by the single physical qubit error of index <code>j</code>. Indexing is such that:</p><ul><li><code>O[1:k,:]</code> is the error-to-logical-X-observable map (logical X observable, i.e. triggered by logical Z errors)</li><li><code>O[k+1:2k,:]</code> is the error-to-logical-Z-observable map</li><li><code>O[:,1:n]</code> is the X-physical-error-to-logical-observable map</li><li><code>O[n+1:2n,:]</code> is the Z-physical-error-to-logical-observable map</li></ul><p>E.g. for <code>k=1</code>, <code>n=10</code>, then if <code>O[2,5]</code> is true, then the logical Z observable is flipped by a X₅ error; and if <code>O[1,12]</code> is true, then the logical X observable is flipped by a Z₂ error.</p><p>Of note is that there is a lot of freedom in choosing the logical operations! A logical operator multiplied by a stabilizer operator is still a logical operator. Similarly there is a different fault matrix for each choice of logical operators. But once the logical operators are picked, the fault matrix is fixed.</p><p>Below we show an example that uses the Shor code. While it is not the smallest code, it is a convenient choice to showcase the importance of the fault matrix when dealing with degenerate codes where a correction operation and an error do not need to be the same.</p><p>First, consider a single-qubit error, potential correction operations, and their effect on the Shor code:</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford.ECC: faults_matrix, Shor9

julia&gt; state = MixedDestabilizer(Shor9())
𝒟ℯ𝓈𝓉𝒶𝒷━━━━━
+ Z________
+ ___Z_____
+ _X_______
+ __X______
+ ____X____
+ _____X___
+ ______X__
+ _______X_
𝒳ₗ━━━━━━━━━
+ ______XXX
𝒮𝓉𝒶𝒷━━━━━━━
+ XXX___XXX
+ ___XXXXXX
+ ZZ_______
+ Z_Z______
+ ___ZZ____
+ ___Z_Z___
+ ______Z_Z
+ _______ZZ
𝒵ₗ━━━━━━━━━
+ Z__Z____Z

julia&gt; err_Z₁ = single_z(9,1) # the error we will simulate
+ Z________

julia&gt; cor_Z₂ = single_z(9,2) # the correction operation we will perform
+ _Z_______

julia&gt; err_Z₁ * state # observe that one of the syndrome bits is now flipped
𝒟ℯ𝓈𝓉𝒶𝒷━━━━━
+ Z________
+ ___Z_____
+ _X_______
+ __X______
+ ____X____
+ _____X___
+ ______X__
+ _______X_
𝒳ₗ━━━━━━━━━
+ ______XXX
𝒮𝓉𝒶𝒷━━━━━━━
- XXX___XXX
+ ___XXXXXX
+ ZZ_______
+ Z_Z______
+ ___ZZ____
+ ___Z_Z___
+ ______Z_Z
+ _______ZZ
𝒵ₗ━━━━━━━━━
+ Z__Z____Z

julia&gt; cor_Z₂ * err_Z₁ * state # we are back to a good code state
𝒟ℯ𝓈𝓉𝒶𝒷━━━━━
+ Z________
+ ___Z_____
- _X_______
+ __X______
+ ____X____
+ _____X___
+ ______X__
+ _______X_
𝒳ₗ━━━━━━━━━
+ ______XXX
𝒮𝓉𝒶𝒷━━━━━━━
+ XXX___XXX
+ ___XXXXXX
+ ZZ_______
+ Z_Z______
+ ___ZZ____
+ ___Z_Z___
+ ______Z_Z
+ _______ZZ
𝒵ₗ━━━━━━━━━
+ Z__Z____Z

julia&gt; bad_Z₆Z₉ = single_z(9,6) * single_z(9,9) # a different &quot;correction&quot; operation
+ _____Z__Z

julia&gt; bad_Z₆Z₉ * err_Z₁ * state # the syndrome is trivial, but now we have a logical error
𝒟ℯ𝓈𝓉𝒶𝒷━━━━━
+ Z________
+ ___Z_____
+ _X_______
+ __X______
+ ____X____
- _____X___
+ ______X__
+ _______X_
𝒳ₗ━━━━━━━━━
- ______XXX
𝒮𝓉𝒶𝒷━━━━━━━
+ XXX___XXX
+ ___XXXXXX
+ ZZ_______
+ Z_Z______
+ ___ZZ____
+ ___Z_Z___
+ ______Z_Z
+ _______ZZ
𝒵ₗ━━━━━━━━━
+ Z__Z____Z</code></pre><p>The success of <code>cor_Z₂</code> and the failure of <code>bad_Z₆Z₉</code> can be immediately seen through the fault matrix, as the wrong &quot;correction&quot; does not result in the same logical flips ad the error:</p><pre><code class="language-julia-repl hljs">julia&gt; O = faults_matrix(Shor9())
2×18 BitMatrix:
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1
 1  0  0  1  0  0  0  0  1  0  0  0  0  0  0  0  0  0

julia&gt; O * stab_to_gf2(err_Z₁)
2-element Vector{Int64}:
 0
 0

julia&gt; O * stab_to_gf2(cor_Z₂)
2-element Vector{Int64}:
 0
 0

julia&gt; O * stab_to_gf2(bad_Z₆Z₉)
2-element Vector{Int64}:
 1
 0</code></pre><p>While its use in this situation is rather contrived, the fault matrix is incredibly useful when running large scale simulations in which we want a separate fast error sampling process, (e.g. with Pauli frames) and a syndrome decoding process, without coupling between them. We just gather all our syndrome measurement <strong>and logical observables</strong> from the Pauli frame simulations, and then use them with the fault matrix in the syndrome decoding simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/ECC.jl#L162-L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.generalized_bicycle_codes" href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>QuantumClifford.ECC.generalized_bicycle_codes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Hecke. Check the docs for the <a href="http://qc.quantumsavory.org/stable/ECC_API/#Implemented-in-an-extension-requiring-Hecke.jl">Hecke extension</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/codes/lifted_product.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.haah_cubic_codes" href="#QuantumClifford.ECC.haah_cubic_codes"><code>QuantumClifford.ECC.haah_cubic_codes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Hecke. Check the docs for the <a href="http://qc.quantumsavory.org/stable/ECC_API/#Implemented-in-an-extension-requiring-Hecke.jl">Hecke extension</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/codes/lifted_product.jl#L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.iscss-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:QECCore.AbstractECC" href="#QuantumClifford.ECC.iscss-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:QECCore.AbstractECC"><code>QuantumClifford.ECC.iscss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Check if the code is CSS.</p><p>Return <code>nothing</code> if unknown from the type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/ECC.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.isdegenerate" href="#QuantumClifford.ECC.isdegenerate"><code>QuantumClifford.ECC.isdegenerate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Check if the code is degenerate with respect to a given set of error or with respect to all &quot;up to d physical-qubit&quot; errors (defaulting to d=1).</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford.ECC

julia&gt; isdegenerate(Shor9(), [single_z(9,1), single_z(9,2)])
true

julia&gt; isdegenerate(Shor9(), [single_z(9,1), single_x(9,1)])
false

julia&gt; isdegenerate(Steane7(), 1)
false

julia&gt; isdegenerate(Steane7(), 2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/ECC.jl#L349">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.naive_encoding_circuit-Tuple{Any}" href="#QuantumClifford.ECC.naive_encoding_circuit-Tuple{Any}"><code>QuantumClifford.ECC.naive_encoding_circuit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Encoding physical qubits into a larger logical code.</p><p>The initial physical qubits to be encoded have to be at indices <code>n-k+1:n</code>.</p><div class="admonition is-info" id="Encoding-circuits-are-not-fault-tolerant-b464ac5e2ecb3c3c"><header class="admonition-header">Encoding circuits are not fault-tolerant<a class="admonition-anchor" href="#Encoding-circuits-are-not-fault-tolerant-b464ac5e2ecb3c3c" title="Permalink"></a></header><div class="admonition-body"><p>Encoding circuits are not fault-tolerant, and thus should not be used in practice. Instead, you should measure the stabilizers of the code and the logical observables, thus projecting into the code space (which can be fault-tolerant).</p></div></div><p>The canonicalization operation performed on the code may permute the qubits (see <a href="../API/#QuantumClifford.canonicalize_gott!-Tuple{Stabilizer}"><code>canonicalize_gott!</code></a>). That permutation is corrected for with SWAP gates by default (controlled by the <code>undoperm</code> keyword argument).</p><p>Based on (<a href="../references/#cleve1997efficient">Cleve and Gottesman, 1997</a>) and (<a href="../references/#gottesman1997stabilizer">Gottesman, 1997</a>), however it seems the published algorithm has some errors. Consult the erratum, as well as the more recent (<a href="../references/#grassl2002algorithmic">Grassl, 2002</a>) and (<a href="../references/#grassl2011variations">Grassl, 2011</a>), and be aware that this implementation also uses H instead of Z gates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/circuits.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.naive_syndrome_circuit" href="#QuantumClifford.ECC.naive_syndrome_circuit"><code>QuantumClifford.ECC.naive_syndrome_circuit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Generate the non-fault-tolerant stabilizer measurement cicuit for a given code instance or parity check tableau.</p><p>Use the <code>ancillary_index</code> and <code>bit_index</code> arguments to offset where the corresponding part the circuit starts.</p><p>Returns the circuit, the number of ancillary qubits that were added, and a list of bit indices that will store the measurement results.</p><p>See also: <a href="#QuantumClifford.ECC.shor_syndrome_circuit"><code>shor_syndrome_circuit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/circuits.jl#L85-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.parity_checks" href="#QuantumClifford.ECC.parity_checks"><code>QuantumClifford.ECC.parity_checks</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parity check tableau of a code.</p><p>See also: <a href="#QECCore.parity_matrix_x-Tuple{QECCore.AbstractECC}"><code>parity_matrix_x</code></a> and <a href="#QECCore.parity_matrix_z-Tuple{QECCore.AbstractECC}"><code>parity_matrix_z</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/ECC.jl#L41-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.random_all_to_all_circuit_code" href="#QuantumClifford.ECC.random_all_to_all_circuit_code"><code>QuantumClifford.ECC.random_all_to_all_circuit_code</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Random all-to-all Clifford circuit code (<a href="../references/#brown2013short">Brown and Fawzi, Jul 2013</a>).</p><p>The code of <code>n</code> qubits is generated by an all-to-all random Clifford circuit of <code>ngates</code> gates that encodes a subset of qubits <code>encode_qubits</code> into logical qubits.</p><p>Because of the random picking, the size of <code>encode_qubits</code> is the only thing that matters for the code, referred to as <code>k</code>.</p><p>See also: <a href="../API/#QuantumClifford.random_all_to_all_clifford_circuit-Tuple{Random.AbstractRNG, Int64, Int64}"><code>random_all_to_all_clifford_circuit</code></a>, <a href="#QuantumClifford.ECC.CircuitCode"><code>CircuitCode</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/codes/random_circuit.jl#L34-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.random_brickwork_circuit_code" href="#QuantumClifford.ECC.random_brickwork_circuit_code"><code>QuantumClifford.ECC.random_brickwork_circuit_code</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Random brickwork Clifford circuit code (<a href="../references/#brown2013short">Brown and Fawzi, Jul 2013</a>).</p><p>The code is generated by a brickwork random Clifford circuit of <code>nlayers</code> layers that encodes a subset of qubits <code>encode_qubits</code> into logical qubits.</p><p>See also: <a href="../API/#QuantumClifford.random_brickwork_clifford_circuit-Tuple{Random.AbstractRNG, NTuple{N, Int64} where N, Int64}"><code>random_brickwork_clifford_circuit</code></a>, <a href="#QuantumClifford.ECC.CircuitCode"><code>CircuitCode</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/codes/random_circuit.jl#L62-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.shor_syndrome_circuit" href="#QuantumClifford.ECC.shor_syndrome_circuit"><code>QuantumClifford.ECC.shor_syndrome_circuit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Generate the Shor fault-tolerant stabilizer measurement cicuit for a given code instance or parity check tableau.</p><p>Use the <code>ancillary_index</code> and <code>bit_index</code> arguments to offset where the corresponding part the circuit starts. Ancillary qubits</p><p>Returns:</p><ul><li>The ancillary cat state preparation circuit.</li><li>The Shor syndrome measurement circuit.</li><li>The number of ancillary qubits that were added.</li><li>The list of bit indices that store the final measurement results.</li></ul><p>See also: <a href="#QuantumClifford.ECC.naive_syndrome_circuit"><code>naive_syndrome_circuit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/circuits.jl#L140-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.two_block_group_algebra_codes" href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>QuantumClifford.ECC.two_block_group_algebra_codes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Hecke. Check the docs for the <a href="http://qc.quantumsavory.org/stable/ECC_API/#Implemented-in-an-extension-requiring-Hecke.jl">Hecke extension</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/codes/lifted_product.jl#L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.twobga_from_direct_product" href="#QuantumClifford.ECC.twobga_from_direct_product"><code>QuantumClifford.ECC.twobga_from_direct_product</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Oscar. Check the docs for the <a href="http://qc.quantumsavory.org/stable/ECC_API/#Implemented-in-an-extension-requiring-Oscar.jl">Oscar extension</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/codes/lifted_product.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.twobga_from_fp_group" href="#QuantumClifford.ECC.twobga_from_fp_group"><code>QuantumClifford.ECC.twobga_from_fp_group</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implemented in a package extension with Oscar. Check the docs for the <a href="http://qc.quantumsavory.org/stable/ECC_API/#Implemented-in-an-extension-requiring-Oscar.jl">Oscar extension</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/src/ecc/codes/lifted_product.jl#L27">source</a></section></article><h2 id="Implemented-in-an-extension-requiring-Hecke.jl"><a class="docs-heading-anchor" href="#Implemented-in-an-extension-requiring-Hecke.jl">Implemented in an extension requiring <code>Hecke.jl</code></a><a id="Implemented-in-an-extension-requiring-Hecke.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Implemented-in-an-extension-requiring-Hecke.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordHeckeExt.LPCode" href="#QuantumCliffordHeckeExt.LPCode"><code>QuantumCliffordHeckeExt.LPCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LPCode &lt;: QECCore.AbstractECC</code></pre><p>Lifted product codes ((<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>), (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>))</p><p>A lifted product code is defined by the hypergraph product of a base matrices <code>A</code> and the conjugate of another base matrix <code>B&#39;</code>. Here, the hypergraph product is taken over a group algebra, of which the base matrices are consisting.</p><p>The binary parity check matrix is obtained by applying <code>repr</code> to each element of the matrix resulted from the hypergraph product, which is mathematically a linear map from each group algebra element to a binary matrix.</p><p><strong>Constructors</strong></p><p>Multiple constructors are available:</p><ol><li><p>Two base matrices of group algebra elements.</p></li><li><p>Two lifted codes, whose base matrices are for quantum code construction.</p></li><li><p>Two base matrices of group elements, where each group element will be considered as a group algebra element by assigning a unit coefficient.</p></li><li><p>Two base matrices of integers, where each integer represent the shift of a cyclic permutation. The order of the cyclic permutation should be specified.</p></li></ol><p>Below is a list of all constructors:</p><pre><code class="language-julia hljs">LPCode(A, B; GA, repr)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7//ext/QuantumCliffordHeckeExt/lifted_product.jl#L105"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted_product.jl:105</code></a>.</p><pre><code class="language-julia hljs">LPCode(c₁, c₂; GA, repr)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7//ext/QuantumCliffordHeckeExt/lifted_product.jl#L112"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted_product.jl:112</code></a>.</p><pre><code class="language-julia hljs">LPCode(A, B; GA)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7//ext/QuantumCliffordHeckeExt/lifted_product.jl#L122"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted_product.jl:122</code></a>.</p><pre><code class="language-julia hljs">LPCode(group_elem_array1, group_elem_array2; GA)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7//ext/QuantumCliffordHeckeExt/lifted_product.jl#L127"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted_product.jl:127</code></a>.</p><pre><code class="language-julia hljs">LPCode(shift_array1, shift_array2, l; GA)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7//ext/QuantumCliffordHeckeExt/lifted_product.jl#L132"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted_product.jl:132</code></a>.</p><p><strong>Examples</strong></p><p>A [[882, 24, d ≤ 24]] code from Appendix B of (<a href="../references/#roffe2023bias">Roffe <em>et al.</em>, 2023</a>). We use the 1st constructor to generate the code and check its length and dimension. During the construction, we do arithmetic operations to get the group algebra elements in base matrices <code>A</code> and <code>B</code>. Here <code>x</code> is the generator of the group algebra, i.e., offset-1 cyclic permutation, and <code>GA(1)</code> is the unit element.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; import LinearAlgebra: diagind; using QuantumClifford.ECC;

julia&gt; l = 63; GA = group_algebra(GF(2), abelian_group(l)); x = gens(GA)[];

julia&gt; A = zeros(GA, 7, 7);

julia&gt; A[diagind(A)] .= x^27;

julia&gt; A[diagind(A, -1)] .= x^54;

julia&gt; A[diagind(A, 6)] .= x^54;

julia&gt; A[diagind(A, -2)] .= GA(1);

julia&gt; A[diagind(A, 5)] .= GA(1);

julia&gt; B = reshape([1 + x + x^6], (1, 1));

julia&gt; c1 = LPCode(A, B);

julia&gt; code_n(c1), code_k(c1)
(882, 24)</code></pre><p>A [[175, 19, d ≤ 10]] code from Eq. (18) in Appendix A of (<a href="../references/#raveendran2022finite">Raveendran <em>et al.</em>, 2022</a>), following the 4th constructor.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke; using QuantumClifford.ECC;

julia&gt; base_matrix = [0 0 0 0; 0 1 2 5; 0 6 3 1]; l = 7;

julia&gt; c2 = LPCode(base_matrix, l .- base_matrix&#39;, l);

julia&gt; code_n(c2), code_k(c2)
(175, 19)</code></pre><p><strong>Code subfamilies and convenience constructors for them</strong></p><ul><li>When the base matrices of the <code>LPCode</code> are 1×1, the code is called a two-block group-algebra code <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>.</li><li>When the base matrices of the <code>LPCode</code> are 1×1 and their elements are sums of cyclic permutations, the code is called a generalized bicycle code <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>.</li><li>When the two matrices are adjoint to each other, the code is called a bicycle code <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>.</li></ul><p><strong>The representation function</strong></p><p>We use the default representation function <code>Hecke.representation_matrix</code> to convert a <code>GF(2)</code>-group algebra element to a binary matrix. The default representation, provided by <code>Hecke</code>, is the permutation representation.</p><p>We also accept a custom representation function as detailed in <a href="#QuantumCliffordHeckeExt.LiftedCode"><code>LiftedCode</code></a>.</p><p>See also: <a href="#QuantumCliffordHeckeExt.LiftedCode"><code>LiftedCode</code></a>, <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.haah_cubic_codes"><code>haah_cubic_codes</code></a>.</p><p>All fields:</p><ul><li><p><code>A::Union{LinearAlgebra.Adjoint{&lt;:Hecke.GroupAlgebraElem, &lt;:Matrix{&lt;:Hecke.GroupAlgebraElem}}, Matrix{&lt;:Hecke.GroupAlgebraElem}}</code>: the first base matrix of the code, whose elements are in a group algebra.</p></li><li><p><code>B::Union{LinearAlgebra.Adjoint{&lt;:Hecke.GroupAlgebraElem, &lt;:Matrix{&lt;:Hecke.GroupAlgebraElem}}, Matrix{&lt;:Hecke.GroupAlgebraElem}}</code>: the second base matrix of the code, whose elements are in the same group algebra as <code>A</code>.</p></li><li><p><code>GA::Hecke.GroupAlgebra</code>: the group algebra for which elements in <code>A</code> and <code>B</code> are from.</p></li><li><p><code>repr::Function</code>: a function that converts a group algebra element to a binary matrix; default to be the permutation representation for GF(2)-algebra.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/ext/QuantumCliffordHeckeExt/lifted_product.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumCliffordHeckeExt.LiftedCode" href="#QuantumCliffordHeckeExt.LiftedCode"><code>QuantumCliffordHeckeExt.LiftedCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LiftedCode &lt;: QECCore.AbstractCECC</code></pre><p>Classical codes lifted over a group algebra, used for lifted product code construction ((<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>), (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>))</p><p>The parity-check matrix is constructed by applying <code>repr</code> to each element of <code>A</code>, which is mathematically a linear map from a group algebra element to a binary matrix. The size of the parity check matrix will enlarged with each element of <code>A</code> being inflated into a matrix. The procedure is called a lift (<a href="../references/#panteleev2022asymptotically">Panteleev and Kalachev, Jun 2022</a>).</p><p><strong>Constructors</strong></p><p>A lifted code can be constructed via the following approaches:</p><ol><li><p>A matrix of group algebra elements.</p></li><li><p>A matrix of group elements, where a group element will be considered as a group algebra element by assigning a unit coefficient.</p></li><li><p>A matrix of integers, where each integer represent the shift of a cyclic permutation. The order of the cyclic permutation should be specified.</p></li></ol><p>The default <code>GA</code> is the group algebra of <code>A[1, 1]</code>, the default representation <code>repr</code> is the permutation representation.</p><p>Below is a list of all constructors:</p><pre><code class="language-julia hljs">LiftedCode(A; GA, repr)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7//ext/QuantumCliffordHeckeExt/lifted.jl#L58"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted.jl:58</code></a>.</p><pre><code class="language-julia hljs">LiftedCode(A; GA)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7//ext/QuantumCliffordHeckeExt/lifted.jl#L68"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted.jl:68</code></a>.</p><pre><code class="language-julia hljs">LiftedCode(group_elem_array; GA, repr)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7//ext/QuantumCliffordHeckeExt/lifted.jl#L74"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted.jl:74</code></a>.</p><pre><code class="language-julia hljs">LiftedCode(shift_array, l; GA)</code></pre><p>defined at <a href="https://github.com/QuantumSavory/QuantumClifford.jl/tree/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7//ext/QuantumCliffordHeckeExt/lifted.jl#L87"><code>/home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted.jl:87</code></a>.</p><p><strong>The representation function <code>repr</code></strong></p><p>We use the default representation function <code>Hecke.representation_matrix</code> to convert a <code>GF(2)</code>-group algebra element to a binary matrix. The default representation, provided by <code>Hecke</code>, is the permutation representation.</p><p>We also accept a custom representation function (the <code>repr</code> field of the constructor). Whatever the representation, the matrix elements need to be convertible to Integers (e.g. permit <code>lift(ZZ, ...)</code>). Such a customization would be useful to reduce the number of bits required by the code construction.</p><p>For example, if we use a D4 group for lifting, our default representation will be <code>8×8</code> permutation matrices, where 8 is the group&#39;s order. However, we can find a <code>4×4</code> matrix representation for the group, e.g. by using the typical <a href="https://en.wikipedia.org/wiki/Dihedral_group"><code>2×2</code> representation</a> and converting it into binary representation by replacing &quot;1&quot; with the Pauli I, and &quot;-1&quot; with the Pauli X matrix.</p><p>See also: <a href="#QuantumClifford.ECC.LPCode-Tuple"><code>QuantumClifford.ECC.LPCode</code></a>.</p><p>All fields:</p><ul><li><p><code>A::Union{LinearAlgebra.Adjoint{&lt;:Hecke.GroupAlgebraElem, &lt;:Matrix{&lt;:Hecke.GroupAlgebraElem}}, Matrix{&lt;:Hecke.GroupAlgebraElem}}</code>: the base matrix of the code, whose elements are in a group algebra.</p></li><li><p><code>GA::Hecke.GroupAlgebra</code>: the group algebra for which elements in <code>A</code> are from.</p></li><li><p><code>repr::Function</code>: a function that converts a group algebra element to a binary matrix; default to be the permutation representation for GF(2)-algebra.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/ext/QuantumCliffordHeckeExt/lifted.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.bicycle_codes-Tuple{Array{Int64}, Int64}" href="#QuantumClifford.ECC.bicycle_codes-Tuple{Array{Int64}, Int64}"><code>QuantumClifford.ECC.bicycle_codes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bicycle_codes(a_shifts::Array{Int64}, l::Int64) -&gt; Any
</code></pre><p>Bicycle codes are a special case of generalized bicycle codes, where <code>a</code> and <code>b</code> are conjugate to each other. The order of the cyclic group is <code>l</code>, and the shifts <code>a_shifts</code> and <code>b_shifts</code> are reverse to each other. Thus you need to provide only the <code>a_shifts</code> and the rest of the conversions and conjugations are taken care of.</p><p>See also: <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.haah_cubic_codes"><code>haah_cubic_codes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/ext/QuantumCliffordHeckeExt/lifted_product.jl#L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.generalized_bicycle_codes-Tuple{Array{Int64}, Array{Int64}, Int64}" href="#QuantumClifford.ECC.generalized_bicycle_codes-Tuple{Array{Int64}, Array{Int64}, Int64}"><code>QuantumClifford.ECC.generalized_bicycle_codes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generalized_bicycle_codes(
    a_shifts::Array{Int64},
    b_shifts::Array{Int64},
    l::Int64
) -&gt; Any
</code></pre><p>Generalized bicycle codes, which are a special case of <em>abelian</em> 2GBA codes (and therefore of lifted product codes). Here the group is chosen as the cyclic group of order <code>l</code>, and the base matrices <code>a</code> and <code>b</code> are the sum of the group algebra elements corresponding to the shifts <code>a_shifts</code> and <code>b_shifts</code>.</p><p>Behind the scenes, the shifts are converted to the corresponding group algebra elements and piped to <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>.</p><p>See also: <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>.</p><p><strong>Examples</strong></p><p>A [[254, 28, 14 ≤ d ≤ 20]] code from (A1) in Appendix B of (<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke; using QuantumClifford.ECC

julia&gt; c = generalized_bicycle_codes([0, 15, 20, 28, 66], [0, 58, 59, 100, 121], 127);

julia&gt; code_n(c), code_k(c)
(254, 28)</code></pre><p>An [[70, 8, 10]] <em>abelian</em> 2BGA code from Table 1 of (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>), with cyclic group of order <code>l = 35</code>, illustrates that <em>abelian</em> 2BGA codes can be viewed as GB codes.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke; using QuantumClifford.ECC

julia&gt; l = 35;

julia&gt; c1 = generalized_bicycle_codes([0, 15, 16, 18], [0, 1, 24, 27], l);

julia&gt; code_n(c1), code_k(c1)
(70, 8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/ext/QuantumCliffordHeckeExt/lifted_product.jl#L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.haah_cubic_codes-Tuple{Array{Int64}, Array{Int64}, Int64}" href="#QuantumClifford.ECC.haah_cubic_codes-Tuple{Array{Int64}, Array{Int64}, Int64}"><code>QuantumClifford.ECC.haah_cubic_codes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">haah_cubic_codes(
    a_shifts::Array{Int64},
    b_shifts::Array{Int64},
    l::Int64
) -&gt; Any
</code></pre><p>Haah’s cubic codes (<a href="../references/#haah2011local">Haah, 2011</a>) can be viewed as generalized bicycle (GB) codes with the group <code>G = Cₗ × Cₗ × Cₗ</code>, where <code>l</code> denotes the lattice size. In particular, a GB code with the group <code>G = ℤ₃ˣ³</code> corresponds to a cubic code.</p><p>Behind the scenes, this function is just a simple shortcut for preparing the group <code>G</code>, before piping the arguments to <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>.</p><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/haah_cubic">entry for this family</a>.</p><p>See also: <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke; using QuantumClifford.ECC;

julia&gt; c = haah_cubic_codes([0, 15, 20, 28, 66], [0, 58, 59, 100, 121], 6);

julia&gt; code_n(c), code_k(c)
(432, 8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/ext/QuantumCliffordHeckeExt/lifted_product.jl#L357">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.two_block_group_algebra_codes-Tuple{Hecke.GroupAlgebraElem, Hecke.GroupAlgebraElem}" href="#QuantumClifford.ECC.two_block_group_algebra_codes-Tuple{Hecke.GroupAlgebraElem, Hecke.GroupAlgebraElem}"><code>QuantumClifford.ECC.two_block_group_algebra_codes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">two_block_group_algebra_codes(
    a::Hecke.GroupAlgebraElem,
    b::Hecke.GroupAlgebraElem
) -&gt; Any
</code></pre><p>Two-block group algebra (2BGA) codes, which are a special case of lifted product codes from two group algebra elements <code>a</code> and <code>b</code>, used as <code>1×1</code> base matrices. To build them, you pick a group and specific generators for that group, then you pick two polynomials made of the group generators, and then, behind the scenes, these two polynomials <code>a</code> and <code>b</code> are piped to the lifted product code constructor as the elements of <code>1×1</code> matrices.</p><p>See also: <a href="#QuantumClifford.ECC.LPCode-Tuple"><code>QuantumClifford.ECC.LPCode</code></a>, <a href="#QuantumClifford.ECC.generalized_bicycle_codes"><code>generalized_bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.bicycle_codes"><code>bicycle_codes</code></a>, <a href="#QuantumClifford.ECC.haah_cubic_codes"><code>haah_cubic_codes</code></a>.</p><p><strong>Examples of 2BGA code subfamilies</strong></p><p><strong><code>C₄ x C₂</code></strong></p><p>Here is an example of a [[56, 28, 2]] 2BGA code from Table 2 of (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>) build out of polymonials of generators of the direct product <code>C₄ × C₂</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; using QuantumClifford.ECC;

julia&gt; GA = group_algebra(GF(2), abelian_group([14,2]));

julia&gt; x, s = gens(GA);

julia&gt; A = 1 + x^7;

julia&gt; B = 1 + x^7 + s + x^8 + s*x^7 + x;

julia&gt; c = two_block_group_algebra_codes(A,B);

julia&gt; import HiGHS;

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(56, 28, 2)</code></pre><p><strong>Bivariate Bicycle codes</strong></p><p>Bivariate Bicycle codes are a class of Abelian 2BGA codes formed by the direct product of two cyclic groups <code>ℤₗ × ℤₘ</code>. The parameters <code>l</code> and <code>m</code> represent the orders of the first and second cyclic groups, respectively.</p><p>The ECC Zoo has an <a href="https://errorcorrectionzoo.org/c/qcga">entry for this family</a>.</p><p>A [[756, 16, ≤ 34]] code from Table 3 of (<a href="../references/#bravyi2024high">Bravyi <em>et al.</em>, 2024</a>):</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; using QuantumClifford.ECC;

julia&gt; l=21; m=18;

julia&gt; GA = group_algebra(GF(2), abelian_group([l, m]));

julia&gt; x, y = gens(GA);

julia&gt; A = x^3 + y^10 + y^17;

julia&gt; B = y^5 + x^3  + x^19;

julia&gt; c = two_block_group_algebra_codes(A,B);

julia&gt; code_n(c), code_k(c)
(756, 16)</code></pre><p><strong>Multivariate Bicycle code</strong></p><p>The group algebra of the qubit multivariate bicycle (MB) code with r variables is <code>𝔽₂[𝐺ᵣ]</code>, where <code>𝐺ᵣ = ℤ/l₁ × ℤ/l₂ × ... × ℤ/lᵣ</code>.</p><p>A [[48, 4, 6]] Weight-6 TB-QLDPC code from Appendix A Table 2 of (<a href="../references/#voss2024multivariatebicyclecodes">Voss <em>et al.</em>, 2024</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; using QuantumClifford.ECC;

julia&gt; l=4; m=6;

julia&gt; GA = group_algebra(GF(2), abelian_group([l, m]));

julia&gt; x, y = gens(GA);

julia&gt; z = x*y;

julia&gt; A = x^3 + y^5;

julia&gt; B = x + z^5 + y^5 + y^2;

julia&gt; c = two_block_group_algebra_codes(A, B);

julia&gt; import HiGHS

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(48, 4, 6)</code></pre><p><strong>Coprime Bivariate Bicycle code</strong></p><p>The coprime bivariate bicycle (BB) codes are defined by two polynomials <code>𝑎(𝑥,𝑦)</code> and <code>𝑏(𝑥,𝑦)</code>, where <code>𝑙</code> and <code>𝑚</code> are coprime, and can be expressed as univariate polynomials <code>𝑎(𝜋)</code> and <code>𝑏(𝜋)</code>, with generator <code>𝜋 = 𝑥𝑦</code>. They can be viewed as a special case of Lifted Product construction based on abelian group <code>ℤₗ x ℤₘ</code> where <code>ℤⱼ</code> cyclic group of order <code>j</code>.</p><p>[[108, 12, 6]] coprime-bivariate bicycle (BB) code from Table 2 of (<a href="../references/#wang2024coprime">Wang and Mueller, 2024</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; using QuantumClifford.ECC;

julia&gt; l=2; m=27;

julia&gt; GA = group_algebra(GF(2), abelian_group([l*m]));

julia&gt; 𝜋 = gens(GA)[1];

julia&gt; A = 𝜋^2 + 𝜋^5  + 𝜋^44;

julia&gt; B = 𝜋^8 + 𝜋^14 + 𝜋^47;

julia&gt; c = two_block_group_algebra_codes(A, B);

julia&gt; import HiGHS

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(108, 12, 6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/ext/QuantumCliffordHeckeExt/lifted_product.jl#L165">source</a></section></article><h2 id="Implemented-in-an-extension-requiring-Oscar.jl"><a class="docs-heading-anchor" href="#Implemented-in-an-extension-requiring-Oscar.jl">Implemented in an extension requiring <code>Oscar.jl</code></a><a id="Implemented-in-an-extension-requiring-Oscar.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Implemented-in-an-extension-requiring-Oscar.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.twobga_from_direct_product-Tuple{Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}}, Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}}, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}" href="#QuantumClifford.ECC.twobga_from_direct_product-Tuple{Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}}, Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}}, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}"><code>QuantumClifford.ECC.twobga_from_direct_product</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">twobga_from_direct_product(
    a_elts::Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}},
    b_elts::Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}},
    F2G::Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}
) -&gt; Any
</code></pre><p>Constructing two block group algebra codes by specifying the direct product to be used. See also the more general <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>.</p><p>Two block group algebra codes are constructed by choosing a group (and specific generators), then choosing two polynomials made out of these generators, then piping these two polynomials as the elements of <code>1×1</code> matrices to the lifted product code constructors.</p><p>The Hecke library, for which we already have an extension, provides for a fairly easy way to construct such polynomials for many abelian and small groups. See <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a> for those capabilities.</p><p>However, more esoteric groups can be specified as the direct product of other groups. To support arbitrary direct products we use Oscar, which builds upon Hecke. Oscar supports the <strong>direct product</strong> operation between two or more arbitrary <strong>general</strong> groups, including non-abelian groups such as <code>alternating_group</code>, <code>dihedral_group</code>, <code>symmetric_group</code>, and even arbitrary finitely presented groups (e.g., <code>free_group</code>). This capability is not available in <code>Hecke.jl</code>. The 2BGA codes discovered in (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>) rely on direct products of two or more <em>general</em> groups, which necessitate the use of <code>Oscar.direct_product</code>.</p><p>This particular function is nothing more than a simple wrapper that takes care of argument conversions. Of note, the polynomials here are given as lists of monomials.</p><p>Of course, if you are comfortable with Oscar, you can use <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a> directly.</p><p>See also: <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.twobga_from_fp_group"><code>twobga_from_fp_group</code></a></p><p><strong>Examples</strong></p><p>The [[56, 28, 2]] abelian 2BGA code from Appendix C, Table II in (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>) can be constructed using the direct product of two cyclic groups. Specifically, the group <code>C₂₈</code> of order <code>l = 28</code> can be represented as <code>C₁₄ × C₂</code>, where the first group has order <code>m = 14</code> and the second group has order <code>n = 2</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; import Oscar: cyclic_group, small_group_identification, describe, order

julia&gt; import Hecke: gens, quo, group_algebra, GF, one, direct_product, sub

julia&gt; using QuantumClifford, QuantumClifford.ECC

julia&gt; m = 14; n = 2;

julia&gt; C₁₄ = cyclic_group(m);

julia&gt; C₂ = cyclic_group(n);

julia&gt; G = direct_product(C₁₄, C₂);

julia&gt; GA = group_algebra(GF(2), G);

julia&gt; x, s = gens(GA)[1], gens(GA)[3];

julia&gt; a = [one(GA), x^7];

julia&gt; b = [one(GA), x^7, s, x^8, s * x^7, x];

julia&gt; c = twobga_from_direct_product(a, b, GA);

julia&gt; order(G)
28

julia&gt; code_n(c), code_k(c)
(56, 28)

julia&gt; describe(G), small_group_identification(G)
(&quot;C14 x C2&quot;, (28, 4))</code></pre><div class="admonition is-danger" id="Danger-b4691122f7d248bb"><header class="admonition-header">Danger<a class="admonition-anchor" href="#Danger-b4691122f7d248bb" title="Permalink"></a></header><div class="admonition-body"><p>When using the direct product, there isn&#39;t necessarily a unique set of generators. It is essential to verify that Oscar is providing you with the generators you expect, e.g. for a cycling group that you have the presentation <code>Cₘ = ⟨x, s | xᵐ = s² = xsx⁻¹s⁻¹ = 1⟩</code>. For situations where the generators provided by Oscar are not the ones you want, you can also use <a href="#QuantumClifford.ECC.twobga_from_fp_group"><code>twobga_from_fp_group</code></a> where you specify the group presentation directly.</p></div></div><p>As a verification that you have the correct generators, <code>Oscar.sub</code> can be used to determine if <code>H</code> is a subgroup of <code>G</code> and to confirm that both <code>C₁₄</code> and <code>C₂</code> are subgroups of <code>C₂₈</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; order(gens(G)[1])
14

julia&gt; order(gens(G)[3])
2

julia&gt; x^14 == s^2 == x * s * x^-1 * s^-1
true

julia&gt; H, _  = sub(G, [gens(G)[1], gens(G)[3]]);

julia&gt; H == G
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/ext/QuantumCliffordOscarExt/direct_product.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumClifford.ECC.twobga_from_fp_group-Tuple{Vector{Oscar.FPGroupElem}, Vector{Oscar.FPGroupElem}, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.FPGroup, Oscar.FPGroupElem}}" href="#QuantumClifford.ECC.twobga_from_fp_group-Tuple{Vector{Oscar.FPGroupElem}, Vector{Oscar.FPGroupElem}, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.FPGroup, Oscar.FPGroupElem}}"><code>QuantumClifford.ECC.twobga_from_fp_group</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">twobga_from_fp_group(
    a_elts::Vector{Oscar.FPGroupElem},
    b_elts::Vector{Oscar.FPGroupElem},
    F2G::Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.FPGroup, Oscar.FPGroupElem}
) -&gt; Any
</code></pre><p>Constructing two block group algebra codes by specifying the group presentation.</p><p>Two block group algebra codes are constructed by choosing a group (and specific generators), then choosing two polynomials made out of these generators, then piping these two polynomials as the elements of <code>1×1</code> matrices to the lifted product code constructors.</p><p>The Hecke library, for which we already have an extension, provides for a fairly easy way to construct such polynomials for many abelian and small groups. See <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a> for those capabilities.</p><p>However, more esoteric groups are usually specified by a group presentation <code>⟨S | R⟩</code>, where <code>S</code> is a set of generators and <code>R</code> is the relations those generators obey. To support arbitrary group presentations we use Oscar, which builds upon Hecke. We use <code>Oscar.free_group</code> and <code>quo</code> in order to first prepare the free group generated by <code>S</code>, and then the group obeying also the relations <code>R</code>, i.e. the <code>⟨S | R⟩</code> <a href="https://en.wikipedia.org/wiki/Presentation_of_a_group">presentation</a>.</p><p>After that point we proceed as usual, creating two polynomials of generators and piping them to <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>.</p><p>This particular function is nothing more than a simple wrapper that takes care of argument conversions. Of note, the polynomials here are given as lists of monomials.</p><p>Of course, if you are comfortable with Oscar, you can use <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a> directly.</p><p>See also: <a href="#QuantumClifford.ECC.two_block_group_algebra_codes"><code>two_block_group_algebra_codes</code></a>, <a href="#QuantumClifford.ECC.twobga_from_direct_product"><code>twobga_from_direct_product</code></a></p><p><strong>Examples</strong></p><p>The [[96, 12, 10]] 2BGA code from Table I in (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>) has the group presentation <code>⟨r, s | s⁶ = r⁸ = r⁻¹srs = 1⟩</code> (the group <code>C₂ × (C₃ ⋉ C₈)</code>).</p><p>Currently unsupported as it requires a non-commutative group algebra.</p><pre><code class="language-julia-repl hljs">julia&gt; import Oscar: free_group, small_group_identification, describe, order

julia&gt; import Hecke: gens, quo, group_algebra, GF, one

julia&gt; using QuantumClifford, QuantumClifford.ECC

julia&gt; F = free_group([&quot;r&quot;, &quot;s&quot;]);

julia&gt; r, s = gens(F); # generators

julia&gt; G, = quo(F, [s^6, r^8, r^(-1) * s * r * s]);  # relations

julia&gt; GA = group_algebra(GF(2), G);

julia&gt; r, s = gens(G);

julia&gt; a = [one(G), r, s^3 * r^2, s^2 * r^3];

julia&gt; b = [one(G), r, s^4 * r^6, s^5 * r^3];

julia&gt; c = twobga_from_fp_group(a, b, GA);
ERROR: The CSS code just created is invalid -- its rows do not commute. This is either a bug in this library, or an inconsistent parity check matrices were provided to the CSS constructor.
[...]</code></pre><p><strong>Cyclic Groups</strong></p><p>Cyclic groups with specific group presentations, given by <code>Cₘ = ⟨x, s | xᵐ = s² = xsx⁻¹s⁻¹ = 1⟩</code>, where the order is <code>2m</code> as seen in Table II of (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>).</p><p>The [[56, 28, 2]] abelian 2BGA code from Appendix C, Table II in (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>) is constructed using the group presentation <code>⟨x, s | xs = sx, xᵐ = s² = 1⟩</code> (the cyclic group <code>C₂₈ = C₁₄ × C₂</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; m = 14;

julia&gt; F = free_group([&quot;x&quot;, &quot;s&quot;]);

julia&gt; x, s = gens(F); # generators

julia&gt; G, = quo(F, [x^m, s^2, x * s * x^-1 * s^-1]); # relations

julia&gt; GA = group_algebra(GF(2), G);

julia&gt; x, s = gens(G);

julia&gt; a = [one(G), x^7];

julia&gt; b = [one(G), x^7, s, x^8, s * x^7, x];

julia&gt; c = twobga_from_fp_group(a, b, GA);

julia&gt; order(G)
28

julia&gt; code_n(c), code_k(c)
(56, 28)

julia&gt; describe(G), small_group_identification(G)
(&quot;C14 x C2&quot;, (28, 4))</code></pre><p><strong>Dihedral Groups</strong></p><p>Dihedral (non-abelian) groups with group presentations given by <code>Dₘ = ⟨r, s | rᵐ = s² = (rs)² = 1⟩</code>, where the order is <code>2m</code>.</p><p>The [[24, 8, 3]] 2BGA code from Appendix C, Table III in (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>) is constructed by specifying a group presentation below (giving the group <code>D₆ = C₆ ⋉ C₂</code>).</p><p>Currently unsupported as it requires a non-commutative group algebra.</p><pre><code class="language-julia-repl hljs">julia&gt; m = 6;

julia&gt; F = free_group([&quot;r&quot;, &quot;s&quot;]);

julia&gt; r, s = gens(F); # generators

julia&gt; G, = quo(F, [r^m, s^2, (r*s)^2]); # relations

julia&gt; GA = group_algebra(GF(2), G);

julia&gt; r, s = gens(G);

julia&gt; a = [one(G), r^4];

julia&gt; b = [one(G), s*r^4, r^3, r^4, s*r^2, r];

julia&gt; c = twobga_from_fp_group(a, b, GA);
ERROR: The CSS code just created is invalid -- its rows do not commute. This is either a bug in this library, or an inconsistent parity check matrices were provided to the CSS constructor.
[...]</code></pre><div class="admonition is-info" id="Note-9792205551ac43e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-9792205551ac43e" title="Permalink"></a></header><div class="admonition-body"><p>Notice how in all of these construction we are specifying a group presentation. We are explicitly <strong>not</strong> picking a group by name and getting its &quot;canonical&quot; generators, as we do not a priori know whether Oscar would give us the generating set we need (generating sets are not unique).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/ext/QuantumCliffordOscarExt/group_presentation.jl#L1">source</a></section></article><h2 id="Implemented-in-an-extension-requiring-JuMP.jl"><a class="docs-heading-anchor" href="#Implemented-in-an-extension-requiring-JuMP.jl">Implemented in an extension requiring <code>JuMP.jl</code></a><a id="Implemented-in-an-extension-requiring-JuMP.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Implemented-in-an-extension-requiring-JuMP.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QECCore.distance-Tuple{QECCore.AbstractECC, QuantumClifford.ECC.DistanceMIPAlgorithm}" href="#QECCore.distance-Tuple{QECCore.AbstractECC, QuantumClifford.ECC.DistanceMIPAlgorithm}"><code>QECCore.distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance(
    code::QECCore.AbstractECC,
    alg::QuantumClifford.ECC.DistanceMIPAlgorithm
) -&gt; Any
</code></pre><p>Compute the distance of a code using mixed integer programming. See <a href="#QuantumClifford.ECC.DistanceMIPAlgorithm"><code>QuantumClifford.ECC.DistanceMIPAlgorithm</code></a> for configuration options.</p><p>Computes the minimum Hamming weight of a binary vector <code>x</code> by solving an <strong>mixed integer program (MIP)</strong> that satisfies the following constraints:</p><ul><li><span>$\text{stab} \cdot x \equiv 0 \pmod{2}$</span>: The binary vector <code>x</code> must have an</li></ul><p>even overlap with each <code>X</code>-check of the stabilizer binary representation <code>stab</code>.</p><ul><li><span>$\text{logicOp} \cdot x \equiv 1 \pmod{2}$</span>: The binary vector <code>x</code> must have</li></ul><p>an odd overlap with logical-<code>X</code> operator <code>logicOp</code> on the <code>i</code>-th logical qubit.</p><p>Specifically, it calculates the minimum Hamming weight <span>$d_{Z}$</span> for the <code>Z</code>-type logical operator. The minimum distance for <code>X</code>-type logical operators is the same.</p><p><strong>Background on Minimum Distance</strong></p><p>For <em>classical</em> codes, the minimum distance, which measures a code&#39;s error-correcting capability, is equivalent to its minimum weight. This can be computed by generating all possible codewords from combinations of the generator matrix rows, calculating their weights, and finding the smallest. While accurate, this method takes exponential time. Vardy (<a href="../references/#vardy1997intractability">Vardy, 1997</a>) demonstrated that computing the minimum distance is <em>NP-hard</em>, and the corresponding decision problem is <em>NP-complete</em>, making polynomial-time algorithms unlikely.</p><p>For <em>quantum</em> codes, classical intuition does not always apply. The minimum distance is given by the minimum weight of a non-trivial logical operator. This is generally unrelated to the minimum distance of the corresponding stabilizer code when viewed as a classical, additive code. White and Grassl (<a href="../references/#white2006new">White and Grassl, 2006</a>) proposed mapping quantum codes to higher-dimensional classical linear codes. This mapping allows the minimum distance of the quantum additive code to be inferred from that of the classical linear code but increases parameters from <code>n</code> to <code>3n</code> and <code>d</code> to <code>2d</code>, adding complexity. Furthermore, once a minimal weight vector is identified, it is essential to verify whether it belongs to the Pauli group <code>𝒫ₙ</code> over <code>n</code> qubits (<a href="../references/#Sabo_2022smk">Sabo, 2022</a>).</p><p>Additionally, to illustrate how classical intuition can be misleading in this context, consider that the <code>[[7, 1, 3]]</code> Steane code has a minimum distance of three, despite all its elements having a weight of four. This discrepancy occurs because stabilizer codes are defined by parity-check matrices, while their minimum distances are determined by the dual (<a href="../references/#Sabo_2022smk">Sabo, 2022</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford, QuantumClifford.ECC

julia&gt; c = parity_checks(Steane7());

julia&gt; stab_to_gf2(c)
6×14 Matrix{Bool}:
 0  0  0  1  1  1  1  0  0  0  0  0  0  0
 0  1  1  0  0  1  1  0  0  0  0  0  0  0
 1  0  1  0  1  0  1  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  1  1  1  1
 0  0  0  0  0  0  0  0  1  1  0  0  1  1
 0  0  0  0  0  0  0  1  0  1  0  1  0  1

julia&gt; minimum(sum(stab_to_gf2(c), dims=2))
4

julia&gt; distance(Steane7())
3</code></pre><div class="admonition is-info" id="Note-c371603342d50d66"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c371603342d50d66" title="Permalink"></a></header><div class="admonition-body"><p>The minimum distance problem for quantum codes is <em>NP-hard</em>, and this hardness extends to multiplicative and additive approximations, even when restricted to stabilizer or CSS codes, with the result established through a reduction from classical problems in the CWS framework using a 4-cycle free graph (<a href="../references/#kapshikar2023hardness">Kapshikar and Kundu, 2023</a>). Despite this, methods that improve on brute-force approaches are actively explored.</p></div></div><p>For a more in-depth background on minimum distance, see Chapter 3 of (<a href="../references/#Sabo_2022smk">Sabo, 2022</a>).</p><p><strong>Mixed Integer Programming</strong></p><p>The MIP minimizes the Hamming weight <code>w(x)</code>, defined as the number of nonzero elements in <code>x</code>, while satisfying the constraints:</p><p class="math-container">\[\begin{aligned}
    \text{Minimize} \quad &amp; w(x) = \sum_{i=1}^n x_i, \\
    \text{subject to} \quad &amp; \text{stab} \cdot x \equiv 0 \pmod{2}, \\
                            &amp; \text{logicOp} \cdot x \equiv 1 \pmod{2}, \\
                            &amp; x_i \in \{0, 1\} \quad \text{for all } i.
\end{aligned}\]</p><p>Here:</p><ul><li><span>$\text{stab}$</span> is the binary matrix representing the stabilizer group.</li><li><span>$\text{logicOp}$</span> is the binary vector representing the logical-<code>X</code> operator.</li><li><code>x</code> is the binary vector (decision variable) being optimized.</li></ul><p>The optimal solution <span>$w_{i}$</span> for each logical-<code>X</code> operator corresponds to the minimum weight of a Pauli <code>Z</code>-type operator satisfying the above conditions. The <code>Z</code>-type distance is given by:</p><p class="math-container">\[\begin{aligned}
    d_Z = \min(w_1, w_2, \dots, w_k),
\end{aligned}\]</p><p>where <code>k</code> is the number of logical qubits.</p><p><strong>Example</strong></p><p>A [[40, 8, 5]] 2BGA code with the minimum distance of 5 from Table 2 of (<a href="../references/#lin2024quantum">Lin and Pryadko, 2024</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; import Hecke: group_algebra, GF, abelian_group, gens; import HiGHS; import JuMP;

julia&gt; using QuantumClifford, QuantumClifford.ECC

julia&gt; l = 10; m = 2;

julia&gt; GA = group_algebra(GF(2), abelian_group([l,m]));

julia&gt; x, s = gens(GA);

julia&gt; A = 1 + x^6;

julia&gt; B = 1 + x^5 + s + x^6 + x + s*x^2;

julia&gt; c = two_block_group_algebra_codes(A,B);

julia&gt; code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))
(40, 8, 5)</code></pre><p>A [[48, 6, 8]] GB code with the minimum distance of 8 from (A3) in Appendix B of (<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; l = 24;

julia&gt; c1 = generalized_bicycle_codes([0, 2, 8, 15], [0, 2, 12, 17], l);

julia&gt; code_n(c1), code_k(c1), distance(c1, DistanceMIPAlgorithm(solver=HiGHS))
(48, 6, 8)</code></pre><p><strong>Applications</strong></p><p>Mixed-integer programming (MIP) is applied in quantum error correction, notably for decoding and minimum distance computation. Some applications are as follows:</p><ul><li><p>The first usecase of the MIP approach was the code capacity Most Likely Error (MLE) decoder for color codes introduced in (<a href="../references/#landahl2011color">Landahl <em>et al.</em>, 2011</a>).</p></li><li><p>For all quantum LDPC codes presented in (<a href="../references/#panteleev2021degenerate">Panteleev and Kalachev, 2021</a>), the lower and upper bounds on the minimum distance was obtained by reduction to a mixed integer linear program and using the GNU Linear Programming Kit ((<a href="../references/#makhorin2008glpk">Makhorin, 2008</a>)).</p></li><li><p>For all the Bivariate Bicycle (BB) codes presented in (<a href="../references/#bravyi2024high">Bravyi <em>et al.</em>, 2024</a>), the code distance was calculated using the mixed integer programming approach.</p></li><li><p>(<a href="../references/#lacroix2024scaling">Lacroix <em>et al.</em>, 2024</a>) developed a MLE decoder that finds the most likely chain of Pauli errors given the observed error syndrome by solving a mixed-integer program using <code>HiGHS</code> package ((<a href="../references/#huangfu2018parallelizing">Huangfu and Hall, 2018</a>)).</p></li><li><p>(<a href="../references/#cain2025correlateddecodinglogicalalgorithms">Cain <em>et al.</em>, 2025</a>) formulate maximum-likelihood decoding as a mixed-integer program maximizing <span>$\prod_{j=1}^M p_j^{E_j}(1-p_j)^{1-E_j}$</span> (where binary variables <span>$E_j \in {0,1}$</span> indicate error occurrence) subject to syndrome constraints, solved optimally via MIP solvers despite its NP-hard complexity.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/d6114ebde41c57d5771a2c6de6fa9d0a779ef6a7/ext/QuantumCliffordJuMPExt/min_distance_mixed_integer_programming.jl#L1">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ECC_evaluating/">« Evaluating codes and decoders</a><a class="docs-footer-nextpage" href="../allops/">All Gates »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Thursday 3 July 2025 22:44">Thursday 3 July 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

var documenterSearchIndex = {"docs":
[{"location":"references/#Suggested-reading","page":"Suggested Readings & References","title":"Suggested reading","text":"","category":"section"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"For the basis of the tableaux methods first read (Gottesman, 1998) followed by the more efficient approach described in (Aaronson and Gottesman, 2004).","category":"page"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"The tableaux can be canonicalized (i.e. Gaussian elimination can be performed on them) in a number of different ways, and considering the different approaches provides useful insight. The following methods are implemented in this library:","category":"page"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"The default one: (Garcia et al., 2012)\nUseful when in need of tracing out a set of qubits: (Audenaert and Plenio, 2005)\nUseful when defining logical operators of codes: (Gottesman, 1997)","category":"page"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"For the use of these methods in error correction and the subtle overlap between the two fields consider these resources. They are also useful in defining some of the specific constraints in commutation between rows in the tableaux:","category":"page"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"(Steane, 2007)\n(Calderbank et al., 1998)\n(MacKay et al., 2004)\n(Wilde, 2009)","category":"page"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"These publications describe the uniform sampling of random stabilizer states:","category":"page"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"(Koenig and Smolin, 2014)\n(Bravyi and Maslov, 2021)\n(Van Den Berg, 2021)\n(Li et al., 2019)","category":"page"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"For circuit construction routines (for stabilizer measurements for a given code):","category":"page"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"(Cleve and Gottesman, 1997)\n(Gottesman, 1997) (and its erratum)\n(Grassl, 2002)\n(Grassl, 2011)","category":"page"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"For quantum code construction routines:","category":"page"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"(Cleve and Gottesman, 1997)\n(Gottesman, 1996)\n(Gottesman, 1997)\n(Yu et al., 2013)\n(Chao and Reichardt, 2017)\n(Kitaev, 2003)\n(Fowler et al., 2012)\n(Goppa, 1970)\n(Berlekamp, 1973)\n(McEliece, 1978)\n(Patterson, 1975)\n(Sugiyama et al., 1975)\n(Bernstein et al., 2008)\n(Wirtz, 1988)\n(Singh, 2019)\n(van Lint et al., 1988)\n(Knill and Laflamme, 1996)\n(Steane, 1999)\n(Campbell et al., 2012)\n(Anderson et al., 2014)\n(Wang and Mueller, 2024)\n(Voss et al., 2024)\n(Lin and Pryadko, 2024)\n(Bravyi et al., 2024)\n(Haah, 2011)\n(Landahl et al., 2011)\n(Wang et al., 2023)\n(Naghipour et al., 2015)\n(Eberhardt and Steffan, 2024)\n(Delfosse and Reichardt, 2020)\n(Berthusen et al., 2024)\n(Zeng and Pryadko, 2019)\n(Pecorari et al., 2025)\n(Berthusen et al., 2025)\n(Arnault et al., 2025)\n(Tillich and Zémor, 2006)\n(Bravyi et al., 2024)\n(Quintavalle et al., 2021)\n(Xu et al., 2024)\n(Bravyi and Hastings, 2013)\n(Liang et al., 2025)\n(Jacob et al., 2025)","category":"page"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"For classical code construction routines:","category":"page"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"(Muller, 1954)\n(Reed, 1954)\n(Raaphorst, 2003)\n(Abbe et al., 2020)\n(Djordjevic, 2021)\n(Hocquenghem, 1959)\n(Bose and Ray-Chaudhuri, 1960)\n(Bose and Ray-Chaudhuri, 1960)\n(Lin and Costello, 2024)\n(Golay, 1949)\n(Huffman and Pless, 2010)\n(Bhatia and Kumar, 2018)\n(Hamming, 1950)\n(Huffman and Pless, 2010)\n(Gallager, 1962)","category":"page"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"For minimum distance calculation of quantum codes:","category":"page"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"(Vardy, 1997)\n(Sabo, 2022)\n(Kapshikar and Kundu, 2023)\n(Landahl et al., 2011)\n(White and Grassl, 2006)\n(Pryadko et al., 2023)\n(Makhorin, 2008)\n(Lubin et al., 2023)\n(Huangfu and Hall, 2018)\n(Wang and Pryadko, 2022)","category":"page"},{"location":"references/#References","page":"Suggested Readings & References","title":"References","text":"","category":"section"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"Aaronson, S. and Gottesman, D. (2004). Improved simulation of stabilizer circuits. Physical Review A 70, 052328.\n\n\n\nAbbe, E.; Shpilka, A. and Ye, M. (2020). Reed–Muller codes: Theory and algorithms. IEEE Transactions on Information Theory 67, 3251–3277.\n\n\n\nAnderson, J. T.; Duclos-Cianci, G. and Poulin, D. (2014). Fault-tolerant conversion between the steane and reed-muller quantum codes. Physical review letters 113, 080501.\n\n\n\nArnault, F.; Gaborit, P.; Rozendaal, W.; Saussay, N. and Zémor, G. (2025). Upper Bounds on the Minimum Distance of Structured LDPC Codes, arXiv preprint arXiv:2501.19125.\n\n\n\nAudenaert, K. M. and Plenio, M. B. (2005). Entanglement on mixed stabilizer states: normal forms and reduction procedures. New Journal of Physics 7, 170.\n\n\n\nBerlekamp, E. (1973). Goppa codes. IEEE Transactions on Information Theory 19, 590–592.\n\n\n\nBernstein, D. J.; Lange, T. and Peters, C. (2008). Attacking and defending the McEliece cryptosystem. In: Post-Quantum Cryptography: Second International Workshop, PQCrypto 2008 Cincinnati, OH, USA, October 17-19, 2008 Proceedings 2 (Springer); pp. 31–46.\n\n\n\nBerthusen, N.; Dreiling, J.; Foltz, C.; Gaebler, J. P.; Gatterman, T. M.; Gresh, D.; Hewitt, N.; Mills, M.; Moses, S. A.; Neyenhuis, B.; Siegfried, P. and Hayes, D. (2024). Experiments with the four-dimensional surface code on a quantum charge-coupled device quantum computer. Physical Review A 110.\n\n\n\nBerthusen, N.; Tan, S. J.; Huang, E. and Gottesman, D. (2025). Adaptive Syndrome Extraction, arXiv:2502.14835 [quant-ph].\n\n\n\nBhatia, A. S. and Kumar, A. (2018). McEliece cryptosystem based on extended Golay code, arXiv preprint arXiv:1811.06246.\n\n\n\nBose, R. C. and Ray-Chaudhuri, D. K. (1960). Further results on error correcting binary group codes. Information and Control 3, 279–290.\n\n\n\nBose, R. C. and Ray-Chaudhuri, D. K. (1960). On a class of error correcting binary group codes. Information and control 3, 68–79.\n\n\n\nBravyi, S.; Cross, A. W.; Gambetta, J. M.; Maslov, D.; Rall, P. and Yoder, T. J. (2024). High-threshold and low-overhead fault-tolerant quantum memory. Nature 627, 778–782.\n\n\n\nBravyi, S. and Hastings, M. B. (2013). Homological Product Codes, arXiv:1311.0885 [quant-ph].\n\n\n\nBravyi, S. and Maslov, D. (2021). Hadamard-free circuits expose the structure of the Clifford group. IEEE Transactions on Information Theory 67, 4546–4563.\n\n\n\nBreuckmann, N. P.; Davydova, M.; Eberhardt, J. N. and Tantivasadakarn, N. (2024). Cups and Gates I: Cohomology invariants and logical quantum operations, arXiv:2410.16250 [quant-ph].\n\n\n\nBrown, W. and Fawzi, O. (Jul 2013). Short Random Circuits Define Good Quantum Error Correcting Codes. In: 2013 IEEE International Symposium on Information Theory; pp. 346–350.\n\n\n\nCain, M.; Zhao, C.; Zhou, H.; Meister, N.; Ataides, J. P.; Jaffe, A.; Bluvstein, D. and Lukin, M. D. (2025). Correlated decoding of logical algorithms with transversal gates, arXiv:2403.03272 [quant-ph].\n\n\n\nCalderbank, A. R.; Rains, E. M.; Shor, P. and Sloane, N. J. (1998). Quantum error correction via codes over GF (4). IEEE Transactions on Information Theory 44, 1369–1387.\n\n\n\nCampbell, E. T. (2019). A theory of single-shot error correction for adversarial noise. Quantum Science and Technology 4, 025006.\n\n\n\nCampbell, E. T.; Anwar, H. and Browne, D. E. (2012). Magic-state distillation in all prime dimensions using quantum reed-muller codes. Physical Review X 2, 041021.\n\n\n\nChao, R. and Reichardt, B. W. (2017). Quantum Error Correction with Only Two Extra Qubits. Physical review letters 121 5, 050502.\n\n\n\nCleve, R. and Gottesman, D. (1997). Efficient computations of encodings for quantum error correction. Physical Review A 56, 76.\n\n\n\nDelfosse, N. and Reichardt, B. W. (2020). Short shor-style syndrome sequences, arXiv preprint arXiv:2008.05051.\n\n\n\nDjordjevic, I. B. (2021). Quantum information processing, quantum computing, and quantum error correction: an engineering approach (Academic Press).\n\n\n\nEberhardt, J. N. and Steffan, V. (2024). Logical operators and fold-transversal gates of bivariate bicycle codes, arXiv preprint arXiv:2407.03973.\n\n\n\nEkert, A.; Hosgood, T.; Kay, A. and Macchiavello, C. Introduction to Quantum Information Science, https://qubit.guide.\n\n\n\nFowler, A. G.; Mariantoni, M.; Martinis, J. M. and Cleland, A. N. (2012). Surface codes: Towards practical large-scale quantum computation. Physical Review A 86, 032324.\n\n\n\nGallager, R. (1962). Low-density parity-check codes. IRE Transactions on Information Theory 8, 21–28.\n\n\n\nGarcia, H. J.; Markov, I. L. and Cross, A. W. (2012). Efficient inner-product algorithm for stabilizer states, arXiv preprint arXiv:1210.6646.\n\n\n\nGolay, M. J. (1949). Notes on digital coding. Proc. IEEE 37, 657.\n\n\n\nGoodenough, K.; Sajjad, A.; Kaur, E.; Guha, S. and Towsley, D. (2024). Bipartite entanglement of noisy stabilizer states through the lens of stabilizer codes, arXiv:2406.02427 [quant-ph].\n\n\n\nGoppa, V. D. (1970). A new class of linear correcting codes. Problemy Peredachi Informatsii 6, 24–30.\n\n\n\nGottesman, D. (1996). Class of quantum error-correcting codes saturating the quantum Hamming bound. Physical Review A 54, 1862.\n\n\n\nGottesman, D. (1997). Stabilizer codes and quantum error correction. Ph.D. Thesis, California Institute of Technology.\n\n\n\nGottesman, D. (1998). The Heisenberg representation of quantum computers. In: International Conference on Group Theoretic Methods in Physics (Citeseer).\n\n\n\nGrassl, M. (2002). Algorithmic aspects of quantum error-correcting codes. Mathematics of Quantum Computation, 223–252.\n\n\n\nGrassl, M. (2011). Variations on encoding circuits for stabilizer quantum codes. In: International Conference on Coding and Cryptology (Springer); pp. 142–158.\n\n\n\nGullans, M. J.; Krastanov, S.; Huse, D. A.; Jiang, L. and Flammia, S. T. (2021). Quantum Coding with Low-Depth Random Circuits. Physical Review X 11, 031066.\n\n\n\nHaah, J. (2011). Local stabilizer codes in three dimensions without string logical operators. Physical Review A?Atomic, Molecular, and Optical Physics 83, 042330.\n\n\n\nHamming, R. W. (1950). Error detecting and error correcting codes. The Bell system technical journal 29, 147–160.\n\n\n\nHiggott, O. and Breuckmann, N. P. (2023). Improved Single-Shot Decoding of Higher-Dimensional Hypergraph-Product Codes. PRX Quantum 4.\n\n\n\nHocquenghem, A. (1959). Codes correcteurs d'erreurs. Chiffers 2, 147–156.\n\n\n\nHuangfu, Q. and Hall, J. J. (2018). Parallelizing the dual revised simplex method. Mathematical Programming Computation 10, 119–142.\n\n\n\nHuffman, W. C. and Pless, V. (2010). Fundamentals of error-correcting codes (Cambridge university press).\n\n\n\nJacob, A.; McLauchlan, C. and Browne, D. E. (2025). Single-Shot Decoding and Fault-tolerant Gates with Trivariate Tricycle Codes, arXiv:2508.08191 [quant-ph].\n\n\n\nKapshikar, U. and Kundu, S. (2023). On the hardness of the minimum distance problem of quantum codes. IEEE Transactions on Information Theory 69, 6293–6302.\n\n\n\nKitaev, A. (2003). Fault-tolerant quantum computation by anyons. Annals of Physics 303, 2–30.\n\n\n\nKnill, E. and Laflamme, R. (1996). Concatenated quantum codes, arXiv preprint quant-ph/9608012.\n\n\n\nKoenig, R. and Smolin, J. A. (2014). How to efficiently select an arbitrary Clifford group element. Journal of Mathematical Physics 55, 122202.\n\n\n\nKoukoulekidis, N.; IV, F. Š.; Leib, M. and Pereira, F. R. (2024). Small Quantum Codes from Algebraic Extensions of Generalized Bicycle Codes, arXiv:2401.07583 [quant-ph].\n\n\n\nKrastanov, S.; de la Cerda, A. S. and Narang, P. (2020). Heterogeneous Multipartite Entanglement Purification for Size-Constrained Quantum Devices, arXiv preprint arXiv:2011.11640.\n\n\n\nLacroix, N.; Bourassa, A.; Heras, F. J.; Zhang, L. M.; Bausch, J.; Senior, A. W.; Edlich, T.; Shutty, N.; Sivak, V.; Bengtsson, A. and others (2024). Scaling and logic in the color code on a superconducting quantum processor, arXiv preprint arXiv:2412.14256.\n\n\n\nLafiamme, R.; Miquel, C.; Paz, J. P. and Zurek, W. H. (1996). Perfect quantum error correction code. Physical Review Letters 77, 198–201.\n\n\n\nLandahl, A. J.; Anderson, J. T. and Rice, P. R. (2011). Fault-tolerant quantum computing with color codes, arXiv:1108.5738 [quant-ph].\n\n\n\nLeverrier, A.; Tillich, J.-P. and Zémor, G. (2015). Quantum expander codes. In: 2015 IEEE 56th Annual Symposium on Foundations of Computer Science (IEEE); pp. 810–824.\n\n\n\nLi, Y.; Chen, X. and Fisher, M. P. (2019). Measurement-driven entanglement transition in hybrid quantum circuits. Physical Review B 100, 134306.\n\n\n\nLiang, Z.; Liu, K.; Song, H. and Chen, Y.-A. (2025). Generalized toric codes on twisted tori for quantum error correction, arXiv:2503.03827 [quant-ph].\n\n\n\nLiang, Z.; Xu, Y.; Iosue, J. T. and Chen, Y.-A. (2024). Extracting Topological Orders of Generalized Pauli Stabilizer Codes in Two Dimensions. PRX Quantum 5.\n\n\n\nLin, H.-K. and Pryadko, L. P. (2024). Quantum two-block group algebra codes. Physical Review A 109, 022407.\n\n\n\nLin, S. and Costello, D. (2024). Error Control Coding (Pearson).\n\n\n\nvan Lint, J. H.; van der Geer, G.; van Lint, J. H. and van der Geer, G. (1988). Classical Goppa codes. Introduction to Coding Theory and Algebraic Geometry, 22–24.\n\n\n\nLubin, M.; Dowson, O.; Garcia, J. D.; Huchette, J.; Legat, B. and Vielma, J. P. (2023). JuMP 1.0: Recent improvements to a modeling language for mathematical optimization. Mathematical Programming Computation 15, 581–589.\n\n\n\nMacKay, D. J.; Mitchison, G. and McFadden, P. L. (2004). Sparse-graph codes for quantum error correction. IEEE Transactions on Information Theory 50, 2315–2330.\n\n\n\nMakhorin, A. (2008). GLPK (GNU linear programming kit), http://www. gnu. org/s/glpk/glpk. html.\n\n\n\nMcEliece, R. J. (1978). A public-key cryptosystem based on algebraic. Coding Thv 4244, 114–116.\n\n\n\nMuller, D. E. (1954). Application of Boolean algebra to switching circuit design and to error detection. Transactions of the IRE professional group on electronic computers, 6–12.\n\n\n\nNaghipour, A.; Jafarizadeh, M. A. and Shahmorad, S. (2015). Quantum stabilizer codes from Abelian and non-Abelian groups association schemes. International Journal of Quantum Information 13, 1550021.\n\n\n\nNahum, A.; Ruhman, J.; Vijay, S. and Haah, J. (2017). Quantum Entanglement Growth under Random Unitary Dynamics. Physical Review X 7, 031016.\n\n\n\nPanteleev, P. and Kalachev, G. (2021). Degenerate Quantum LDPC Codes With Good Finite Length Performance. Quantum 5, 585, arXiv:1904.02703 [quant-ph].\n\n\n\nPanteleev, P. and Kalachev, G. (Jun 2022). Asymptotically Good Quantum and Locally Testable Classical LDPC Codes. In: Proceedings of the 54th Annual ACM SIGACT Symposium on Theory of Computing (ACM, Rome Italy); pp. 375–388.\n\n\n\nPatterson, N. (1975). The algebraic decoding of Goppa codes. IEEE Transactions on Information Theory 21, 203–207.\n\n\n\nPecorari, L.; Jandura, S.; Brennen, G. K. and Pupillo, G. (2025). High-rate quantum LDPC codes for long-range-connected neutral atom registers. Nature Communications 16, 1111.\n\n\n\nPostema, J. J. and Kokkelmans, S. J. (2025). Existence and Characterisation of Bivariate Bicycle Codes, arXiv:2502.17052 [quant-ph].\n\n\n\nPryadko, L. P.; Shabashov, V. A. and Kozin, V. K. (2023). QDistRnd: A GAP package for computing the distance of quantum error-correcting codes, arXiv preprint arXiv:2308.15140.\n\n\n\nQuintavalle, A. O.; Vasmer, M.; Roffe, J. and Campbell, E. T. (2021). Single-shot error correction of three-dimensional homological product codes. PRX Quantum 2, 020340.\n\n\n\nQuintavalle, A. O.; Vasmer, M.; Roffe, J. and Campbell, E. T. (2021). Single-Shot Error Correction of Three-Dimensional Homological Product Codes. PRX Quantum 2.\n\n\n\nRaaphorst, S. (2003). Reed-muller codes. Carleton University, May 9.\n\n\n\nRaveendran, N.; Rengaswamy, N.; Rozpędek, F.; Raina, A.; Jiang, L. and Vasić, B. (2022). Finite Rate QLDPC-GKP Coding Scheme That Surpasses the CSS Hamming Bound. Quantum 6, 767.\n\n\n\nReed, I. S. (1954). A class of multiple-error-correcting codes and the decoding scheme. IEEE Transactions on Information Theory 4, 38–49.\n\n\n\nRoffe, J.; Cohen, L. Z.; Quintavalle, A. O.; Chandra, D. and Campbell, E. T. (2023). Bias-Tailored Quantum LDPC Codes. Quantum 7, 1005.\n\n\n\nSabo, E. (2022). Trellis Decoding And Applications For Quantum Error Correction. Ph.D. Thesis, Georgia Tech.\n\n\n\nShor, P. W. (1995). Scheme for reducing decoherence in quantum computer memory. Physical review A 52, R2493.\n\n\n\nSingh, H. (2019). Code based cryptography: Classic mceliece, arXiv preprint arXiv:1907.12754.\n\n\n\nSteane, A. M. (1996). Error correcting codes in quantum theory. Physical Review Letters 77, 793.\n\n\n\nSteane, A. M. (1999). Quantum reed-muller codes. IEEE Transactions on Information Theory 45, 1701–1703.\n\n\n\nSteane, A. M. (2007). A tutorial on quantum error correction. In: PROCEEDINGS-INTERNATIONAL SCHOOL OF PHYSICS ENRICO FERMI, Vol. 162 (IOS Press; Ohmsha; 1999); p. 1.\n\n\n\nSugiyama, Y.; Kasahara, M.; Hirasawa, S. and Namekawa, T. (1975). A method for solving key equation for decoding Goppa codes. Information and Control 27, 87–99.\n\n\n\nTerhal, B. M. (2015). Quantum error correction for quantum memories. Rev. Mod. Phys. 87, 307–346.\n\n\n\nTillich, J.-P. and Zémor, G. (2006). On the minimum distance of structured LDPC codes with two variable nodes of degree 2 per parity-check equation. In: 2006 IEEE International Symposium on Information Theory (IEEE); pp. 1549–1553.\n\n\n\nTillich, J.-P. and Zémor, G. (2013). Quantum LDPC codes with positive rate and minimum distance proportional to the square root of the blocklength. IEEE Transactions on Information Theory 60, 1193–1202.\n\n\n\nVan Den Berg, E. (2021). A simple method for sampling random Clifford operators. In: 2021 IEEE International Conference on Quantum Computing and Engineering (QCE) (IEEE); pp. 54–59.\n\n\n\nVardy, A. (1997). The intractability of computing the minimum distance of a code. IEEE Transactions on Information Theory 43, 1757–1766.\n\n\n\nVoss, L.; Xian, S. J.; Haug, T. and Bharti, K. (2024). Multivariate Bicycle Codes, arXiv:2406.19151 [quant-ph].\n\n\n\nWang, M. and Mueller, F. (2024). Coprime Bivariate Bicycle Codes and their Properties, arXiv preprint arXiv:2408.10001.\n\n\n\nWang, R.; Lin, H.-K. and Pryadko, L. P. (2023). Abelian and non-Abelian quantum two-block codes. In: 2023 12th International Symposium on Topics in Coding (ISTC) (IEEE); pp. 1–5.\n\n\n\nWang, R. and Pryadko, L. P. (2022). Distance bounds for generalized bicycle codes, arXiv:2203.17216 [quant-ph].\n\n\n\nWhite, G. and Grassl, M. (2006). A new minimum weight algorithm for additive codes. In: 2006 IEEE International Symposium on Information Theory (IEEE); pp. 1119–1123.\n\n\n\nWilde, M. M. (2009). Logical operators of quantum codes. Physical Review A 79, 062322.\n\n\n\nWirtz, M. (1988). On the parameters of Goppa codes. IEEE transactions on information theory 34, 1341–1343.\n\n\n\nXu, Q.; Zhou, H.; Zheng, G.; Bluvstein, D.; Ataides, J. P.; Lukin, M. D. and Jiang, L. (2024). Fast and Parallelizable Logical Computation with Homological Product Codes, arXiv:2407.18490 [quant-ph].\n\n\n\nYu, S.; Bierbrauer, J.; Dong, Y.; Chen, Q. and Oh, C. H. (2013). All the Stabilizer Codes of Distance 3. IEEE Transactions on Information Theory 59, 5179–5185.\n\n\n\nZeng, W. and Pryadko, L. P. (2019). Higher-Dimensional Quantum Hypergraph-Product Codes with Finite Rates. Physical Review Letters 122.\n\n\n\n","category":"page"},{"location":"noise/#noise","page":"Noise Processes","title":"Noise Processes","text":"","category":"section"},{"location":"noise/","page":"Noise Processes","title":"Noise Processes","text":"As seen in the list of possible gates, the simulator is capable of modeling different types of noise. If that is your goal, please consider using the available Monte Carlo simulator or the Symbolic Perturbative Expansion system.","category":"page"},{"location":"noise/","page":"Noise Processes","title":"Noise Processes","text":"The implemented types of noise include:","category":"page"},{"location":"noise/","page":"Noise Processes","title":"Noise Processes","text":"UnbiasedUncorrelatedNoise\nPauliNoise","category":"page"},{"location":"noise/","page":"Noise Processes","title":"Noise Processes","text":"The low-level functionality to work with noise is applynoise!, but most of the time you would probably just want to use PauliError,  NoisyGate, NoiseOp and NoiseOpAll.","category":"page"},{"location":"ecc_example_sim/#noisycircuits_pf_ecc_example","page":"ECC example","title":"ECC example with Pauli Frames","text":"","category":"section"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"warning: The documentation is incomplete\nWaiting for a better documentation than the small example below. Check out also the page on ECC performance evaluators","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"Consider Steane 7-qubit code:","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"using QuantumClifford\nusing QuantumClifford.ECC: Steane7, naive_syndrome_circuit, naive_encoding_circuit, parity_checks, code_s, code_n\nusing Quantikz\n\ncode = Steane7()\nH = parity_checks(code)","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"... and the corresponding encoding circuit","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"ecirc = naive_encoding_circuit(code)","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"... and the corresponding syndrome measurement circuit (the non-fault tolerant one)","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"scirc, _ = naive_syndrome_circuit(code)","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"The most straightforward way to start sampling syndromes is to set up a table of Pauli frames.","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"circuit = [ecirc..., scirc...]\nnframes = 4\nframes = pftrajectories(circuit; trajectories=nframes) # run the sims\npfmeasurements(frames)                                 # extract the measurements","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"The pftrajectories function is multithreaded. If you want more low-level control over these Pauli frame simulations, check out the PauliFrame structure, the other methods of pftrajectories, and the circuit compactifaction function compactify_circuit.","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"If you want to model Pauli errors, use:","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"The helper PauliError for unbiased Pauli noise operation acting on a given qubit\nThe lower level NoiseOp (for a single qubit) or NoiseOpAll (for all qubits) parameterized with a particular noise type, e.g. UnbiasedUncorrelatedNoise","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"errprob = 0.1\nerrors = [PauliError(i,errprob) for i in 1:code_n(code)]\nfullcircuit = [ecirc..., errors..., scirc...]","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"And running this noisy simulation:","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"frames = pftrajectories(fullcircuit; trajectories=nframes)\npfmeasurements(frames)","category":"page"},{"location":"stab-algebra-manual/#Stabilizer-Tableau-Algebra-Manual","page":"Manual","title":"Stabilizer Tableau Algebra Manual","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"The library consists of two main parts: Tools for working with the algebra of Stabilizer tableaux and tools specifically for efficient Circuit Simulation. This chapter discusses the former \"lower level\" Stabilizer tableau algebra tools.","category":"page"},{"location":"stab-algebra-manual/#Pauli-Operators","page":"Manual","title":"Pauli Operators","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"The PauliOperator object represents multi-qubit Pauli operator (1iIZXY^otimes n). It is stored in memory as a phase (a single byte where 0x0,0x1,0x2,0x3 corresponds to 1i-1-i) and two bit-arrays, for X and for Z components.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"You can create them with a P string.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> P\"-iXZ\"\n-iXZ","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Or by specifying phase and X/Z components:","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> PauliOperator(0x0,Bool[0,1,0],Bool[0,0,1])\n+ _XZ","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Both underscore and I can be used for identity.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> P\"I_XYZ\"\n+ __XYZ","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Multiplication with scalars or other Pauli operators works as expected, as well as tensor products of Pauli operators.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> -1im*P\"X\"\n-iX\n\njulia> P\"X\" * P\"Z\"\n-iY\n\njulia> P\"X\" ⊗ P\"Z\"\n+ XZ","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"One can check for commutativity with comm.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> comm(P\"X\",P\"Z\")\n0x01\n\njulia> comm(P\"XX\",P\"ZZ\")\n0x00","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"And check the phase of a product with prodphase.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> prodphase(P\"X\", P\"Z\")\n0x03\n\njulia> prodphase(P\"X\", P\"iZ\")\n0x00\n\njulia> prodphase(P\"X\",P\"Y\")\n0x01","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Indexing operations are available.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> p = P\"IXYZ\";\n\njulia> p[1], p[2], p[3], p[4]\n((false, false), (true, false), (true, true), (false, true))\n\njulia> p = P\"III\";\n\njulia> p[2] = (true, true);\n\njulia> p\n+ _Y_","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Including fancy indexing:","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> P\"IXYZ\"[[2,3]]\n+ XY\n\njulia> P\"IXYZ\"[[false,true,true,false]]\n+ XY","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"The operator is represented in memory by bit arrays (much denser than using byte arrays).","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> p = P\"-IXYZ\";\n\njulia> p.nqubits, p.xz\n(4, UInt64[0x0000000000000006, 0x000000000000000c])","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Views that give just the X or Z components of the xz bitarray are available through xview and zview.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> xview(P\"XYZI\")\n1-element view(::Vector{UInt64}, 1:1) with eltype UInt64:\n 0x0000000000000003","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"The convenience methods xbit and zbit give you Bool (GF2) vectors.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> xbit(P\"XYZI\")\n4-element Vector{Bool}:\n 1\n 1\n 0\n 0","category":"page"},{"location":"stab-algebra-manual/#Stabilizers","page":"Manual","title":"Stabilizers","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"A Stabilizer object is a tableau of Pauli operators. When the tableau is meant to represent a (pure or mixed) stabilizer state, all of these operators should commute (but that is not enforced, rather Stabilizer is a generic tableau data structure). It is stored in memory as a phase list and a bit-matrix for X and Z components. It can be instantiated by an S string, or with a number of different constructors.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"tip: Stabilizers and Destabilizers\nIn many cases you probably would prefer to use the MixedDestabilizer data structure, as it caries a lot of useful additional information, like tracking rank and destabilizer operators. Stabilizer has mostly a pedagogical value, and it is also used for slightly faster simulation of a particular subset of Clifford operations. See also the data structures discussion page.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> S\"-XX\n         +ZZ\"\n- XX\n+ ZZ\n\njulia> Stabilizer([P\"-XX\",P\"+ZZ\"])\n- XX\n+ ZZ\n\njulia> Stabilizer([0x2, 0x0],\n                  Bool[1 1;\n                       0 0],\n                  Bool[0 0;\n                       1 1])\n- XX\n+ ZZ","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Direct sums can be performed,","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> S\"-XX\" ⊗ S\"ZZ\"\n- XX__\n+ __ZZ","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Indexing operations are available, including fancy indexing. Be careful about how phase information gets transferred during sub-indexing.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> s = S\"-XYZ\n             -ZIX\n             +XIZ\";\n\njulia> s[1]\n- XYZ\n\njulia> s[1,2]\n(true, true)\n\njulia> s[[3,1]]\n+ X_Z\n- XYZ\n\njulia> s[[3,1],[2]]\n+ _\n- Y","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Consistency at creation is not verified so nonsensical stabilizers can be created, both in terms of content and shape.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> S\"iX\n         +Z\"\n+iX\n+ Z","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Similarly to the Pauli operators, a bit array representation is used.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> s = S\"-XXX\n             +ZZI\n             -IZZ\"\n- XXX\n+ ZZ_\n- _ZZ\n\njulia> phases(s), tab(s).xzs\n(UInt8[0x02, 0x00, 0x02], UInt64[0x0000000000000007 0x0000000000000000 0x0000000000000000; 0x0000000000000000 0x0000000000000003 0x0000000000000006])","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"And there are convenience functions that can extract the corresponding binary check matrix.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> stab_to_gf2(s)\n3×6 Matrix{Bool}:\n 1  1  1  0  0  0\n 0  0  0  1  1  0\n 0  0  0  0  1  1","category":"page"},{"location":"stab-algebra-manual/#Canonicalization-of-Stabilizers","page":"Manual","title":"Canonicalization of Stabilizers","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Canonicalization (akin to Gaussian elimination over F(2,2)) is implemented in the canonicalize! function. Besides the default canonicalization prescription, alternative ones are available as described in the canonicalization page.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> s = S\"-XXX\n             +ZZX\n             +III\";\n\njulia> canonicalize!(s)\n+ YY_\n+ ZZX\n+ ___","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"If phases are inconsequential, the operations can be faster by not tracking and updating them.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> s = S\"-XXX\n             +ZZX\n             +III\";\n\njulia> canonicalize!(s; phases=false)\n- YY_\n+ ZZX\n+ ___","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"These operations are in place (as customarily signified by \"!\").","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> s = S\"-XXX\n             +ZZX\n             +III\";\n\njulia> canonicalize!(s; phases=false);\n\njulia> s\n- YY_\n+ ZZX\n+ ___","category":"page"},{"location":"stab-algebra-manual/#Projective-Measurements","page":"Manual","title":"Projective Measurements","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"The project! function is used to perform generic projective measurements.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"tip: Single qubit projections\nIf you know your Pauli measurement operator acts on a single qubit, there are much faster projection functions available, discussed in the next section. Namely projectX!, projectY!, and projectZ!.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"To observe the effect of different projections, we will start with a GHZ state.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> s = S\"-XXX\n             +ZZI\n             -IZZ\";","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"The project! function returns the new stabilizer, the index where the anticommutation was detected, and the result of the projection (nothing being an undetermined result). For instance here we project on an operator that does not commute with all stabilizer generators.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> project!(copy(s), P\"ZII\")[1]\n+ Z__\n+ ZZ_\n- _ZZ","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Importantly, when there is an undetermined result, we return nothing and leave the phase of the new stabilizer the same as the phase of the projection operator. If you want to perform a Monte Carlo simulation, you need to randomize the phase of the stabilizer at the anticommuting index yourself. For instance, one can do:","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> newstate, anticomindex, result = project!(copy(s), P\"XII\")\n       if isnothing(result)\n           phases(newstate)[anticomindex] = rand([0x0,0x2])\n       end\n       result, anticomindex\n(nothing, 2)","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Of course, this is a rather cumbersome way to run a simulation, so we also provide projectrand! which does the necessary randomization automatically, for cases where you do not need the fine grained control of project!.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"We can project on a commuting operator, hence no anticommuting terms (the index is zero), and the result is perfectly determined (-1, or in our convention to represent the phase, 0x2).","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> project!(copy(s), P\"-ZZI\")\n(Stabilizer 3×3, 0, 0x02)","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"When the projection is consistent with the stabilizer (i.e. the measurement result is not nothing), this would trigger an expensive canonicalization procedure in order to calculate the measurement result (unless we are using more advanced data structures to represent the state, which are discussed later). If all you want to know is whether the projection is consistent with the stabilizer, but you do not care about the measurement result, you can skip the canonicalization and calculation of the result.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> project!(copy(s), P\"-ZZI\", keep_result=false)\n(Stabilizer 3×3, 0, nothing)","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Lastly, in either case, you can skip the calculation of the phases as well, if they are unimportant.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> project!(copy(s), P\"ZZI\", phases=false)\n(Stabilizer 3×3, 0, 0x00)","category":"page"},{"location":"stab-algebra-manual/#Sparse-single-qubit-measurements","page":"Manual","title":"Sparse single-qubit measurements","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"In many circumstances only a single-qubit operator is being measured. In that case one should use the projectX!, projectY!, and projectZ! functions as they are much faster thanks to tracking only a single qubit. They have versions that randomize the phase as necessary as well:  projectXrand!, projectYrand!, and projectZrand!.","category":"page"},{"location":"stab-algebra-manual/#Gate-like-interface","page":"Manual","title":"Gate-like interface","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"If you do not need all this boilerplate, and especially if you want to perform the randomization automatically, you can use the gate-like \"symbolic/sparse/named\" operations sMX, sMY, and sMZ, that perform the measurement and the necessary randomization of phase. If the measurement result is to be stored, you can use the Register structure that stores both stabilizer tableaux and bit values.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> state = Register(ghz(3), [false,false])\nRegister{Vector{UInt8}, Matrix{UInt64}}(Rank 3 stabilizer\n+ Z__\n+ _X_\n+ __X\n═════\n+ XXX\n+ ZZ_\n+ Z_Z\n═════\n, Bool[0, 0])\n\njulia> apply!(state, sMX(3,2)) # which qubit is measured and in which bit it is stored\nRegister{Vector{UInt8}, Matrix{UInt64}}(Rank 3 stabilizer\n+ Z__\n+ _X_\n+ Z_Z\n═════\n+ XXX\n+ ZZ_\n- __X\n═════\n, Bool[0, 1])\n\njulia> bitview(state)\n2-element Vector{Bool}:\n 0\n 1","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Or you can use the projectXrand!, projectYrand!, and projectZrand! if you prefer a function-call interface.","category":"page"},{"location":"stab-algebra-manual/#Partial-Traces","page":"Manual","title":"Partial Traces","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Partial trace (using traceout!) over even a single qubit might cause many of them to decohere due to entanglement.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> ghz = S\"XXX\n               ZZ_\n               _ZZ\";\n\njulia> traceout!(ghz, [1])\n+ _ZZ\n+ ___\n+ ___","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"This is somewhat more elegant when the datastructure being used explicitly supports mixed states.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> ghz = MixedStabilizer(S\"XXX\n                               ZZ_\n                               _ZZ\");\n\njulia> traceout!(ghz, [1])\n+ _ZZ","category":"page"},{"location":"stab-algebra-manual/#Generating-a-Pauli-Operator-with-Stabilizer-Generators","page":"Manual","title":"Generating a Pauli Operator with Stabilizer Generators","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"The generate! function attempts to generate a Pauli operator by multiplying together the operators belonging to a given stabilizer (or reports their independence). This particular function requires the stabilizer to be already canonicalized.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> s = S\"-XXX\n             +ZZI\n             -IZZ\";\n\njulia> s = canonicalize!(s)\n- XXX\n- Z_Z\n- _ZZ","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"It modifies the Pauli operator in place, reducing it to identity if possible. The leftover phase is present to indicate if the phase itself could not have been canceled. The list of indices specifies which rows of the stabilizer were used to generated the desired Pauli operator.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> generate!(P\"XYY\", s)\n(- ___, [1, 3])","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Phases can be neglected, for higher performance.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> generate!(P\"XYY\", s, phases=false)\n(+ ___, [1, 3])","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"If the Pauli operator can not be generated by the stabilizer, nothing value is returned.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> generate!(P\"ZZZ\", s)\n\njulia> generate!(P\"XZX\", s)\n\njulia> generate!(P\"YYY\", s)","category":"page"},{"location":"stab-algebra-manual/#Clifford-Operators","page":"Manual","title":"Clifford Operators","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"The CliffordOperator structure represents a linear mapping between stabilizers (which should also preserve commutation relationships, but that is not checked at instantiation). These are n-qubit dense tableaux, representing an operation on n-qubit states. For single- or two-qubit gates, it is much more efficient to use small sparse/named/symbolic Clifford operators. A number of predefined Clifford operators are available, their name prefixed with t to mark them as dense tableaux.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> tHadamard\nX₁ ⟼ + Z\nZ₁ ⟼ + X\n\njulia> tPhase\nX₁ ⟼ + Y\nZ₁ ⟼ + Z\n\njulia> tCNOT\nX₁ ⟼ + XX\nX₂ ⟼ + _X\nZ₁ ⟼ + Z_\nZ₂ ⟼ + ZZ\n\njulia> tId1\nX₁ ⟼ + X\nZ₁ ⟼ + Z","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Chaining and tensor products are possible. Same for qubit permutations.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> tHadamard ⊗ tPhase\nX₁ ⟼ + Z_\nX₂ ⟼ + _Y\nZ₁ ⟼ + X_\nZ₂ ⟼ + _Z\n\njulia> tHadamard * tPhase\nX₁ ⟼ - Y\nZ₁ ⟼ + X\n\njulia> permutesubsystem(tCNOT, [2,1])\nX₁ ⟼ + X_\nX₂ ⟼ + XX\nZ₁ ⟼ + ZZ\nZ₂ ⟼ + _Z","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"You can create custom Clifford operators with C-strings or with a list of Pauli operators.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> C\"-ZZ\n         +_Z\n         -X_\n         +XX\"\nX₁ ⟼ - ZZ\nX₂ ⟼ + _Z\nZ₁ ⟼ - X_\nZ₂ ⟼ + XX\n\njulia> CliffordOperator([P\"-ZZ\", P\"_Z\", P\"-X_\", P\"XX\"])\nX₁ ⟼ - ZZ\nX₂ ⟼ + _Z\nZ₁ ⟼ - X_\nZ₂ ⟼ + XX","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Naturally, the operators can be applied to stabilizer states. This includes high performance in-place operations (and the phase can be neglected with phases=false for faster computation).","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> tCNOT * S\"X_\"\n+ XX\n\njulia> s = S\"X_\";\n\njulia> apply!(s,tCNOT)\n+ XX","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Sparse applications where a small Clifford operator is applied only on a particular subset of a larger stabilizer is also possible, but in such circumstances it is useful to consider using symbolic/sparse/named operators too.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> s = S\"Z_YX\";\n\njulia> apply!(s, tCNOT, [4,2]) # Apply the CNOT on qubits 4 and 2\n+ ZXYX","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Pauli operators act as Clifford operators too (but they are rather boring, as they only change signs).","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> P\"XII\" * S\"ZXX\"\n- ZXX","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Internally, the CliffordOperator structure simply stores the tableau representation of the operation.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"The apply! function is efficiently multithreaded for CliffordOperators. To start multithreaded Julia, use julia -t<N> where <N> specifies the number of threads.","category":"page"},{"location":"stab-algebra-manual/#Symbolic-Clifford-Operators","page":"Manual","title":"Symbolic/Sparse/Named Clifford Operators","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Much faster implementations for a number of common Clifford operators are available. They are stored as special named small structs, instead of as a full tableau. These are the subtypes of AbstractSingleQubitOperator and AbstractTwoQubitOperator. Currently these are:","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"using QuantumClifford # hide\nusing InteractiveUtils # hide\nsubtypes(QuantumClifford.AbstractSingleQubitOperator)","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"subtypes(QuantumClifford.AbstractTwoQubitOperator)","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Generally, they have the prefix s for symbolic/small/sparse. They are used slightly differently, as one needs to specify the qubits on which they act while instantiating them:","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> sHadamard(2)\nsHadamard on qubit 2\nX₁ ⟼ + Z\nZ₁ ⟼ + X\n\njulia> sHadamard(2)*S\"XXX\"\n+ XZX\n\njulia> sCNOT(2,3)*S\"XYY\"\n- XXZ","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"The apply! function is efficiently multithreaded for these symbolic operators as well. To start multithreaded Julia, use julia -t<N> where <N> specifies the number of threads.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Symbolic projectors on single qubits also exist: sMX, sMY, sMZ. When used with the Register state representation, they can store the measurement results in the corresponding classical register.","category":"page"},{"location":"stab-algebra-manual/#Destabilizers","page":"Manual","title":"Destabilizers","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Slightly abusing the name: What we call \"destabilizers\" here is a stabilizer and its destabilizing operators saved together. They are implemented with the Destabilizer object and are initialized from a stabilizer.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> s=S\"-XXX\n           -ZZI\n           +IZZ\";\n\njulia> d = Destabilizer(s)\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z__\n+ _XX\n+ __X\n𝒮𝓉𝒶𝒷━\n- XXX\n- ZZ_\n+ _ZZ","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"They have convenience methods to extract only the stabilizer and destabilizer pieces:","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> stabilizerview(d)\n- XXX\n- ZZ_\n+ _ZZ\n\njulia> destabilizerview(d)\n+ Z__\n+ _XX\n+ __X","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Importantly commuting projections are much faster when tracking the destabilizer as canonicalization is not necessary (an mathcalO(n^2) complexity because it avoids the expensive mathcalO(n^3) canonicalization operation).","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> project!(d,P\"ZZI\")\n(Destablizer 3×3, 0, 0x02)","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Non-commuting projections are just as fast as when using only stabilizers.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> project!(d,P\"ZZZ\")\n(Destablizer 3×3, 1, nothing)","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Clifford operations can be applied the same way they are applied to stabilizers.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> apply!(d,tCNOT⊗tHadamard)\n𝒟ℯ𝓈𝓉𝒶𝒷\n- X_Z\n+ _XZ\n+ X__\n𝒮𝓉𝒶𝒷━\n+ _ZX\n- _Z_\n+ ZZX","category":"page"},{"location":"stab-algebra-manual/#Mixed-States","page":"Manual","title":"Mixed States","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Both the Stabilizer and Destabilizer structures have more general forms that enable work with mixed stabilizer states. They are the MixedStabilizer and MixedDestabilizer structures, described in Mixed States. More information that can be seen in the data structures page, which expands upon the algorithms available for each structure.","category":"page"},{"location":"stab-algebra-manual/#Random-States-and-Circuits","page":"Manual","title":"Random States and Circuits","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"random_clifford, random_stabilizer, and enumerate_cliffords can be used for the generation of random states.","category":"page"},{"location":"tutandpub/#tutandpub","page":"Tutorials and Publications","title":"Tutorials and Publications","text":"","category":"section"},{"location":"tutandpub/","page":"Tutorials and Publications","title":"Tutorials and Publications","text":"This list has a number of notebooks with tutorials, examples, and reproduction of published results (some of these results originally obtained with this very library).","category":"page"},{"location":"tutandpub/#On-the-topic-of-explicit-use-of-the-Tableaux-formalism-for-Stabilizer-states","page":"Tutorials and Publications","title":"On the topic of explicit use of the Tableaux formalism for Stabilizer states","text":"","category":"section"},{"location":"tutandpub/","page":"Tutorials and Publications","title":"Tutorials and Publications","text":"Quantum coding with low-depth random circuits reproducing results from (Gullans et al., 2021). view on nbviewer.jupyter.org","category":"page"},{"location":"tutandpub/#On-the-Monte-Carlo-and-Perturbative-Expansions-for-**Noisy**-Clifford-circuits","page":"Tutorials and Publications","title":"On the Monte Carlo and Perturbative Expansions for Noisy Clifford circuits","text":"","category":"section"},{"location":"tutandpub/","page":"Tutorials and Publications","title":"Tutorials and Publications","text":"In-depth study of multi-partite entanglement purification circuits reproducing results from (Krastanov et al., 2020). view on nbviewer.jupyter.org\nComparing the Monte Carlo and Perturbative method for noisy circuit simulations. view on nbviewer.jupyter.org\nShowcasing symbolic perturbative expansions of noisy circuits. view on nbviewer.jupyter.org","category":"page"},{"location":"noisycircuits_API/#Full-API-(autogenerated)","page":"API","title":"Full API (autogenerated)","text":"","category":"section"},{"location":"noisycircuits_API/","page":"API","title":"API","text":"warning: Unstable\nThis is experimental functionality with an unstable API.","category":"page"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.ConditionalGate","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.ConditionalGate","text":"A conditional gate that either performs truegate or falsegate, depending on the value of controlbit.\n\n\n\n\n\n","category":"type"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.DecisionGate","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.DecisionGate","text":"A conditional gate that performs one of the gates, depending on the output of decisionfunction applied to the entire classical bit register.\n\n\n\n\n\n","category":"type"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.NoisyBellMeasurement","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.NoisyBellMeasurement","text":"A Bell measurement in which each of the measured qubits has a chance to have flipped.\n\n\n\n\n\n","category":"type"},{"location":"noisycircuits_perturb/#noisycircuits_perturb","page":"Perturbative Expansions","title":"Perturbative expansions for simulating noisy Clifford circuits","text":"","category":"section"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"This module enables the simulation of noisy Clifford circuits through a perturbative expansion in the noise parameter (assuming the noise is small). Instead of simulating many Monte Carlo trajectories, only the leading order trajectories are exhaustively enumerated and simulated, supporting even obtaining symbolic expressions for figures of merit.","category":"page"},{"location":"noisycircuits_perturb/#Purification-Circuit-Example","page":"Perturbative Expansions","title":"Purification Circuit Example","text":"","category":"section"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"Here is an example of a purification circuit (the same circuit seen in the Monte Carlo example)","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"using QuantumClifford # hide\nusing QuantumClifford.Experimental.NoisyCircuits # hide\nusing Quantikz # hide\nusing QuantumClifford.ECC # hide\ngood_bell_state = S\"XX\n                    ZZ\"\ncanonicalize_rref!(good_bell_state)\ninitial_state = MixedDestabilizer(good_bell_state⊗good_bell_state)\n\ng1 = sCNOT(1,3) # CNOT between qubit 1 and qubit 3 (both with Alice)\ng2 = sCNOT(2,4) # CNOT between qubit 2 and qubit 4 (both with Bob)\nm = BellMeasurement([sMX(3),sMX(4)]) # Bell measurement on qubit 3 and 4\nv = VerifyOp(good_bell_state,[1,2]) # Verify that qubit 1 and 2 indeed form a good Bell pair\nepsilon = 0.01 # The error rate\nn = NoiseOpAll(UnbiasedUncorrelatedNoise(epsilon))\n\n# This circuit performs a depolarization at rate `epsilon` to all qubits,\n# then bilater CNOT operations\n# then a Bell measurement\n# followed by checking whether the final result indeed corresponds to the correct Bell pair.\ncircuit = [n,g1,g2,m,v]\n\npetrajectories(initial_state, circuit)","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"For more examples, see the notebook comparing the Monte Carlo and Perturbative method or this tutorial on entanglement purification.","category":"page"},{"location":"noisycircuits_perturb/#Symbolic-expansions","page":"Perturbative Expansions","title":"Symbolic expansions","text":"","category":"section"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"The perturbative expansion method works with symbolic variables as well. One can use any of the symbolic libraries available in Julia and simply plug symbolic parameters in lieu of numeric parameters. A detailed example is available as a Jupyter notebook.","category":"page"},{"location":"noisycircuits_perturb/#Interface-for-custom-operations","page":"Perturbative Expansions","title":"Interface for custom operations","text":"","category":"section"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"If you want to create a custom gate type (e.g. calling it Operation), you need to definite the following methods.","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"applyop_branches!(s::T, g::Operation; max_order=1)::Vector{Tuple{T,Symbol,Real,Int}} where T is a tableaux type like Stabilizer or a Register. The Symbol is the status of the operation, the Real is the probability for that branch, and the Int is the order of that branch.","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"There is also applynoise_branches! which is convenient for use in NoisyGate, but you can also just make up your own noise operator simply by implementing applyop_branches! for it.","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"You can also consult the list of implemented operators.","category":"page"},{"location":"noisycircuits_perturb/#Error-Correction-in-Perturbative-Expansion-Simulations","page":"Perturbative Expansions","title":"Error Correction in Perturbative Expansion Simulations","text":"","category":"section"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"Here is an example that demonstrates the simulation of a noisy quantum circuit using perturbative expansions, where error correction is incorporated through a DecoderCorrectionGate. After encoding the Steane code and introducing noise, the decoder correction gate applies the (hopefully) most likely correction based on the measured syndrome, leading to a noticeable improvement in the logical success rate. This illustrates how perturbative expansion methods can be combined with error-correcting circuits to study performance under noise.","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"Some of the relevant structures and functions used in this code are:","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"Register\nTableDecoder\nDecoderCorrectionGate\npetrajectories","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"using QuantumClifford\nusing QuantumClifford.ECC: Steane7, parity_checks, naive_encoding_circuit, naive_syndrome_circuit, TableDecoder, DecoderCorrectionGate, code_n, code_s\n\ncode = parity_checks(Steane7()) #creates the stabilizer tableau for the Steane code\ndata = code_n(code)\nchecks = code_s(code)\nqbits = data+checks\nregister = Register(one(MixedDestabilizer, qbits), checks) # A register with 13 qubits, 7 data qubits and 6 ancillas\ndecoder = TableDecoder(code) # creates a decoder based on the Steane code\n\nnoiseless_state = one(MixedDestabilizer, data)\nencoding_circuit = naive_encoding_circuit(code) # circuit to encode a state in the Steane codespace\nmctrajectory!(noiseless_state, encoding_circuit) # applies each gate in ecirc to noiseless_state\nverify = VerifyOp(noiseless_state, 1:data) # prepare a \"tomographic\" verification operation, checking that the first 7 qubits of the register indeed form still the same code word\n\nsyndrome_circuit,_,_ = naive_syndrome_circuit(code) # the operations needed to extract the error syndrome\nepsilon = 0.1\nnoise = NoiseOp(UnbiasedUncorrelatedNoise(epsilon), (1:data)) # an op that introduces noise into the circuit\n\ncircuit = vcat(encoding_circuit, noise, syndrome_circuit, verify) ","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"we can run perturbative expansions with petrajectories.","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"pet = petrajectories(register, circuit; max_order=3)\npet","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"We see that the true_success rate is pretty terrible. In order to improve this rate with the help of error correction, we can use the DecoderCorrectionGate:","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"correction_gate = DecoderCorrectionGate(decoder, 1:data, 1:checks) # takes in the decoder, data qubits and syndrome bits as an input and guesses the most probable error correcting Pauli Operation based on the recorded syndrome","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"Let's include the correction gate in our list of circuit operations and place it after syndrome collection.","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"circuit = vcat(encoding_circuit, noise, syndrome_circuit, correction_gate, verify) \npet = petrajectories(register, circuit; max_order=3)\npet","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"We can see that the true_success rate has gone up significantly.","category":"page"},{"location":"graphs/#Graph-States","page":"Graph States","title":"Graph States","text":"","category":"section"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"warning: The `graphstate` API is not considered stable\ngraphstate returns a lot of information about encoding a given stabilizer state in a graph. A different API is being designed that streamlines the work with graph states.","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"Conversion to and from graph states is possible.","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"Consider a GHZ state:","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"using QuantumClifford # hide\nghz(4)","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"It can be converted to a graph state with graphstate","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"graphstate(ghz(4))[1]","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"using Random; Random.seed!(1); using QuantumClifford, GraphMakie, CairoMakie;\nf = Figure(size=(200,200))\na = Axis(f[1,1])\ngraphplot!(a,graphstate(ghz(4))[1])\nhidedecorations!(a); hidespines!(a)\na.aspect = DataAspect()\nsave(\"ghz4graph.png\", f); nothing","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"(Image: )","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"Notice that the initial GHZ state was not in the typical graph state form. We can see that explicitly by converting back and forth between the two forms:","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"julia> using Graphs, QuantumClifford\n\njulia> ghz(4)\n+ XXXX\n+ ZZ__\n+ _ZZ_\n+ __ZZ\n\njulia> Stabilizer(Graph(ghz(4)))\n+ XZZZ\n+ ZX__\n+ Z_X_\n+ Z__X","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"There is a set of single-qubit operations that can convert any stabilizer tableau into a state representable as a graph. These transformations are performed implicitly by the Graph constructor when converting from a Stabilizer. If you need the explicit transformation you can use the graphstate function that specifies which qubits require a Hadamard, Inverse Phase, or Phase Flip gate. The graph_gatesequence or graph_gate helper functions can be used to generate the exact operations:","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"julia> s = ghz(4)\n+ XXXX\n+ ZZ__\n+ _ZZ_\n+ __ZZ\n\njulia> g, h_idx, ip_idx, z_idx = graphstate(s);\n\njulia> gate = graph_gate(h_idx, ip_idx, z_idx, nqubits(s))\nX₁ ⟼ + X___\nX₂ ⟼ + _Z__\nX₃ ⟼ + __Z_\nX₄ ⟼ + ___Z\nZ₁ ⟼ + Z___\nZ₂ ⟼ + _X__\nZ₃ ⟼ + __X_\nZ₄ ⟼ + ___X\n\njulia> canonicalize!(apply!(s,gate)) == canonicalize!(Stabilizer(g))\ntrue","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"These converters also provides for a convenient way to create graph and cluster states, by using the helper constructors provided in Graphs.jl.","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"julia> Stabilizer(grid([4,1])) # Linear cluster state\n+ XZ__\n+ ZXZ_\n+ _ZXZ\n+ __ZX\n\njulia> Stabilizer(grid([2,2])) # Small 2D cluster state\n+ XZZ_\n+ ZX_Z\n+ Z_XZ\n+ _ZZX","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"Graphs are represented with the Graphs.jl package and plotting can be done both in Plots.jl and Makie.jl (with GraphMakie).","category":"page"},{"location":"ECC_API/#Full-ECC-API-(autogenerated)","page":"API","title":"Full ECC API (autogenerated)","text":"","category":"section"},{"location":"ECC_API/#QuantumClifford.ECC.CircuitCode","page":"API","title":"QuantumClifford.ECC.CircuitCode","text":"CircuitCode is defined by a given encoding circuit circ.\n\nn: qubit number\ncirc: the encoding circuit\nencode_qubits: the qubits to be encoded\n\nSee also: random_all_to_all_circuit_code, random_brickwork_circuit_code\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QuantumClifford.ECC.CommutationCheckECCSetup","page":"API","title":"QuantumClifford.ECC.CommutationCheckECCSetup","text":"Configuration for ECC evaluator that does not simulate any ECC circuits, rather it simply checks the commutation of the parity check and the Pauli error.\n\nThis is much faster than any other simulation method, but it is incapable of noisy-circuit simulations and thus useless for fault-tolerance studies.\n\nSee also: NaiveSyndromeECCSetup, ShorSyndromeECCSetup\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QuantumClifford.ECC.Concat","page":"API","title":"QuantumClifford.ECC.Concat","text":"Concat(c₁, c₂) is a code concatenation of two quantum codes (Knill and Laflamme, 1996).\n\nThe inner code c₁ and the outer code c₂. The construction is the following: replace each qubit in code c₂ with logical qubits encoded by code c₁. The resulting code will have n = n₁ × n₂ qubits and k = k₁ × k₂ logical qubits.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QuantumClifford.ECC.DecoderCorrectionGate","page":"API","title":"QuantumClifford.ECC.DecoderCorrectionGate","text":"Applies a Pauli correction on the data_qubits determined by the decoder using the corresponding syndrome_bits from the classical register.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QuantumClifford.ECC.DistanceMIPAlgorithm","page":"API","title":"QuantumClifford.ECC.DistanceMIPAlgorithm","text":"struct DistanceMIPAlgorithm <: AbstractDistanceAlg\n\nA Mixed Integer Programming (MIP) method for computing the code distance of CSS stabilizer codes by finding the minimum-weight non-trivial logical PauliOperator (either X-type or Z-type). Used with distance to select MIP as the method of finding the distance of a code.\n\nnote: Note\nRequires a JuMP-compatible MIP solver (e.g., HiGHS, SCIP).\nFor some stabilizer CSS codes, the X-distance and Z-distance are equal.\n\nlogical_qubit: index of the logical qubit to compute code distance for (nothing means compute for all logical qubits)\nlogical_operator_type: type of logical operator to consider (:X or :Z, defaults to :minXZ).\nsolver: JuMP-compatible MIP solver (e.g., HiGHS, SCIP)\nopt_summary: when true (default=false), prints the MIP solver's solution summary\ntime_limit: time limit (in seconds) for the MIP solver's execution (default=60.0)\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QuantumClifford.ECC.NaiveSyndromeECCSetup","page":"API","title":"QuantumClifford.ECC.NaiveSyndromeECCSetup","text":"Configuration for ECC evaluator that runs the simplest syndrome measurement circuit.\n\nThe circuit is being simulated (as opposed to doing only a quick commutation check). This circuit would give poor performance if there is non-zero gate noise.\n\nSee also: CommutationCheckECCSetup, ShorSyndromeECCSetup\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QuantumClifford.ECC.ShorSyndromeECCSetup","page":"API","title":"QuantumClifford.ECC.ShorSyndromeECCSetup","text":"Configuration for ECC evaluators that simulate the Shor-style syndrome measurement (without a flag qubit).\n\nThe simulated circuit includes:\n\nperfect noiseless encoding (encoding and its fault tolerance are not being studied here)\none round of \"memory noise\" after the encoding but before the syndrome measurement\nperfect preparation of entangled ancillary qubits\nnoisy Shor-style syndrome measurement (only two-qubit gate noise)\nnoiseless \"logical state measurement\" (providing the comparison data when evaluating the decoder)\n\nSee also: CommutationCheckECCSetup, NaiveSyndromeECCSetup\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QuantumClifford.ECC.TableDecoder","page":"API","title":"QuantumClifford.ECC.TableDecoder","text":"A simple look-up table decoder for error correcting codes.\n\nThe lookup table contains only weight=1 errors, thus it is small, but at best it provides only for distance=3 decoding.\n\nThe size of the lookup table would grow exponentially quickly for higher distances.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.code_k-Tuple{Stabilizer}","page":"API","title":"QECCore.code_k","text":"The number of logical qubits in a code.\n\nNote that when redundant rows exist in the parity check matrix, the number of logical qubits code_k(c) will be greater than code_n(c) - code_s(c), where the difference equals the redundancy.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QECCore.parity_matrix_x-Tuple{AbstractECC}","page":"API","title":"QECCore.parity_matrix_x","text":"Parity check boolean matrix of a code (only the X entries in the tableau, i.e. the checks for Z errors).\n\nOnly CSS codes have this method.\n\nSee also: parity_checks\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QECCore.parity_matrix_z-Tuple{AbstractECC}","page":"API","title":"QECCore.parity_matrix_z","text":"Parity check boolean matrix of a code (only the Z entries in the tableau, i.e. the checks for X errors).\n\nOnly CSS codes have this method.\n\nSee also: parity_checks\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.BeliefPropDecoder-Tuple","page":"API","title":"QuantumClifford.ECC.BeliefPropDecoder","text":"A simple Belief Propagation decoder built around tools from LDPCDecoders.jl.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.BitFlipDecoder-Tuple","page":"API","title":"QuantumClifford.ECC.BitFlipDecoder","text":"An Iterative Bitflip decoder built around tools from LDPCDecoders.jl.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.DDimensionalSurfaceCode-Tuple","page":"API","title":"QuantumClifford.ECC.DDimensionalSurfaceCode","text":"D-Dimensional Surface codes ((Berthusen et al., 2024), (Zeng and Pryadko, 2019))\n\nImplemented as a package extension with Oscar. Check the QuantumClifford documentation for more details on that extension.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.DDimensionalToricCode-Tuple","page":"API","title":"QuantumClifford.ECC.DDimensionalToricCode","text":"D-Dimensional Toric codes ((Berthusen et al., 2024), (Zeng and Pryadko, 2019))\n\nImplemented as a package extension with Oscar. Check the QuantumClifford documentation for more details on that extension.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.DoubleHomologicalProductCode-Tuple","page":"API","title":"QuantumClifford.ECC.DoubleHomologicalProductCode","text":"Double Homological Product codes ((Campbell, 2019)).\n\nImplemented as a package extension with Oscar. Check the QuantumClifford documentation for more details on that extension.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.ExtendedGeneralizedBicycleCode-Tuple","page":"API","title":"QuantumClifford.ECC.ExtendedGeneralizedBicycleCode","text":"Extended Generalized Bicycle codes ((Koukoulekidis et al., 2024))\n\nImplemented as a package extension with Hecke. Check the QuantumClifford documentation for more details on that extension.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.GeneralizedBicycleCode-Tuple","page":"API","title":"QuantumClifford.ECC.GeneralizedBicycleCode","text":"Generalized Bicycle codes ((Koukoulekidis et al., 2024))\n\nImplemented as a package extension with Hecke. Check the QuantumClifford documentation for more details on that extension.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.GeneralizedHyperGraphProductCode-Tuple","page":"API","title":"QuantumClifford.ECC.GeneralizedHyperGraphProductCode","text":"Generalized Hypergraph Product codes (Panteleev and Kalachev, 2021) Implemented as a package extension with Hecke. Check the QuantumClifford documentation for more details on that extension.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.GeneralizedToricCode-Tuple","page":"API","title":"QuantumClifford.ECC.GeneralizedToricCode","text":"Generalized Toric codes ((Liang et al., 2025))\n\nImplemented as a package extension with Oscar. Check the QuantumClifford documentation for more details on that extension.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.HomologicalProductCode-Tuple","page":"API","title":"QuantumClifford.ECC.HomologicalProductCode","text":"Homological Product codes ((Quintavalle et al., 2021), (Xu et al., 2024)).\n\nImplemented as a package extension with Oscar. Check the QuantumClifford documentation for more details on that extension.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.LPCode-Tuple","page":"API","title":"QuantumClifford.ECC.LPCode","text":"Lifted product codes ((Panteleev and Kalachev, 2021), (Panteleev and Kalachev, Jun 2022))\n\nImplemented as a package extension with Hecke. Check the QuantumClifford documentation for more details on that extension.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.LaCross-Tuple","page":"API","title":"QuantumClifford.ECC.LaCross","text":"La-cross codes ((Pecorari et al., 2025)) Implemented as a package extension with Hecke. Check the QuantumClifford documentation for more details on that extension.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.LiftedCode-Tuple","page":"API","title":"QuantumClifford.ECC.LiftedCode","text":"Classical codes lifted over a group algebra, used for lifted product code construction ((Panteleev and Kalachev, 2021), (Panteleev and Kalachev, Jun 2022))\n\nImplemented as a package extension with Hecke. Check the QuantumClifford documentation for more details on that extension.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.PyBeliefPropDecoder-Tuple","page":"API","title":"QuantumClifford.ECC.PyBeliefPropDecoder","text":"A Belief Propagation decoder built around tools from the python package ldpc available from the julia package PyQDecoders.jl.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.PyBeliefPropOSDecoder-Tuple","page":"API","title":"QuantumClifford.ECC.PyBeliefPropOSDecoder","text":"A Belief Propagation decoder with ordered statistics decoding, built around tools from the python package ldpc available from the julia package PyQDecoders.jl.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.PyMatchingDecoder-Tuple","page":"API","title":"QuantumClifford.ECC.PyMatchingDecoder","text":"A perfect matching decoder built around tools from the python package pymatching available from the julia package PyQDecoders.jl.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.TrivariateTricycleCode-Tuple","page":"API","title":"QuantumClifford.ECC.TrivariateTricycleCode","text":"Trivariate Tricycle codes ((Jacob et al., 2025)) Implemented as a package extension with Oscar. Check the QuantumClifford documentation for more details on that extension.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.bicycle_codes","page":"API","title":"QuantumClifford.ECC.bicycle_codes","text":"Implemented in a package extension with Hecke. Check the docs for the Hecke extension\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QuantumClifford.ECC.boundary_maps","page":"API","title":"QuantumClifford.ECC.boundary_maps","text":"Implemented in a package extension with Oscar. Check the docs for the Oscar extension\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, QuantumClifford.ECC.AbstractECCSetup, Int64}","page":"API","title":"QuantumClifford.ECC.evaluate_decoder","text":"Evaluate the performance of a given decoder (e.g. TableDecoder) and a given style of running an ECC code (e.g. ShorSyndromeECCSetup)\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.evaluate_decoder-Tuple{QuantumClifford.ECC.AbstractSyndromeDecoder, Vararg{Any, 5}}","page":"API","title":"QuantumClifford.ECC.evaluate_decoder","text":"Evaluate the performance of an error-correcting circuit.\n\nThis method requires you give the circuit that performs both syndrome measurements and (probably noiseless) logical state measurements. The faults matrix that translates an error vector into corresponding logical errors is necessary as well.\n\nThis is a relatively barebones method that assumes the user prepares necessary circuits, etc. It is a method that is used internally by more user-frienly methods providing automatic conversion of codes and noise models to the necessary noisy circuits.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.faults_matrix-Tuple{Stabilizer}","page":"API","title":"QuantumClifford.ECC.faults_matrix","text":"Error-to-logical-observable map (a.k.a. fault matrix) of a code.\n\nFor a code with n physical qubits and k logical qubits this function returns a 2k × 2n binary matrix O such that O[i,j] is true if the logical observable of index i is flipped by the single physical qubit error of index j. Indexing is such that:\n\nO[1:k,:] is the error-to-logical-X-observable map (logical X observable, i.e. triggered by logical Z errors)\nO[k+1:2k,:] is the error-to-logical-Z-observable map\nO[:,1:n] is the X-physical-error-to-logical-observable map\nO[n+1:2n,:] is the Z-physical-error-to-logical-observable map\n\nE.g. for k=1, n=10, then if O[2,5] is true, then the logical Z observable is flipped by a X₅ error; and if O[1,12] is true, then the logical X observable is flipped by a Z₂ error.\n\nOf note is that there is a lot of freedom in choosing the logical operations! A logical operator multiplied by a stabilizer operator is still a logical operator. Similarly there is a different fault matrix for each choice of logical operators. But once the logical operators are picked, the fault matrix is fixed.\n\nBelow we show an example that uses the Shor code. While it is not the smallest code, it is a convenient choice to showcase the importance of the fault matrix when dealing with degenerate codes where a correction operation and an error do not need to be the same.\n\nFirst, consider a single-qubit error, potential correction operations, and their effect on the Shor code:\n\njulia> using QuantumClifford.ECC: faults_matrix, Shor9\n\njulia> state = MixedDestabilizer(Shor9())\n𝒟ℯ𝓈𝓉𝒶𝒷━━━━━\n+ Z________\n+ ___Z_____\n+ _X_______\n+ __X______\n+ ____X____\n+ _____X___\n+ ______X__\n+ _______X_\n𝒳ₗ━━━━━━━━━\n+ ______XXX\n𝒮𝓉𝒶𝒷━━━━━━━\n+ XXX___XXX\n+ ___XXXXXX\n+ ZZ_______\n+ Z_Z______\n+ ___ZZ____\n+ ___Z_Z___\n+ ______Z_Z\n+ _______ZZ\n𝒵ₗ━━━━━━━━━\n+ Z__Z____Z\n\njulia> err_Z₁ = single_z(9,1) # the error we will simulate\n+ Z________\n\njulia> cor_Z₂ = single_z(9,2) # the correction operation we will perform\n+ _Z_______\n\njulia> err_Z₁ * state # observe that one of the syndrome bits is now flipped\n𝒟ℯ𝓈𝓉𝒶𝒷━━━━━\n+ Z________\n+ ___Z_____\n+ _X_______\n+ __X______\n+ ____X____\n+ _____X___\n+ ______X__\n+ _______X_\n𝒳ₗ━━━━━━━━━\n+ ______XXX\n𝒮𝓉𝒶𝒷━━━━━━━\n- XXX___XXX\n+ ___XXXXXX\n+ ZZ_______\n+ Z_Z______\n+ ___ZZ____\n+ ___Z_Z___\n+ ______Z_Z\n+ _______ZZ\n𝒵ₗ━━━━━━━━━\n+ Z__Z____Z\n\njulia> cor_Z₂ * err_Z₁ * state # we are back to a good code state\n𝒟ℯ𝓈𝓉𝒶𝒷━━━━━\n+ Z________\n+ ___Z_____\n- _X_______\n+ __X______\n+ ____X____\n+ _____X___\n+ ______X__\n+ _______X_\n𝒳ₗ━━━━━━━━━\n+ ______XXX\n𝒮𝓉𝒶𝒷━━━━━━━\n+ XXX___XXX\n+ ___XXXXXX\n+ ZZ_______\n+ Z_Z______\n+ ___ZZ____\n+ ___Z_Z___\n+ ______Z_Z\n+ _______ZZ\n𝒵ₗ━━━━━━━━━\n+ Z__Z____Z\n\njulia> bad_Z₆Z₉ = single_z(9,6) * single_z(9,9) # a different \"correction\" operation\n+ _____Z__Z\n\njulia> bad_Z₆Z₉ * err_Z₁ * state # the syndrome is trivial, but now we have a logical error\n𝒟ℯ𝓈𝓉𝒶𝒷━━━━━\n+ Z________\n+ ___Z_____\n+ _X_______\n+ __X______\n+ ____X____\n- _____X___\n+ ______X__\n+ _______X_\n𝒳ₗ━━━━━━━━━\n- ______XXX\n𝒮𝓉𝒶𝒷━━━━━━━\n+ XXX___XXX\n+ ___XXXXXX\n+ ZZ_______\n+ Z_Z______\n+ ___ZZ____\n+ ___Z_Z___\n+ ______Z_Z\n+ _______ZZ\n𝒵ₗ━━━━━━━━━\n+ Z__Z____Z\n\nThe success of cor_Z₂ and the failure of bad_Z₆Z₉ can be immediately seen through the fault matrix, as the wrong \"correction\" does not result in the same logical flips ad the error:\n\njulia> O = faults_matrix(Shor9())\n2×18 BitMatrix:\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1\n 1  0  0  1  0  0  0  0  1  0  0  0  0  0  0  0  0  0\n\njulia> O * stab_to_gf2(err_Z₁)\n2-element Vector{Int64}:\n 0\n 0\n\njulia> O * stab_to_gf2(cor_Z₂)\n2-element Vector{Int64}:\n 0\n 0\n\njulia> O * stab_to_gf2(bad_Z₆Z₉)\n2-element Vector{Int64}:\n 1\n 0\n\nWhile its use in this situation is rather contrived, the fault matrix is incredibly useful when running large scale simulations in which we want a separate fast error sampling process, (e.g. with Pauli frames) and a syndrome decoding process, without coupling between them. We just gather all our syndrome measurement and logical observables from the Pauli frame simulations, and then use them with the fault matrix in the syndrome decoding simulation.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.generalized_bicycle_codes","page":"API","title":"QuantumClifford.ECC.generalized_bicycle_codes","text":"Implemented in a package extension with Hecke. Check the docs for the Hecke extension\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QuantumClifford.ECC.haah_cubic_codes","page":"API","title":"QuantumClifford.ECC.haah_cubic_codes","text":"Implemented in a package extension with Hecke. Check the docs for the Hecke extension\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QuantumClifford.ECC.honeycomb_color_codes","page":"API","title":"QuantumClifford.ECC.honeycomb_color_codes","text":"Implemented in a package extension with Hecke.\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QuantumClifford.ECC.iscss-Union{Tuple{Type{T}}, Tuple{T}} where T<:AbstractECC","page":"API","title":"QuantumClifford.ECC.iscss","text":"Check if the code is CSS.\n\nReturn nothing if unknown from the type.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.isdegenerate","page":"API","title":"QuantumClifford.ECC.isdegenerate","text":"Check if the code is degenerate with respect to a given set of error or with respect to all \"up to d physical-qubit\" errors (defaulting to d=1).\n\njulia> using QuantumClifford.ECC\n\njulia> isdegenerate(Shor9(), [single_z(9,1), single_z(9,2)])\ntrue\n\njulia> isdegenerate(Shor9(), [single_z(9,1), single_x(9,1)])\nfalse\n\njulia> isdegenerate(Steane7(), 1)\nfalse\n\njulia> isdegenerate(Steane7(), 2)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QuantumClifford.ECC.naive_encoding_circuit-Tuple{Any}","page":"API","title":"QuantumClifford.ECC.naive_encoding_circuit","text":"Encoding physical qubits into a larger logical code.\n\nThe initial physical qubits to be encoded have to be at indices n-k+1:n.\n\ninfo: Encoding circuits are not fault-tolerant\nEncoding circuits are not fault-tolerant, and thus should not be used in practice. Instead, you should measure the stabilizers of the code and the logical observables, thus projecting into the code space (which can be fault-tolerant).\n\nThe canonicalization operation performed on the code may permute the qubits (see canonicalize_gott!). That permutation is corrected for with SWAP gates by default (controlled by the undoperm keyword argument).\n\nBased on (Cleve and Gottesman, 1997) and (Gottesman, 1997), however it seems the published algorithm has some errors. Consult the erratum, as well as the more recent (Grassl, 2002) and (Grassl, 2011), and be aware that this implementation also uses H instead of Z gates.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.naive_syndrome_circuit","page":"API","title":"QuantumClifford.ECC.naive_syndrome_circuit","text":"Generate the non-fault-tolerant stabilizer measurement cicuit for a given code instance or parity check tableau.\n\nUse the ancillary_index and bit_index arguments to offset where the corresponding part the circuit starts.\n\nReturns the circuit, the number of ancillary qubits that were added, and a list of bit indices that will store the measurement results.\n\nSee also: shor_syndrome_circuit\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QuantumClifford.ECC.parity_checks","page":"API","title":"QuantumClifford.ECC.parity_checks","text":"Parity check tableau of a code.\n\nSee also: parity_matrix_x and parity_matrix_z\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QuantumClifford.ECC.random_all_to_all_circuit_code","page":"API","title":"QuantumClifford.ECC.random_all_to_all_circuit_code","text":"Random all-to-all Clifford circuit code (Brown and Fawzi, Jul 2013).\n\nThe code of n qubits is generated by an all-to-all random Clifford circuit of ngates gates that encodes a subset of qubits encode_qubits into logical qubits.\n\nBecause of the random picking, the size of encode_qubits is the only thing that matters for the code, referred to as k.\n\nSee also: random_all_to_all_clifford_circuit, CircuitCode\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QuantumClifford.ECC.random_brickwork_circuit_code","page":"API","title":"QuantumClifford.ECC.random_brickwork_circuit_code","text":"Random brickwork Clifford circuit code (Brown and Fawzi, Jul 2013).\n\nThe code is generated by a brickwork random Clifford circuit of nlayers layers that encodes a subset of qubits encode_qubits into logical qubits.\n\nSee also: random_brickwork_clifford_circuit, CircuitCode\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QuantumClifford.ECC.shor_syndrome_circuit","page":"API","title":"QuantumClifford.ECC.shor_syndrome_circuit","text":"Generate the Shor fault-tolerant stabilizer measurement cicuit for a given code instance or parity check tableau.\n\nUse the ancillary_index and bit_index arguments to offset where the corresponding part the circuit starts. Ancillary qubits\n\nReturns:\n\nThe ancillary cat state preparation circuit.\nThe Shor syndrome measurement circuit.\nThe number of ancillary qubits that were added.\nThe list of bit indices that store the final measurement results.\n\nSee also: naive_syndrome_circuit\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QuantumClifford.ECC.two_block_group_algebra_codes","page":"API","title":"QuantumClifford.ECC.two_block_group_algebra_codes","text":"Implemented in a package extension with Hecke. Check the docs for the Hecke extension\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QuantumClifford.ECC.twobga_from_direct_product","page":"API","title":"QuantumClifford.ECC.twobga_from_direct_product","text":"Implemented in a package extension with Oscar. Check the docs for the Oscar extension\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QuantumClifford.ECC.twobga_from_fp_group","page":"API","title":"QuantumClifford.ECC.twobga_from_fp_group","text":"Implemented in a package extension with Oscar. Check the docs for the Oscar extension\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#The-base-library-QECCore.jl","page":"API","title":"The base library QECCore.jl","text":"","category":"section"},{"location":"ECC_API/#QECCore.AbstractCECC","page":"API","title":"QECCore.AbstractCECC","text":"AbstractCECC <: AbstractECC\n\nAbstract type for classical error correction code.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.AbstractCSSCode","page":"API","title":"QECCore.AbstractCSSCode","text":"AbstractCSSCode <: AbstractQECC\n\nAbstract type for Calderbank-Shor-Steane (CSS) code.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.AbstractDistanceAlg","page":"API","title":"QECCore.AbstractDistanceAlg","text":"AbstractDistanceAlg\n\nAbstract type representing algorithms for computing the minimum distance of quantum error correction codes.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.AbstractECC","page":"API","title":"QECCore.AbstractECC","text":"AbstractECC\n\nAbstract type for error correction code.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.AbstractQECC","page":"API","title":"QECCore.AbstractQECC","text":"AbstractQECC <: AbstractECC\n\nAbstract type for quantum error correction code.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.Bitflip3","page":"API","title":"QECCore.Bitflip3","text":"struct Bitflip3 <: AbstractQECC\n\nBitflip3 is a three-qubit bit-flip code that corrects single-qubit bit-flip error and does not detect any phase-flip errors.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.CSS","page":"API","title":"QECCore.CSS","text":"struct CSS <: AbstractCSSCode\n\nAn arbitrary CSS error correction code defined by its X and Z checks.\n\nFields\n\nHx::Matrix{Bool}: The parity check matrix of the X stabilizers.\nHz::Matrix{Bool}: The parity check matrix of the Z stabilizers.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.Cleve8","page":"API","title":"QECCore.Cleve8","text":"struct Cleve8 <: AbstractQECC\n\nA pedagogical example of a quantum error correcting [8,3] code used in (Cleve and Gottesman, 1997).\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.CyclicQuantumTannerGraphProduct","page":"API","title":"QECCore.CyclicQuantumTannerGraphProduct","text":"struct CyclicQuantumTannerGraphProduct <: AbstractCSSCode\n\nConstructs a 𝑄(𝐺₁ × 𝐺₂) quantum Tanner graph product code using cyclic Tanner graphs of length 2m.\n\njulia> using QuantumClifford; using QuantumClifford.ECC;\n\njulia> m = 1;\n\njulia> c = parity_checks(CyclicQuantumTannerGraphProduct(m))\n+ X_X_XX__\n+ _X_XXX__\n+ X_X___XX\n+ _X_X__XX\n+ ZZ__Z_Z_\n+ ZZ___Z_Z\n+ __ZZZ_Z_\n+ __ZZ_Z_Z\n\njulia> code_n(c), code_k(c)\n(8, 2)\n\njulia> m = 10;\n\njulia> c = parity_checks(CyclicQuantumTannerGraphProduct(m));\n\njulia> code_n(c), code_k(c)\n(800, 2)\n\nFields\n\nm::Int64\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.DelfosseReichardt","page":"API","title":"QECCore.DelfosseReichardt","text":"struct DelfosseReichardt <: AbstractCSSCode\n\nThe Delfosse-Reichardt code is derived from the classical self-orthogonal Reed-Muller codes. For parameters (r,m) = (1,3) and (2,4), (Delfosse and Reichardt, 2020) constructs families of:\n\n[[8p, 6(p-1), 4]] codes requiring 8 measurement rounds.\n[[16p, 14p-8, 4]] codes requiring 10 measurement rounds.\n\nDelfosse and Reichardt ((Delfosse and Reichardt, 2020)) utilize the [8, 4, 4] Reed-Muller code to construct [[8p, 6(p−1), 4]] self-dual CSS quantum codes for p ≥ 2, and the [16, 11, 4] Reed-Muller code to construct [[16p, 14p − 8, 4]] self-dual CSS quantum codes for p ≥ 1.  The parameter p specifies the number of blocks in the code construction.\n\nTo generalize the code construction, we extended the approach by using self-orthogonal Reed-Muller codes as base matrices for the Delfosse-Reichardt code.\n\nnote: Note\nSingle-shot distance-3 fault tolerance uses two Reed-Muller subfamilies: repetition codes and extended Hamming codes. Their structure may enable distance > 4 fault-tolerant sequences, raising a key open problem (Delfosse and Reichardt, 2020): \"Find a minimum-length sequence of parity check measurements for distance-7 fault-tolerant error correction with distance-8 Reed-Muller codes.\"\n\n[[8p, 6(p−1), 4]] code family\n\nAn [[16, 6, 4]] Delfosse-Reichardt code of from [[8p, 6(p−1), 4]] code family from (Delfosse and Reichardt, 2020).\n\njulia> using QuantumClifford; using QuantumClifford.ECC; # hide\n\njulia> p = 2; r = 1; m = 3;\n\njulia> c = parity_checks(DelfosseReichardt(p, r, m))\n+ XXXXXXXX________\n+ ________XXXXXXXX\n+ XXXX____XXXX____\n+ XX__XX__XX__XX__\n+ X_X_X_X_X_X_X_X_\n+ ZZZZZZZZ________\n+ ________ZZZZZZZZ\n+ ZZZZ____ZZZZ____\n+ ZZ__ZZ__ZZ__ZZ__\n+ Z_Z_Z_Z_Z_Z_Z_Z_\n\njulia> code_n(c), code_k(c)\n(16, 6)\n\n[[16p, 14p − 8, 4]] code family\n\nAn [[32, 20, 4]] Delfosse-Reichardt code of from [[16p, 14p − 8, 4]] code family.\n\njulia> using QuantumClifford; using QuantumClifford.ECC; # hide\n\njulia> p = 2; r = 2; m = 4;\n\njulia> c = parity_checks(DelfosseReichardt(p, r, m))\n+ XXXXXXXXXXXXXXXX________________\n+ ________________XXXXXXXXXXXXXXXX\n+ XXXXXXXX________XXXXXXXX________\n+ XXXX____XXXX____XXXX____XXXX____\n+ XX__XX__XX__XX__XX__XX__XX__XX__\n+ X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_\n+ ZZZZZZZZZZZZZZZZ________________\n+ ________________ZZZZZZZZZZZZZZZZ\n+ ZZZZZZZZ________ZZZZZZZZ________\n+ ZZZZ____ZZZZ____ZZZZ____ZZZZ____\n+ ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__\n+ Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_\n\njulia> code_n(c), code_k(c)\n(32, 20)\n\nFields\n\np::Int64: The number of blocks in the Delfosse-Reichardt CSS code.\nr::Int64: The order of the classical Reed-Muller code.\nm::Int64: The log-length of the classical Reed-Muller code.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.DelfosseReichardt823","page":"API","title":"QECCore.DelfosseReichardt823","text":"struct DelfosseReichardt823 <: AbstractQECC\n\nThe [[8p, 4p − 2, 3]] Delfosse-Reichardt Generalized [[8,2,3]] code is derived from the quantum [[8,2,3]] code. These codes were introduced by Delfosse and Reichardt in the paper Short Shor-style syndrome sequences (Delfosse and Reichardt, 2020). The parameter p specifies the number of blocks in the code construction.\n\nThe [[8, 2, 3]] non-CSS code serves as the seed code for constructing Delfosse-Reichardt generalized [[8p, 4p − 2, 3]]codes.\n\njulia> using QuantumClifford; using QuantumClifford.ECC; # hide\n\njulia> p = 1;\n\njulia> c = parity_checks(DelfosseReichardt823(p))\n+ ZZZZ____\n+ XXXX____\n+ ____ZZZZ\n+ ____XXXX\n+ _XYZ_XYZ\n+ _ZXY_ZXY\n\njulia> code_n(c), code_k(c)\n(8, 2)\n\nAn [[16, 6, 3]] Delfosse-Reichardt Generalized [[8,2,3]] code from (Delfosse and Reichardt, 2020).\n\njulia> using QuantumClifford; using QuantumClifford.ECC; # hide\n\njulia> p = 2;\n\njulia> c = parity_checks(DelfosseReichardt823(p))\n+ ZZZZ____________\n+ XXXX____________\n+ ____ZZZZ________\n+ ____XXXX________\n+ ________ZZZZ____\n+ ________XXXX____\n+ ____________ZZZZ\n+ ____________XXXX\n+ _XYZ_XYZ_XYZ_XYZ\n+ _ZXY_ZXY_ZXY_ZXY\n\njulia> code_n(c), code_k(c)\n(16, 6)\n\nFields\n\np::Int64: The number of blocks in the Delfosse-Reichardt generalized [[8, 2, 3]] code.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.DelfosseReichardtRepCode","page":"API","title":"QECCore.DelfosseReichardtRepCode","text":"struct DelfosseReichardtRepCode <: AbstractCSSCode\n\nThe [[4p, 2(p − 2), 4]] Delfosse-Reichardt repetition code is derived from the classical [4, 1, 4] repetition code and is used to construct quantum stabilizer code.\n\nThe [4, 1, 4] repetition code is a classical error-correcting code where each bit is repeated four times to improve error detection and correction. It is defined by the following parity-check matrix:\n\nbeginpmatrix\n1  1  1  1 \n0  0  1  1 \n0  1  0  1\nendpmatrix\n\nThe [[4p, 2(p − 2), 4]] codes were introduced by Delfosse and Reichardt in the paper Short Shor-style syndrome sequences (Delfosse and Reichardt, 2020). The parameter p specifies the number of blocks in the code construction. For the code to be valid, p must be a multiple of 2.\n\nAn [[24, 8, 4]] Delfosse-Reichardt repetition code from (Delfosse and Reichardt, 2020).\n\njulia> using QuantumClifford; using QuantumClifford.ECC # hide\n\njulia> p = 6;\n\njulia> c = parity_checks(DelfosseReichardtRepCode(p))\n+ XXXX____________________\n+ ____XXXX________________\n+ ________XXXX____________\n+ ____________XXXX________\n+ ________________XXXX____\n+ ____________________XXXX\n+ __XX__XX__XX__XX__XX__XX\n+ _X_X_X_X_X_X_X_X_X_X_X_X\n+ ZZZZ____________________\n+ ____ZZZZ________________\n+ ________ZZZZ____________\n+ ____________ZZZZ________\n+ ________________ZZZZ____\n+ ____________________ZZZZ\n+ __ZZ__ZZ__ZZ__ZZ__ZZ__ZZ\n+ _Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z\n\njulia> code_n(c), code_k(c)\n(24, 8)\n\nFields\n\np::Int64: The number of blocks in the Delfosse-Reichardt Repetition code.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.GallagerLDPC","page":"API","title":"QECCore.GallagerLDPC","text":"struct GallagerLDPC <: AbstractCECC\n\nConstruct a regular LDPC code parity-check matrix H using Gallager's original construction method (Gallager, 1962).\n\nMathematical Formulation\n\nThe parity-check matrix H is constructed as:\n\nbeginaligned\nH = beginbmatrix H_1  H_2  vdots  H_w_c endbmatrix\nendaligned\n\nwhere each submatrix H_d is a μ  μw_r binary matrix with:\n\nRow weight w_r (number of 1s per row)\nColumn weight 1 (each column has exactly one 1)\n\nThe first submatrix H_1 has a specific structure where row i (1  i  μ) contains  its w_r 1s in columns (i-1)w_r + 1 to iw_r. Subsequent submatrices H_2H_w_c  are column permutations of H_1.\n\nThe ECC Zoo has an entry for this family.\n\nExample\n\nHere is an example of (3,4)-LDPC code\n\njulia> using QECCore; using Nemo\n\njulia> μ = 3; wc = 3; wr = 4;\n\njulia> c = GallagerLDPC(μ, wc, wr);\n\njulia> H = parity_matrix(c)\n9×12 SparseArrays.SparseMatrixCSC{Bool, Int64} with 36 stored entries:\n 1  1  1  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  1  1  1  1  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  1  1  1\n 1  ⋅  1  ⋅  ⋅  ⋅  1  ⋅  1  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  1  ⋅  ⋅  1  1\n ⋅  1  ⋅  1  1  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅\n ⋅  1  1  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  1  ⋅  1  1  1  ⋅  ⋅  ⋅  ⋅\n 1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  1  1  ⋅\n\njulia> code_n(c), code_k(c)\n(12, 5)\n\njulia> all(sum(Matrix(H), dims=1) .== 3)\ntrue\n\njulia> all(sum(Matrix(H), dims=2) .== 4)\ntrue\n\nFields\n\nblock_rows::Int64: Number of block rows called \"submatrices\" in the Gallager's construction (Gallager, 1962).\ncol_weight::Int64: Column weight\nrow_weight::Int64: Row weight which must be greater column weight.\nseed::Int64: Random seed for reproducible parity check matrix generation (default=42).\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.GeneralizedCirculantBivariateBicycle","page":"API","title":"QECCore.GeneralizedCirculantBivariateBicycle","text":"struct GeneralizedCirculantBivariateBicycle <: AbstractCSSCode\n\nA generalization of the circulant bivariate bicycle code introduced in (Bravyi et al., 2024), extending the original three-term polynomial representation up to ℓ terms (for x-powers) and m terms (for y-powers).\n\nBivariate Bicycle Codes\n\nBivariate bicycle codes are a class of group algebra codes defined for the finite abelian group G = mathbbZellmathbbZ times mathbbZmmathbbZ. The group algebra mathbbF_2G admits an identification with the quotient ring R = mathbbF_2xy(x^ell - 1 y^m - 1), where the standard basis consists of monomials x^iy^j for 0 leq i  ell and 0 leq j  m (Eberhardt and Steffan, 2024). Within this framework, every pair of elements cd in R determines a BB code (C(cd) through the group algebra construction. \n\nCirculant Matrix Representation\n\nBB codes admit a matrix representation via the injective ring homomorphism (Eberhardt and Steffan, 2024):\n\nbeginaligned\nvarphi R = mathbbF_2xy(x^ell - 1 y^m - 1) rightarrow mathbbF_2^ell m times ell m\nendaligned\n\nwhere varphi(x) = S_ell otimes I_m and varphi(y) = I_ell otimes S_m provides matrix representations of the algebraic generators. Through this mapping, any code-defining polynomials cd in R correspond to parity-check matrices A = varphi(c) and B = varphi(d) composed of tensor products of circulant blocks.\n\nThree-term Polynomials\n\nThe original construction in (Bravyi et al., 2024) constrained the polynomials to specific forms:  \n\nbeginaligned\na(x y) = x^a + y^b + y^c quad b(x y) = y^d + x^e + x^f\nendaligned\n\nThus, A and B can be expressed as A = A_1 + A_2 + A_3 and B = B_1 + B_2 + B_3. Consequently, each stabilizer generator has weight at most 6 for any valid three-term polynomials (Postema and Kokkelmans, 2025).  \n\nGeneralized Polynomials\n\nWe extend the original three-term construction of (Bravyi et al., 2024) to arbitrary finite sums of commuting monomials in x and y:\n\nbeginaligned\nA = sum_i in I x^p_i + sum_j in J y^q_j quad B = sum_k in K x^r_k + sum_l in L y^s_l\nendaligned\n\nwhere index sets I J K L are finite and non-empty, with powers bounded by:\n\nbeginaligned\n0 leq p_i r_k leq ell-1 quad 0 leq q_j s_l leq m-1\nendaligned\n\nCommuting Shift Matrices\n\nThe matrices x = S_ell otimes I_m and y = I_ell otimes S_m form a pair of commuting operators, where S_ell and S_m are cyclic shift matrices of sizes ell times ell and m times m respectively, and I_ell, I_m denote identity matrices of corresponding dimensions. Their commutativity xy = yx follows from the mixed-product property of Kronecker products (Wang and Mueller, 2024):\n\nbeginaligned\n(A otimes B)(C otimes D) = (AC) otimes (BD)\nendaligned\n\nwhich yields:\n\nbeginaligned\n(S_ell otimes I_m)(I_ell otimes S_m) = (I_ell otimes S_m)(S_ell otimes I_m) = S_ell otimes S_m\nendaligned\n\nThe set of monomials x^i y^j mid 0 leq i  ell 0 leq j  m forms a basis for the matrix algebra generated by x and y, establishing a bijection between these monomials and the resulting (ell m) times (ell m) matrices. This correspondence allows us to work equivalently with either the polynomial or matrix formulation (Wang and Mueller, 2024).\n\nParity Checks\n\nThe commuting polynomial matrices A = a(x y) and B = b(x y) define the code’s parity checks:\n\nbeginaligned\nH_x = A mid B quad H_z = B^top mid A^top\nendaligned\n\nThe addition and multiplication on binary matrices are performed modulo 2. Both H_x and H_z are (n2)n matrices.\n\nCirculant Bivariate Bicycle Code\n\nThe BB code is represented by matrices A and B, defined as: A = A_1 + A_2 + A_3 and B = B_1 + B_2 + B_3.\n\nnote: Note\nBoth A and B are matrices in which each row and column contains exactly three non-zero entries when using a 3-term polynomial representation (Bravyi et al., 2024).\n\nThe ECC Zoo has an entry for this family.\n\nExample\n\nHere is [[756, 16, ≤ 34]] circulant bivariate bicycle code from Table 1 of (Bravyi et al., 2024) with polynomials A = x^3 + y^10 + y^17 and B = y^5 + x^3 + x^19. \n\njulia> using QuantumClifford; using QuantumClifford.ECC; # hide\n\njulia> l, m = 21, 18;\n\njulia> A = [(:x,3), (:y,10), (:y,17)];\n\njulia> B = [(:y,5), (:x,3), (:x,19)];\n\njulia> c = GeneralizedCirculantBivariateBicycle(l, m, A, B);\n\njulia> code_n(c), code_k(c)\n(756, 16)\n\nGeneralized Circulant Bivariate Bicycle Code\n\nHere is an example of [[128, 14, 12]] generalized circulant bivariate bicycle code that uses 4-term polynomials c = x^2 + y + y^3 + y^4 and d = y^2 + x + x^3 + x^4 with group orders l m = 8 8 from (Eberhardt and Steffan, 2024).\n\njulia> using QuantumClifford; using QuantumClifford.ECC; # hide\n\njulia> l, m = 8, 8;\n\njulia> A = [(:x,2), (:y,1), (:y,3), (:y,4)];\n\njulia> B = [(:y,2), (:x,1), (:x,3), (:x,4)];\n\njulia> c = GeneralizedCirculantBivariateBicycle(l, m, A, B);\n\njulia> code_n(c), code_k(c)\n(128, 14)\n\nHere is [[18, 4, 4]] generalized circulant bivariate bicycle code that uses 3-term polynomials a = 1 + x + y and b = 1 + x^2 + y^2 with group orders l m = 3 3 from Table III of (Wang and Mueller, 2024). \n\nnote: Note\nWe can also employ 3-term polynomials of a different form than those proposed in (Bravyi et al., 2024).\n\njulia> using QuantumClifford; using QuantumClifford.ECC;\n\njulia> l, m = 3, 3;\n\njulia> A = [(:x, 0), (:x, 1), (:y, 1)];\n\njulia> B = [(:y, 0), (:x, 2), (:y, 2)];\n\njulia> c = GeneralizedCirculantBivariateBicycle(l, m, A, B);\n\njulia> code_n(c), code_k(c)\n(18, 4)\n\nnote: Note\nThe Bivariate Bicycle code mathrmQC(AB) is a specific instance of the Lifted Product construction, where the underlying group is the direct product  mathbbZ_ell times mathbbZ_m (with mathbbZ_j denoting the cyclic group of order j).\n\nHere is [[36, 4, 6]] generalized circulant bivariate bicycle code that uses 3-term polynomials a = x + y^2 + y^3 and b = 1 + y + x^2 with group orders l m = 3 6 from Table III of (Wang and Mueller, 2024). \n\njulia> using QuantumClifford; using QuantumClifford.ECC;\n\njulia> import Hecke: group_algebra, GF, abelian_group, gens;\n\njulia> l, m = 3, 6;\n\njulia> GA = group_algebra(GF(2), abelian_group([l, m]));\n\njulia> x, y = gens(GA);\n\njulia> A = x + y^2 + y^3;\n\njulia> B = 1 + y + x^2;\n\njulia> c = two_block_group_algebra_codes(A,B);\n\njulia> code_n(c), code_k(c)\n(36, 4)\n\nFields\n\nl::Int64: Dimension of cyclic shift matrix Sₗ where x = Sₗ ⊗ Iₘ\nm::Int64:  Dimension of cyclic shift matrix Sₘ where y = Iₗ ⊗ Sₘ\nA::Vector{Tuple{Symbol, Int64}}: Terms in matrix A, where each tuple is (:x or :y, power)\nB::Vector{Tuple{Symbol, Int64}}: Terms in matrix B, where each tuple is (:x or :y, power)\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.Golay","page":"API","title":"QECCore.Golay","text":"struct Golay <: AbstractCECC\n\nThe family of classical binary Golay codes were discovered by Edouard Golay in his 1949 paper (Golay, 1949), where he described the binary [23, 12, 7] Golay code.\n\nThere are two binary Golay codes:\n\nBinary [23, 12, 7] Golay code: The perfect code with code length n = 23\n\nand dimension k = 12. By puncturing in any of the coordinates of parity check matrix H = [24, 12, 8], we obtain a [23, 12, 7] Golay code.\n\nExtended Binary [24, 12, 8] Golay code: Obtained by adding a parity check bit\n\nto [23, 12, 7]. The bordered reverse circulant matrix (A) of [24, 12, 8] Golay code is self-dual, i.e., A₂₄ is same as A₂₄'.\n\nThe parity check matrix is defined as follows: H₂₄ = [I₁₂ | A'] where I₁₂ is the 12 × 12 identity matrix and A is a bordered reverse circulant matrix. Puncturing and then extending any column in​ with an overall parity check H₂₃ reconstructs the original parity check matrix H₂₄. Thus, all punctured codes are equivalent.\n\nThe ECC Zoo has an entry for this family.\n\nFields\n\nn::Int64: The number of bits in the code.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.Gottesman","page":"API","title":"QECCore.Gottesman","text":"struct Gottesman <: AbstractQECC\n\nThe family of [[2ʲ, 2ʲ - j - 2, 3]] Gottesman codes, also known as quantum Hamming codes, as described in Gottesman's 1997 PhD thesis and in (Gottesman, 1996).\n\nYou might be interested in consulting (Yu et al., 2013) and (Chao and Reichardt, 2017) as well.\n\nThe ECC Zoo has an entry for this family\n\nFields\n\nj::Int64: The parameter j of the code.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.Hamming","page":"API","title":"QECCore.Hamming","text":"struct Hamming <: AbstractCECC\n\nThe family of [2ʳ - 1, 2ʳ - 1 - r, 3] Hamming binary codes were discovered by Richard W. Hamming in his 1950 paper (Hamming, 1950) as a way of automatically correcting errors introduced by punched card readers. In his original paper, Hamming elaborated his general idea, but specifically focused on the Hamming(7, 4) code which adds three parity bits to four bits of data.\n\nThe Hamming matrix H is an r × (2ʳ - 1) binary matrix, where each column corresponds to the binary representation of the integers from 1 to 2ʳ - 1, with r ≥ 2. This matrix serves as the parity-check matrix for a binary Hamming code with parameters [2ʳ − 1, 2ʳ − 1 − r, 3] The minimum Hamming distance of this code is 3, as detailed in (Huffman and Pless, 2010).\n\nThe ECC Zoo has an entry for this family.\n\nFields\n\nr::Int64\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.Perfect5","page":"API","title":"QECCore.Perfect5","text":"struct Perfect5 <: AbstractQECC\n\nPerfect5 code (Lafiamme et al., 1996) is the smallest qubit stabilizer code to correct a single-qubit error.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.Phaseflip3","page":"API","title":"QECCore.Phaseflip3","text":"struct Phaseflip3 <: AbstractQECC\n\nPhaseflip3 is a three-qubit phase-flip code that corrects single-qubit phase-flip error and does not detect any bit-flip errors.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.QuantumReedMuller","page":"API","title":"QECCore.QuantumReedMuller","text":"struct QuantumReedMuller <: AbstractCSSCode\n\nThe family of [[2ᵐ - 1, 1, 3]] CSS Quantum-Reed-Muller codes, as discovered by Steane in his 1999 paper (Steane, 1999).\n\nQuantum codes are constructed from shortened Reed-Muller codes RM(1, m), by removing the first row and column of the generator matrix Gₘ. Similarly, we can define truncated dual codes RM(m - 2, m) using the generator matrix Hₘ (Anderson et al., 2014). The quantum Reed-Muller codes QRM(m) derived from RM(1, m) are CSS codes. \n\nGiven that the stabilizers of the quantum code are defined through the generator matrix of the classical code, the minimum distance of the quantum code corresponds to the minimum distance of the dual classical code, which is d = 3, thus it can correct any single qubit error. Since one stabilizer from the original and one from the dual code are removed in the truncation process, the code parameters are [[2ᵐ - 1, 1, 3]].\n\nYou might be interested in consulting (Anderson et al., 2014) and (Campbell et al., 2012) as well.\n\nThe ECC Zoo has an entry for this family.\n\nSee also: ReedMuller and RecursiveReedMuller\n\nFields\n\nm::Int64: The log-length of the code.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.QuantumTannerGraphProduct","page":"API","title":"QECCore.QuantumTannerGraphProduct","text":"struct QuantumTannerGraphProduct <: AbstractCSSCode\n\nRepresents the CSS quantum code Q(G₁ × G₂) constructed from two binary codes with parity-check matrices H₁ and H₂, using the hypergraph product formulation introduced by (Tillich and Zémor, 2013).\n\nThis construction corresponds to a specific product of Tanner graphs:\n\nLet G₁ = T(V₁, C₁, E₁) and G₂ = T(V₂, C₂, E₂) be the Tanner graphs of H₁ and H₂.\nThe product graph G₁ × G₂ has vertex set (V₁ × V₂) ∪ (C₁ × C₂) and check set (C₁ × V₂) ∪ (V₁ × C₂).\nThe Tanner subgraphs G₁ ×ₓ G₂ and G₁ ×𝓏 G₂ define classical codes Cₓ and C𝓏 used in the CSS construction.\n\nThe hgp(H₁, H₂) function algebraically realizes this graph-theoretic product using Kronecker operations, yielding the X- and Z-type parity-check matrices:\n\nH_X = [H₁ ⊗ I  |  I ⊗ H₂ᵗ] corresponds to G₁ ×ₓ G₂\nH_Z = [I ⊗ H₂  |  H₁ᵗ ⊗ I] corresponds to G₁ ×𝓏 G₂\n\nThese matrices ensure H_X * H_Zᵗ = 0, satisfying the CSS condition.\n\nSee: (Tillich and Zémor, 2013), Section 4.3 — “The hypergraph connection, product codes”\n\n𝑄(𝐺₁ × 𝐺₂)\n\nThe 𝑄(𝐺₁ × 𝐺₂) quantum LDPC codes represent a broader generalization of quantum expander codes which are derived from the Leverrier-Tillich-Zémor construction (Tillich and Zémor, 2013).\n\njulia> using QuantumClifford; using QuantumClifford.ECC; using QECCore\n\njulia> H1 = [1 0 1 0; 0 1 0 1; 1 1 0 0];\n\njulia> H2 = [1 1 0; 0 1 1];\n\njulia> c = parity_checks(QuantumTannerGraphProduct(H1, H2))\n+ X_____X_____X_____\n+ _X_____X____XX____\n+ __X_____X____X____\n+ ___X_____X____X___\n+ ____X_____X___XX__\n+ _____X_____X___X__\n+ X__X____________X_\n+ _X__X___________XX\n+ __X__X___________X\n+ ZZ__________Z___Z_\n+ _ZZ__________Z___Z\n+ ___ZZ_________Z_Z_\n+ ____ZZ_________Z_Z\n+ ______ZZ____Z_____\n+ _______ZZ____Z____\n+ _________ZZ___Z___\n+ __________ZZ___Z__\n\njulia>  code_n(c), code_k(c)\n(18, 1)\n\nQuantum Expander code\n\nThe 𝑄(𝐺₁ × 𝐺₂) code is more general than the standard quantum expander code (Leverrier et al., 2015) construction. The quantum expander code construction corresponds to the specific case where G = G1 = G2​.\n\njulia> H = parity_matrix(RepCode(3));\n\njulia> c = parity_checks(QuantumTannerGraphProduct(H, H))\n+ X__X_____X_X______\n+ _X__X____XX_______\n+ __X__X____XX______\n+ ___X__X_____X_X___\n+ ____X__X____XX____\n+ _____X__X____XX___\n+ X_____X________X_X\n+ _X_____X_______XX_\n+ __X_____X_______XX\n+ ZZ_______Z_____Z__\n+ _ZZ_______Z_____Z_\n+ Z_Z________Z_____Z\n+ ___ZZ____Z__Z_____\n+ ____ZZ____Z__Z____\n+ ___Z_Z_____Z__Z___\n+ ______ZZ____Z__Z__\n+ _______ZZ____Z__Z_\n+ ______Z_Z_____Z__Z\n\njulia>  code_n(c), code_k(c)\n(18, 2)\n\nFields\n\nH1::AbstractMatrix: The first classical seed code for the the quantum tanner graph code.\nH2::AbstractMatrix: The second classical seed code for the the quantum tanner graph code.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.RecursiveReedMuller","page":"API","title":"QECCore.RecursiveReedMuller","text":"struct RecursiveReedMuller <: AbstractCECC\n\nA construction of the Reed-Muller class of codes using the recursive definition.\n\nThe Plotkin (u, u + v) construction defines a recursive relation between generator matrices of Reed-Muller (RM) codes (Abbe et al., 2020). To derive the generator matrix G(m, r) for RM(r, m), the generator matrices of lower-order codes are utilized:\n\nG(r - 1, m - 1): Generator matrix of RM(r - 1, m - 1)\nG(r, m - 1): Generator matrix of RM(r, m - 1)\n\nThe generator matrix G(m, r) of RM(m, r) is formulated as follows in matrix notation:\n\nG(m r) = eginbmatrix\nG(r m - 1)  G(r m - 1) \n0  G(r - 1 m - 1)\nndbmatrix\n\nHere, the matrix 0 denotes an all-zero matrix with dimensions matching G(r - 1, m - 1). This recursive approach facilitates the construction of higher-order Reed-Muller codes based on the generator matrices of lower-order codes.\n\nIn addition, the dimension of RM(m - r - 1, m) equals the dimension of the dual of RM(r, m). Thus, RM(m - r - 1, m) = RM(r, m)^⊥ shows that the dual code of RM(r, m) is RM(m − r − 1, m), indicating the parity check matrix of RM(r, m) is the generator matrix for RM(m - r - 1, m).\n\nSee also: ReedMuller and QuantumReedMuller\n\nFields\n\nr::Int64: The order of the code.\nm::Int64: The log-length of the code.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.ReedMuller","page":"API","title":"QECCore.ReedMuller","text":"struct ReedMuller <: AbstractCECC\n\nThe family of Reed-Muller codes, as discovered by Muller in his 1954 paper (Muller, 1954) and Reed who proposed the first efficient decoding algorithm (Reed, 1954).\n\nLet m be a positive integer and r a nonnegative integer with r ≤ m. These linear codes, denoted as RM(r, m), have order r (where 0 ≤ r ≤ m) and codeword length n of 2ᵐ.\n\nTwo special cases of generator(RM(r, m)) exist:     1. generator(RM(0, m)): This is the 0ᵗʰ-order RM code, similar to the binary repetition code with length 2ᵐ. It's characterized by a single basis vector containing all ones.     2. generator(RM(m, m)): This is the mᵗʰ-order RM code. It encompasses the entire field F(2ᵐ), representing all possible binary strings of length 2ᵐ.\n\nYou might be interested in consulting (Raaphorst, 2003), (Abbe et al., 2020), and (Djordjevic, 2021) as well.\n\nThe dimension of RM(m - r - 1, m) equals the dimension of the dual of RM(r, m). Thus, RM(m - r - 1, m) = RM(r, m)^⊥ shows that the dual code of RM(r, m) is RM(m − r − 1, m), indicating the parity check matrix of RM(r, m) is the generator matrix for RM(m - r - 1, m).\n\nThe ECC Zoo has an entry for this family.\n\nSee also: RecursiveReedMuller and QuantumReedMuller\n\nFields\n\nr::Int64: The order of the code.\nm::Int64: The log-length of the code.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.RepCode","page":"API","title":"QECCore.RepCode","text":"struct RepCode <: AbstractCECC\n\nRepetition code is a classical error correction code that repeats the same bit n times.\n\nFields\n\nn::Int64: The number of times to repeat the bit.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.Shor9","page":"API","title":"QECCore.Shor9","text":"struct Shor9 <: AbstractCSSCode\n\nShor9 code (Shor, 1995)is a nine-qubit CSS code that is the first quantum error-correcting code.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.Steane7","page":"API","title":"QECCore.Steane7","text":"struct Steane7 <: AbstractCSSCode\n\nSteane code (Steane, 1996).\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.Surface","page":"API","title":"QECCore.Surface","text":"struct Surface <: AbstractCSSCode\n\nThe planar surface code refers to the code (Kitaev, 2003) in a 2D lattice with open boundaries. Illustration of a 3×2 surface code, where qubits are located on the edges:\n\n|---1--(Z)--2---|---3---|\n|  (X)  7       8       o\n|---4---|---5---|---6---|\n|       o       o       o\n|       |       |       |\n\nThe surface code has open boundary conditions, unlike the toric code. To this end, we remove qubits (denoted by \"o\") and parity checks on the right and bottom sides.\n\nFaces like (1,4,7) have X checks, and crosses like (1,2,7) have Z checks. Due to the removal of the bottom and right sides, we have some 3-qubit checks on the boundaries.\n\nThe parity checks of Surface(3,2) are:\n\nX__X__X_\n_X__X_XX\n__X__X_X\nZZ____Z_\n_ZZ____Z\n___ZZ_Z_\n____ZZ_Z\n\nMore information can be seen in (Fowler et al., 2012).\n\nFields\n\ndx::Int64: The number of qubits in the x direction.\ndz::Int64: The number of qubits in the z direction.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.TillichZemor","page":"API","title":"QECCore.TillichZemor","text":"struct TillichZemor{M} <: AbstractCSSCode\n\nThe [[n² + m²,(n - rank([C ∣ M]))² + (m − rank([C ∣ M]ᵀ))², d]] quantum Tillich Zémor code is a novel quantum LDPC code is constructed using the hypergraph product of two classical seed (n, m, r)-Structured LDPC codes.\n\nStructured LDPC\n\nThe classical (n, m, r)-structured LDPC codes were introduced in (Tillich and Zémor, 2006).  The minimum distance of structured binary LDPC codes with parity-check matrices of the form C mid M, where C is circulant and M has fixed column weight r geq 3, is in O(n^fracr-2r-1 + epsilon), improving the previous bound of O(n^fracr-1r(Arnault et al., 2025).\n\nThe classical structured LDPC codes are defined by a specific structure in their parity-check matrix H, which is composed of a circulant matrix C and a binary matrix M. The ensemble of these codes is referred to as (n, m, r)-structured LDPC codes, where n is the block length of the code, m is the number of parity-check equations, r is the weight of the columns in the matrix M.\n\nParity-Check Matrix Structure\n\nThe parity-check matrix H is an m × n binary matrix of the form: C mid M where: C  is an  m times m  circulant matrix. M is an m times (n - m) binary matrix with specific properties.\n\nCirculant Matrix C\n\nThe circulant matrix C is defined as:\n\nbeginaligned\nC = beginpmatrix\n1                          1 \n1  1                         \n   1       ddots            \n           ddots  1         \n                   1       1\nendpmatrix\nendaligned\n\nThis matrix has the property that each row is a cyclic shift of the previous row. The first row contains two consecutive 1s, and the rest of the entries are 0s.\n\nBinary Matrix M\n\nThe matrix M satisfies the following conditions:\n\nNo Zero Rows: Every row of M contains at least one non-zero element.\nColumn Weight: Every column of M has a constant weight r, where r geq 3.\n\nExistence Conditions\n\nThe family of classical (n, m, r)-structured LDPC codes exists if and only if the following conditions are satisfied:\n\nbeginaligned\nm geq r quad textand quad (n - m)r geq m\nendaligned\n\nThese conditions ensure that the matrix M can be constructed with the required properties.\n\nQuantum (n m r)-Structured LDPC codes\n\nWe introduce a novel construction of quantum LDPC codes from classical (n m r)-structured LDPC seed codes, whose parity-check matrices H = C mid M consist of an m times m circulant core C with column weight 2 (enabling linear-time encoding) and an m times (n-m) matrix M with column weight r geq 3 and no zero rows. The resulting quantum Tillich-Zémor code has block length N = n^2 + m^2 and code dimensionK = (n - \\text{rank}([C \\mid M]))^2 + (m - \\text{rank}([C \\mid M]^\\top))^2 This construction inherits the classical seed codes sub-linear distance scaling (d = O(n^{\\frac{r-2}{r-1}+\\epsilon}`) per Theorem1` of (Arnault et al., 2025) while preserving efficient encoding.\n\nExamples\n\njulia> using QuantumClifford; using QuantumClifford.ECC; using QECCore;\n\njulia> n, m, r = 4, 3, 3;\n\njulia> c = parity_checks(TillichZemor(n, m, r))\n+ X_______X___X___XX_______\n+ _X_______X___X___XX______\n+ __X_______X___X_X_X______\n+ ___X_______X___XXXX______\n+ X___X_______X______XX____\n+ _X___X_______X______XX___\n+ __X___X_______X____X_X___\n+ ___X___X_______X___XXX___\n+ ____X___X___X_________XX_\n+ _____X___X___X_________XX\n+ ______X___X___X_______X_X\n+ _______X___X___X______XXX\n+ Z_ZZ____________Z__Z_____\n+ ZZ_Z_____________Z__Z____\n+ _ZZZ______________Z__Z___\n+ ____Z_ZZ___________Z__Z__\n+ ____ZZ_Z____________Z__Z_\n+ _____ZZZ_____________Z__Z\n+ ________Z_ZZ____Z_____Z__\n+ ________ZZ_Z_____Z_____Z_\n+ _________ZZZ______Z_____Z\n+ ____________Z_ZZZ__Z__Z__\n+ ____________ZZ_Z_Z__Z__Z_\n+ _____________ZZZ__Z__Z__Z\n\njulia> code_n(c), code_k(c)\n(25, 1)\n\njulia> n, m, r = 100, 40, 40;\n\njulia> c = TillichZemor(n, m, r);\n\njulia> code_n(c), code_k(c)\n(11600, 3722)\n\nFields\n\nn::Int64: The block length of the classical (n, m, r)-Structured LDPC seed code.\nm::Int64: The number of check nodes (rows in the parity-check matrix H).\nr::Int64: The column weight parameter for matrix M (each column of M must have exactly r ones).\nmatrices::Any: The X-type and Z-type parity check matrices generated via the hypergraph product of the classical parity check matrix H = [C | M]. For randomized constructions via random_TillichZemor_code, these matrices are derived from the hypergraph product of a randomly generated (n, m, r)-Structured LDPC seed code.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.Toric","page":"API","title":"QECCore.Toric","text":"struct Toric <: AbstractCSSCode\n\nThe Toric code (Kitaev, 2003). Illustration of a 2x2 toric code, where qubits are located on the edges:\n\n|--1-(Z)-2--|\n| (X) 5     6\n|--3--|--4--|\n|     7     8\n|     |     |\n\nIt is important to note that the toric code has periodic boundary conditions, which means that the top and bottom sides are essentially glued together, as are the left and right sides.\n\nFaces like (1,3,5,6) have X checks, and crosses like (1,2,5,7) have Z checks.\n\nThe parity checks of Toric(2,2) are:\n\nX_X_XX__\n_X_XXX__\nX_X___XX\nZZ__Z_Z_\nZZ___Z_Z\n__ZZZ_Z_\n\nFields\n\ndx::Int64: The number of qubits in the x direction.\ndz::Int64: The number of qubits in the z direction.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.Triangular488","page":"API","title":"QECCore.Triangular488","text":"struct Triangular488 <: QECCore.TriangularCode\n\nTriangular code following the 4.8.8 tiling. Constructor take a distance d as input.\n\nExample\n\nHere is [[17,1, 5]] color code following the 4.8.8 tiling:\n\njulia> import HiGHS; import JuMP; # hide\n\njulia> using QuantumClifford.ECC: Triangular666, DistanceMIPAlgorithm; # hide\n\njulia> c = Triangular488(5);\n\njulia> code = Stabilizer(c)\n+ XXXX_____________\n+ X_X_XX___________\n+ __XX_XX__XX__XX__\n+ ____XX__XX_______\n+ ______XX__XX_____\n+ _______X___X___XX\n+ ________XX__XX___\n+ __________XX__XX_\n+ ZZZZ_____________\n+ Z_Z_ZZ___________\n+ __ZZ_ZZ__ZZ__ZZ__\n+ ____ZZ__ZZ_______\n+ ______ZZ__ZZ_____\n+ _______Z___Z___ZZ\n+ ________ZZ__ZZ___\n+ __________ZZ__ZZ_\n\njulia> distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n5\n\nMore information can be seen in (Landahl et al., 2011)\n\nFields\n\nd::Int64: The distance of the code.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.Triangular666","page":"API","title":"QECCore.Triangular666","text":"struct Triangular666 <: QECCore.TriangularCode\n\nTriangular code following the 6.6.6 tiling. Constructor take a distance d as input.\n\nExample\n\nHere is [[19,1, 5]] color code following the 6.6.6 tiling:\n\njulia> import HiGHS; import JuMP; # hide\n\njulia> using QuantumClifford.ECC: Triangular666, DistanceMIPAlgorithm; # hide\n\njulia> c = Triangular666(5);\n\njulia> code = Stabilizer(c)\n+ XXXX_______________\n+ _X_X_XX____________\n+ __XXXX_XX__________\n+ ____X__X__XX_______\n+ _________X___X___XX\n+ _____XX_XX__XX_____\n+ _______XX__XX__XX__\n+ __________XX__XX___\n+ ____________XX__XX_\n+ ZZZZ_______________\n+ _Z_Z_ZZ____________\n+ __ZZZZ_ZZ__________\n+ ____Z__Z__ZZ_______\n+ _________Z___Z___ZZ\n+ _____ZZ_ZZ__ZZ_____\n+ _______ZZ__ZZ__ZZ__\n+ __________ZZ__ZZ___\n+ ____________ZZ__ZZ_\n\njulia> distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n5\n\nMore information can be seen in (Landahl et al., 2011)\n\nFields\n\nd::Int64: The distance of the code.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QECCore.GoppaCode-Tuple","page":"API","title":"QECCore.GoppaCode","text":"Goppa codes (Goppa, 1970).\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QECCore.bivariate_bicycle_code_k","page":"API","title":"QECCore.bivariate_bicycle_code_k","text":"Implemented in a package extension with Oscar.\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QECCore.code_k","page":"API","title":"QECCore.code_k","text":"code_k(c::AbstractECC)\n\nThe number of logical qubits in a error correction code.\n\nSee also: code_n and code_s\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QECCore.code_n-Tuple{AbstractQECC}","page":"API","title":"QECCore.code_n","text":"code_n(c::AbstractECC)\n\nThe number of physical qubits in a error correction code.\n\nSee also: code_k and code_s\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QECCore.code_s","page":"API","title":"QECCore.code_s","text":"code_s(c::AbstractECC)\n\nThe number of stabilizers in a error correction code. They might not be all linearly independent, thus code_s >= code_n-code_k. For the number of linearly independent checks you can use LinearAlgebra.rank.\n\nSee also: code_n and code_k\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QECCore.distance","page":"API","title":"QECCore.distance","text":"distance(c::AbstractECC)\n\nThe code distance of a error correction code.\n\nSee also: code_n and code_k\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QECCore.generator_polynomial","page":"API","title":"QECCore.generator_polynomial","text":"generator_polynomial(c::AbstractCECC)\n\nThe generator polynomial g(x) of a cyclic code which generates the ideal corresponding to the code in the quotient ring mathbbF_qx(x^n - 1).\n\nThe generator polynomial is the unique monic polynomial of minimal degree in the polynomial code. For a cyclic  code C of length n over mathbbF_q, g(x) satisfies:\n\ng(x) divides x^n - 1 in mathbbF_qx.\nThe degree of g(x) is n - k, where k is the code dimension for the non-degenerate case.\nEvery codeword polynomial c(x) in C can be expressed as c(x) = m(x)g(x) mod (x^n - 1).\n\nThe input is a classical polynomial error-correcting code defined over a finite field.\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QECCore.metacheck_matrix","page":"API","title":"QECCore.metacheck_matrix","text":"metacheck_matrix(c::AbstractCSSCode)\n\nReturn the X- and Z-metacheck matrices for CSS codes enabling single-shot quantum error correction — a fault-tolerant scheme that corrects both data and measurement errors using one round of syndrome measurements ((Higgott and Breuckmann, 2023), (Quintavalle et al., 2021)).\n\nSingle-Shot QEC\n\nSingle-shot QEC enables both physical errors on qubits and errors in syndrome measurements to be detected and corrected using only a single round of noisy measurements, without requiring repeated measurement rounds. A layer of redundancy is added to the measurement process itself. This redundancy is captured by metasyndromes: linear constraints that the noisy syndrome outcomes must satisfy if no measurement error has occurred. When violated, they indicate faults in the syndrome extraction layer itself.\n\nTraditional QEC combats measurement faults by repeating stabilizer measurements. In contrast, single-shot QEC uses spatial redundancy via metachecks — extra linear constraints on syndrome outcomes (\"checks of checks\") to detect and correct measurement errors immediately.\n\nAs noted in (Higgott and Breuckmann, 2023): \"Some single-shot codes have linear dependencies amongst the check operators, leading to syndromes becoming code words of a classical linear code (called a metacode) that can be used for syndrome repair. These linear dependencies are not a requirement for a code to be single-shot (indeed, quantum expander codes are single shot and confined but can have full-rank check matrices); however, a metacode can nevertheless be useful when decoding. We can construct a code that has syndromes encoded in a metacode using a chain complex with length at least 3 (to obtain a metacode for either X or Z syndromes), or length 4 if we would like a metacode for both X and Z syndromes.\"\n\nConfinement and Single-Shot Decoding\n\nMetachecks enable single-shot decoding by providing a metacode for syndrome repair, but their role is best understood through the broader property of confinement (Higgott and Breuckmann, 2023):\n\nA code has *(tf)*-confinement if for all errors *E* with|E|_{\\text{red}} leq t,\n\nthe syndrome weight satisfies f(sigma(E)) geq E_textred, where f mathbbZ to mathbbR is an increasing function. This bounds the physical error weight by a function of the syndrome weight.\n\nCodes with metachecks (e.g., D-dimensional surface and toric codes) exhibit confinement because M_XM_Z constrain syndromes to a metacode, but confinement can exist without metachecks (e.g., quantum expander codes). Thus, while metachecks are sufficient for single-shot QEC (via syndrome repair), they are not strictly necessary.\n\nRepair-Syndrome Decoding\n\nTo correct errors in CSS codes, a two-stage decoder can be employed when given a noisy syndrome measurement z′. This method separately addresses data qubit errors (e.g., Z-errors) and syndrome measurement errors (e.g., faulty X-stabilizer measurements). The same approach applies symmetrically for X-errors and Z-stabilizer measurements.\n\nStage I: Syndrome Repair via Metachecks\n\nThe metacheck matrix M_X computes the metasyndrome s = M_Xz, identifying inconsistencies caused by measurement errors.\nA classical decoder f^1_d  mathbbF^n_i-2_2 rightarrow mathbbF^n_i-1_2 estimates the noiseless syndrome z from s, effectively \"repairing\" the syndrome.\n\nStage II: Data Qubit Correction\n\nA second decoder f^2_d  mathbbF^n_i-1_2 rightarrow mathbbF^n_2​ uses the corrected syndrome z to compute a noise vector n such that H_Xn = z, determining the most likely data qubit errors.\n\nThe correction can fail in two ways:\n\nInvalid Syndrome: The repaired z lies outside the valid syndrome space im(H_X).\nLogical Error: The correction n corresponds to a nontrivial logical operator (i.e., n in ker(H_X)).\n\nTo mitigate the first failure (i.e. invalid syndrome), we can modify the metacheck matrix to\n\nbeginaligned\nM = beginpmatrix\nM_X \nL_M\nendpmatrix\nendaligned\n\nwhere L_M spans the cohomology group H^i-1. However, if L_M is non-sparse (common in topological codes), decoding efficiency may suffer.\n\nnote: Note\nThe modified metacheck matrix M is only employed when the initial decoding attempt yields an invalid syndrome (z notin textim(H_X)). This approach helps maintain decoder efficiency, particularly for topological codes where L_M is typically non-sparse (Higgott and Breuckmann, 2023). However, the overall performance of two-stage decoders remains fundamentally constrained by the metacode's threshold, often resulting in suboptimal error correction capability.\n\nSingle-Stage Decoding\n\nSingle-stage decoding provides a unified framework for correcting both data qubit errors (e) and syndrome measurement errors (s_e) simultaneously (Higgott and Breuckmann, 2023). Given an observed syndrome s = H_X e + s_e, where H_X is the X-stabilizer matrix, the decoder seeks the most probable error configuration e = beginpmatrixe  s_eendpmatrix that satisfies the extended parity-check equation:\n\nbeginaligned\nH e = s quad textwhere quad H = beginpmatrixH_X  I_rendpmatrix\nendaligned\n\nThe Tanner graph T(H) for this system is constructed by augmenting the original Tanner graph T(H_X) with additional variable nodes v_i^m_i=1^r representing potential measurement errors. Each check node f_i gains a corresponding edge (v_i^m f_i), creating a structure where measurement errors appear explicitly in the decoding graph.\n\nThe decoding framework can be further enhanced by explicitly incorporating metachecks through the extended matrix:\n\nbeginaligned\nbeginequation\nH_M = eginpmatrix\nH_X  I_r \n0  M\nendpmatrix\nendequation\nendaligned\n\nwhere M is the metacheck matrix. Though these metachecks are implicitly present as linear combinations in T(H), their explicit inclusion significantly improves decoder performance.\n\nThe single-stage decoding approach offers several key advantages over two-stage methods, including the elimination of metacode failures—since the combined error syndrome s + s_e is within the image of H_X by construction—along with the avoidance of non-sparse L_M matrices that can degrade decoder performance, and ultimately yielding improved thresholds for topological codes (Higgott and Breuckmann, 2023).\n\nChain Complexes and mathbbF_2 Homology\n\nA chain complex of length l is a sequence of vector spaces connected by boundary maps:\n\nbeginaligned\n0 xrightarrowpartial_l+1 C_l xrightarrowpartial_l C_l-1 xrightarrowpartial_l-1 cdots xrightarrowpartial_1 C_0 xrightarrowpartial_0 0\nendaligned\n\nwhere\n\nEach C_i is called an i-cell.\nThe image of partial_i+1, denoted mathrmimpartial_i+1, consists of i-boundaries.\nThe kernel of partial_i, denoted kerpartial_i, consists of i-cycles.\n\nThe boundary maps satisfy the constraint:\n\nbeginaligned\npartial_i circ partial_i+1 = 0 quad textfor all  i in 0 dots l\nendaligned\n\nBecause partial_i circ partial_i+1 = 0, every boundary is a cycle:\n\nbeginaligned\nmathrmimpartial_i+1 subseteq kerpartial_i\nendaligned\n\nThe i-th homology group measures the difference between cycles and boundaries:\n\nbeginaligned\nH_i = frackerpartial_imathrmimpartial_i+1\nendaligned\n\nAssociated with a chain complex is a cochain complex with coboundary operators delta^i C^i to C^i+1, typically defined as the transpose (or dual) of the boundary maps:\n\nbeginaligned\n0 xrightarrowdelta^-1 C^0 xrightarrowdelta^0 C^1 xrightarrowdelta^1 cdots xrightarrowdelta^l-1 C^l xrightarrowdelta^l 0\nendaligned\n\nwhere\n\nkerdelta^i consists of i-cocycles.\nmathrmimdelta^i-1 consists of i-coboundaries.\n\nThe i-th cohomology group is:\n\nbeginaligned\nH^i = frackerdelta^imathrmimdelta^i-1\nendaligned\n\nCSS codes using Homological Algebra\n\nQuantum CSS codes can be described using the framework of chain complexes.\n\nFor a chain complex of length l ≥ 4 , where qubits are placed on i-cells (C_i) with (1 < i < l−1):\n\nbeginaligned\nC_l-1 xrightarrowpartial_l-1 cdots xrightarrowpartial_i+2 C_i+1 xrightarrowpartial_i+1 C_i xrightarrowpartial_i C_i-1 xrightarrowpartial_i-1 cdots xrightarrowpartial_1 C_0\nendaligned\n\nwhere\n\nparity_checks_x(c): X-stabilizers are given by the boundary map H_X = partial_i C_i  C_i-1.\nparity_checks_z(c): Z-stabilizers are given by the coboundary map H_Z = partial_i+1^T C_i  C_i+1.\nmetacheck_matrix_x(c): X-metachecks are defined as M_X = partial_i-1 C_i-1  C_i-2.\nmetacheck_matrix_z(c): Z-metachecks are defined as M_Z = partial_i+2^T C_i+2  C_i+1.\n\nThe boundary conditions partial_i-1 partial_i = 0 (i.e., M_X H_X = 0) guarantee that valid syndromes (im H_X) lie in ker M_X.\n\nInvalid syndromes in ker M_X \\setminus im H_X belong to the (i−1)-th homology group H_i-1 = ker partial_i-1  mathrmim partial_i, while invalid Z-syndromes in ker M_Z \\setminus im H_Z belong to the (i+1)-th cohomology group.\n\nnote: Note\nA code can be designed to incorporate syndromes within a metacode by employing a chain complex of minimum length three—sufficient for encoding either X or Z syndromes. If the goal is to include both X and Z syndromes in the metacode, the chain complex must extend to at least length four (Higgott and Breuckmann, 2023).\n\nMetachecks in Higher-Dimensional Complexes\n\nIn D-dimensional codes, such as the 4D surface code, we consider a 5-term chain complex:\n\nbeginaligned\nC_4 xrightarrowpartial_4 C_3 xrightarrowpartial_3 C_2 xrightarrowpartial_2 C_1 xrightarrowpartial_1 C_0\nendaligned\n\nIn this chain complex framework:\n\nStandard parity checks are: partial_3 = H_Z^top, and partial_2 = H_X\nMetachecks correspond to: partial_4 = M_Z^top, and partial_1 = M_X\n\nSyndrome Validation\n\nThe matrices M_X and M_Z enforce syndrome validity via boundary conditions from the chain complex:\n\nbeginaligned\nM_Xs_X = 0 quad textfor X-syndromes  (s_X in C_1) \nM_Zs_Z = 0 quad textfor Z-syndromes  (s_Z in C_3)\nendaligned\n\nSee also: metacheck_matrix_x, metacheck_matrix_z\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QECCore.metacheck_matrix_x","page":"API","title":"QECCore.metacheck_matrix_x","text":"metacheck_matrix_x(c::AbstractCSSCode)\n\nReturns the X-metacheck matrix (M_X = partial_i-1) for a CSS code defined by a chain complex of length l ≥ 4, where qubits are placed on i-cells with 1  i  l1.\n\nThis matrix acts on X-syndromes (measurement outcomes from X-type stabilizers that detect Z-errors, obtained via parity_matrix_x and enforces the constraint M_X s_X = 0, ensuring syndromes s_X are valid codewords of a classical metacode.\n\nnote: Note\nFor an introduction to chain complexes in quantum error correction and the role of metachecks in single-shot QEC, see the documentation for metacheck_matrix.\n\nExample: 4D surface code\n\nIn the 5-term chain complex used for the 4D surface code:\n\nbeginaligned\nC_4 xrightarrowpartial_4 C_3 xrightarrowpartial_3 C_2 xrightarrowpartial_2 C_1 xrightarrowpartial_1 C_0\nendaligned\n\nthe metacheck matrix M_X = partial_1 obtained via metacheck_matrix_x satisfies the following:\n\nActs on X-syndromes: s_X in C_1.\nIt enforces M_Xs_X = 0, i.e. only valid syndromes lie in ker M_X.\nIt satisfies the boundary condition M_XH_X = 0 (i.e., partial_1 partial_2 = 0)  where H_Z and M_Z are obtained via parity_matrix_x and metacheck_matrix_x respectively.\n\nSee also: metacheck_matrix_z, metacheck_matrix, parity_matrix_x\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QECCore.metacheck_matrix_z","page":"API","title":"QECCore.metacheck_matrix_z","text":"metacheck_matrix_z(c::AbstractCSSCode)\n\nReturns the Z-metacheck matrix (M_Z = partial_i+2^top) for a CSS code defined by a chain complex of length l ≥ 4, where qubits are placed on i-cells (1 < i < l−1).\n\nThis matrix acts on Z-syndromes (measurement outcomes from Z-type stabilizers that detect X-errors, obtained via parity_matrix_z and enforces the constraint M_Z s_Z = 0, ensuring syndromes s_Z are valid codewords of a classical metacode.\n\nnote: Note\nFor an introduction to chain complexes in quantum error correction and the role of metachecks in single-shot QEC, see the documentation for metacheck_matrix.\n\nExample: 4D Surface Code\n\nIn the 5-term chain complex used for the 4D surface code:\n\nbeginaligned\nC_4 xrightarrowpartial_4 C_3 xrightarrowpartial_3 C_2 xrightarrowpartial_2 C_1 xrightarrowpartial_1 C_0\nendaligned\n\nthe metacheck matrix M_Z = partial_4 obtained via metacheck_matrix_z satisfies the following:\n\nActs on Z-syndromes: s_Z in C_3,\nIt enforces M_Zcdot_Z = 0, i.e. only valid syndromes lie in ker M_Z.\nIt satisfies the boundary condition H_Z^top cdot M_Z^top = 0 (i.e., \\partial3 \\partial4 = 0) whereHZandMZ`are obtained via [paritymatrixz](@ref) and [metacheckmatrixz`](@ref) respectively.\n\nSee also: metacheck_matrix_x, metacheck_matrix, parity_matrix_z\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QECCore.parity_matrix","page":"API","title":"QECCore.parity_matrix","text":"parity_matrix(c::AbstractECC)\n\nThe parity check matrix of a error correction code in the form of (X|Z). The size of the matrix is (code_s, 2*code_n). code_s is the number of stabilizers, and code_n is the number of physical qubits. Each row of the matrix is a stabilizer. The first code_n columns represent whether this stabilizer contains a X operator on the physical qubit, and the last code_n columns represent whether this stabilizer contains a Z operator on the physical qubit.\n\nSee also: parity_matrix_x and parity_matrix_z\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QECCore.parity_matrix_x","page":"API","title":"QECCore.parity_matrix_x","text":"parity_matrix_x(c::AbstractCSSCode)\n\nParity check boolean matrix of a code (only the X entries in the tableau, i.e. the checks for Z errors). Only CSS codes have this method.\n\nSee also: parity_matrix and parity_matrix_z\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QECCore.parity_matrix_z","page":"API","title":"QECCore.parity_matrix_z","text":"parity_matrix_z(c::AbstractCSSCode)\n\nParity check boolean matrix of a code (only the Z entries in the tableau, i.e. the checks for X errors). Only CSS codes have this method.\n\nSee also: parity_matrix and parity_matrix_x\n\n\n\n\n\n","category":"function"},{"location":"ECC_API/#QECCore.random_TillichZemor_code-Tuple{Random.AbstractRNG, Int64, Int64, Int64}","page":"API","title":"QECCore.random_TillichZemor_code","text":"The random Tillich Zémor code is a quantum LDPC code constructed using the hypergraph product of two randomized classical (n, m, r)-Structured LDPC seed codes.\n\nThe parity-check matrix H = C mid M is generated by combining a deterministic circulant core C of size m times m with column weight 2 and a randomized matrix M of size m times (n-m). Each column of M contains exactly r geq 3 nonzero entries, which are placed uniformly at random while ensuring that no row of M is entirely zero. This construction ensures a structured yet partially randomized design for the seed parity-check matrix H = C mid M.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QECCore.rate-Tuple{Any}","page":"API","title":"QECCore.rate","text":"rate(c::AbstractECC)\n\nThe rate of a error correction code.\n\nSee also: code_n and code_k\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QECCore.search_self_orthogonal_rm_codes-Tuple{Int64}","page":"API","title":"QECCore.search_self_orthogonal_rm_codes","text":"Search for parameters (r,m) of self-orthogonal Reed-Muller codes where the code RM(r,m) satisfies H times H^top equiv 0 pmod2. Skips the trivial case RM(0,1) which produces a code with k=0 logical qubits.\n\njulia> using QuantumClifford; using QuantumClifford.ECC; using QECCore: search_self_orthogonal_rm_codes; # hide\n\njulia> search_self_orthogonal_rm_codes(6)\n12-element Vector{Tuple{Int64, Int64}}:\n (1, 2)\n (1, 3)\n (2, 3)\n (2, 4)\n (3, 4)\n (2, 5)\n (3, 5)\n (4, 5)\n (3, 6)\n (4, 6)\n (5, 6)\n\nHere is an example using a self-orthogonal classical RM(3,5) seed code to demonstrate the generalization of the Delfosse-Reichardt construction.\n\njulia> using QuantumClifford; using QuantumClifford.ECC; # hide\n\njulia> p = 2; r = 3; m = 5;\n\njulia> c = parity_checks(DelfosseReichardt(p, r, m))\n+ XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX________________________________\n+ ________________________________XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n+ XXXXXXXXXXXXXXXX________________XXXXXXXXXXXXXXXX________________\n+ XXXXXXXX________XXXXXXXX________XXXXXXXX________XXXXXXXX________\n+ XXXX____XXXX____XXXX____XXXX____XXXX____XXXX____XXXX____XXXX____\n+ XX__XX__XX__XX__XX__XX__XX__XX__XX__XX__XX__XX__XX__XX__XX__XX__\n+ X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_X_\n+ ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ________________________________\n+ ________________________________ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\n+ ZZZZZZZZZZZZZZZZ________________ZZZZZZZZZZZZZZZZ________________\n+ ZZZZZZZZ________ZZZZZZZZ________ZZZZZZZZ________ZZZZZZZZ________\n+ ZZZZ____ZZZZ____ZZZZ____ZZZZ____ZZZZ____ZZZZ____ZZZZ____ZZZZ____\n+ ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__ZZ__\n+ Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_\n\njulia> code_n(c), code_k(c)\n(64, 50)\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#Implemented-in-an-extension-requiring-Hecke.jl","page":"API","title":"Implemented in an extension requiring Hecke.jl","text":"","category":"section"},{"location":"ECC_API/#QuantumCliffordHeckeExt.ExtendedGeneralizedBicycleCode","page":"API","title":"QuantumCliffordHeckeExt.ExtendedGeneralizedBicycleCode","text":"struct ExtendedGeneralizedBicycleCode <: AbstractCSSCode\n\nThe extended generalized bicycle code is a family of quantum LDPC codes generated through algebraic extension of a base GeneralizedBicycleCode. Starting with initial generating polynomials a(x) b(x) in mathbbF_2^langleellrangle, the extended GB codes are constructed by polynomial multiplication, where for each extension step m, an extension polynomial \n\nbeginaligned\np^(m)(x) in mathbbF_2^langlekappa_mellrangle\nendaligned\n\nis selected to produce extended polynomials:\n\nbeginaligned\na^(m)(x) = p^(m)(x)a(x) \nb^(m)(x) = p^(m)(x)b(x)\nendaligned\n\nThese extended polynomials are then used to form kappa_mell times kappa_mell circulant matrices A_m and B_m, which are combined into a parity-check matrix H_m with block structure:\n\nbeginaligned\nH_m = beginpmatrix \nA_m mid B_m  0 \n0  B_m^top mid A_m^top \nendpmatrix \nendaligned\n\nwhile maintaining logical dimension:\n\nbeginaligned\nk_m = 2degleft(gcdleft(a^(m) b^(m) x^kappa_mell-1right)right)\nendaligned\n\nthat are always bounded below by the base code dimension k.\n\nExample\n\njulia> import Hecke: polynomial_ring, GF, one, gen; using QuantumClifford.ECC;\n\njulia> R, x = polynomial_ring(GF(2), \"x\");\n\njulia> l = 5;\n\njulia> a = 1 + x^4;\n\njulia> b = 1 + x + x^2 + x^4;\n\njulia> c = GeneralizedBicycleCode(a, b, l);\n\njulia> import HiGHS;\n\njulia> code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n(10, 2, 3)\n\njulia> m, p = 4, one(R);\n\njulia> new_code = ExtendedGeneralizedBicycleCode(c, m, p);\n\njulia> code_n(new_code), code_k(new_code), distance(new_code, DistanceMIPAlgorithm(solver=HiGHS))\n(40, 2, 5)\n\njulia> m, p = 4, 1 + x;\n\njulia> new_code = ExtendedGeneralizedBicycleCode(c, m, p);\n\njulia> code_n(new_code), code_k(new_code), distance(new_code, DistanceMIPAlgorithm(solver=HiGHS))\n(40, 4, 5)\n\nnote: Note\n(Koukoulekidis et al., 2024) establishes that ℓ = 5 is the minimal lift size required to achieve quantum error-correcting codes with a minimum distance of d ≥ 3.\n\nFields\n\nbase_code::AbstractCSSCode: The base generalized bicycle code to extend.\nm::Int64: The extension index (m ≥ 1)\np::Nemo.FqPolyRingElem: The extension polynomial ∈ 𝔽₂[((m-1)ℓ +1)].\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QuantumCliffordHeckeExt.GeneralizedBicycleCode","page":"API","title":"QuantumCliffordHeckeExt.GeneralizedBicycleCode","text":"struct GeneralizedBicycleCode <: AbstractCSSCode\n\nGeneralized bicycle codes ((Koukoulekidis et al., 2024))\n\nA generalized bicycle quantum LDPC code constructed from two polynomials in mathbbF_2x(x^l - 1).\n\nHere is an example of a [[10, 2, 3]] GB code from the Appendix B of (Koukoulekidis et al., 2024) with lift size of 5 build out of two polymonials in mathbbF_2x(x^l - 1).\n\njulia> import Hecke: polynomial_ring, GF; using QuantumClifford.ECC;\n\njulia> R, x = polynomial_ring(GF(2), \"x\");\n\njulia> l = 5;\n\njulia> a = 1 + x^4;\n\njulia> b = 1 + x + x^2 + x^4;\n\njulia> c = GeneralizedBicycleCode(a, b, l);\n\njulia> import HiGHS;\n\njulia> code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n(10, 2, 3)\n\nHere is an example of a [[12, 2, 3]] GB code from the Appendix B of (Koukoulekidis et al., 2024) with lift size of 6 build out of two polymonials in mathbbF_2x(x^l - 1).\n\njulia> import Hecke: polynomial_ring, GF; using QuantumClifford.ECC;\n\njulia> R, x = polynomial_ring(GF(2), \"x\");\n\njulia> l = 6;\n\njulia> a = 1 + x + x^2 + x^5;\n\njulia> b = 1 + x + x^3 + x^5;\n\njulia> c = GeneralizedBicycleCode(a, b, l);\n\njulia> import HiGHS;\n\njulia> code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n(12, 2, 3)\n\nSee also: generalized_bicycle_codes\n\nFields\n\na::Nemo.FqPolyRingElem: First generator polynomial in 𝔽₂[x]/(xˡ - 1).\nb::Nemo.FqPolyRingElem: Second generator polynomial in 𝔽₂[x]/(xˡ - 1).\nl::Int64: The lift size which corresponds to dimension of circulant matrices.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QuantumCliffordHeckeExt.GeneralizedHyperGraphProductCode","page":"API","title":"QuantumCliffordHeckeExt.GeneralizedHyperGraphProductCode","text":"struct GeneralizedHyperGraphProductCode <: AbstractCSSCode\n\nA Generalized Hypergraph Product (GHP) CSS code introduced in (Panteleev and Kalachev, 2021).\n\nThe GHP code is constructed from a matrix A in M_m times n(R), where R subseteq M_ell(mathbbF_2) is a ring of binary circulant matrices, and a binary matrix b in M_ell(mathbbF_2) such that every element of R commutes with b. The code is defined by the block parity-check matrices:\n\nbeginaligned\n    H_X = beginbmatrix A  b cdot I_m endbmatrix quad\n    H_Z = beginbmatrix b^T cdot I_n  A^* endbmatrix\nendaligned\n\nwhere A^* is the transpose of A with each entry polynomial-reversed modulo x^ell - 1, and I_m I_n are identity matrices over R.\n\nHere is an example of [[882, 24, 18 ≤ d ≤ 24]] code from Appendix B of (Panteleev and Kalachev, 2021).\n\njulia> import Hecke: polynomial_ring, GF, quo, matrix; using QuantumClifford.ECC;\n\njulia> R, x = polynomial_ring(GF(2), :x);\n\njulia> l = 63; n = 7;\n\njulia> S, _ =  quo(R, x^l - 1);\n\njulia> A = matrix(S, n, n,\n           [x^27  0     0     0     0     1     x^54\n            x^54  x^27  0     0     0     0     1\n            1     x^54  x^27  0     0     0     0\n            0     1     x^54  x^27  0     0     0\n            0     0     1     x^54  x^27  0     0\n            0     0     0     1     x^54  x^27  0\n            0     0     0     0     1     x^54  x^27]);\n\njulia> b = S(1 + x + x^6);\n\njulia> c = GeneralizedHyperGraphProductCode(A, b, l);\n\njulia> code_n(c), code_k(c)\n(882, 24)\n\nHere is an example of [[1270, 28, 16 ≤ d ≤ 46]] code from Appendix B of (Panteleev and Kalachev, 2021).\n\njulia> import Hecke: polynomial_ring, GF, quo, matrix; using QuantumClifford.ECC;\n\njulia> R, x = polynomial_ring(GF(2), :x);\n\njulia> l = 127; n = 5;\n\njulia> S, _ =  quo(R, x^l - 1);\n\njulia> A = matrix(S, n, n,\n           [1     0     x^51  x^52  0\n            0     1     0     x^111 x^20\n            1     0     x^98  0     x^122\n            1     x^80  0     x^119 0 \n            0     1     x^5   0     x^106]);\n\njulia> b = S(1 + x + x^7);\n\njulia> c = GeneralizedHyperGraphProductCode(A, b, l);\n\njulia> code_n(c), code_k(c)\n(1270, 28)\n\nFields\n\nA::AbstractAlgebra.Generic.MatSpaceElem{AbstractAlgebra.Generic.EuclideanRingResidueRingElem{Nemo.FqPolyRingElem}}: The matrix A in M_n times n(R), where R = mathbbF_2x(x^ell - 1). Each entry in A represents a polynomial modulo x^ell - 1, defining a circulant block.\nb::AbstractAlgebra.Generic.EuclideanRingResidueRingElem{Nemo.FqPolyRingElem}: The polynomial b(x) in R, generating a binary circulant matrix that commutes with all elements of R.\nl::Int64: The number of rows and columns in each binary circulant block.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QuantumCliffordHeckeExt.LPCode","page":"API","title":"QuantumCliffordHeckeExt.LPCode","text":"struct LPCode <: AbstractCSSCode\n\nLifted product codes ((Panteleev and Kalachev, 2021), (Panteleev and Kalachev, Jun 2022))\n\nA lifted product code is defined by the hypergraph product of a base matrices A and the conjugate of another base matrix B'. Here, the hypergraph product is taken over a group algebra, of which the base matrices are consisting.\n\nThe binary parity check matrices are obtained by applying A_repr and B_repr representation maps to each element of the base matrices. These linear transformations convert group algebra elements to their matrix representations while preserving the CSS orthogonality condition.\n\nMathematical Framework\n\nGiven classical parity-check matrices:\n\nA in mathbbF_q^m_a times n_a\nB in mathbbF_q^m_b times n_b\n\nThe lifted product construction produces quantum CSS codes with parity-check matrices:\n\nbeginaligned\n    H_X = A otimes I_m_b -I_m_a otimes B \n    H_Z = I_n_a otimes B^* A^* otimes I_n_b\nendaligned\n\nCommutative Group Algebra\n\nWhen R is commutative, a single representation suffices since all elements naturally commute. Here rho(a) = lambda(a) for all a in R.\n\nNon-Commutative Group Algebra\n\nWhen R is non-commutative, distinct representations are essential:\n\nA_repr implements the right regular representation: rho(a)x = xa\nB_repr implements the left regular representation: lambda(b)x = bx\n\nThese ensure the critical commutation relation:\n\nbeginaligned\n    rho(a)lambda(b) = lambda(b)rho(a)\nendaligned\n\nwhich follows from the associative property:\n\nbeginaligned\n    rho(a)lambda(b)(x) = b(xa) = (bx)a = lambda(b)rho(a)(x)\nendaligned\n\nConstructors\n\nMultiple constructors are available:\n\nTwo base matrices of group algebra elements.\nTwo lifted codes, whose base matrices are for quantum code construction.\nTwo base matrices of group elements, where each group element will be considered as a group algebra element by assigning a unit coefficient.\nTwo base matrices of integers, where each integer represent the shift of a cyclic permutation. The order of the cyclic permutation should be specified.\n\nBelow is a list of all constructors:\n\nLPCode(A, B; GA, A_repr, B_repr, repr)\n\ndefined at /home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted_product.jl:158.\n\nLPCode(c₁, c₂; GA, A_repr, B_repr, repr)\n\ndefined at /home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted_product.jl:175.\n\nLPCode(A, B; GA)\n\ndefined at /home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted_product.jl:195.\n\nLPCode(group_elem_array1, group_elem_array2; GA)\n\ndefined at /home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted_product.jl:203.\n\nLPCode(shift_array1, shift_array2, l; GA)\n\ndefined at /home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted_product.jl:211.\n\nExamples\n\nA [[882, 24, d ≤ 24]] code from Appendix B of (Roffe et al., 2023). We use the 1st constructor to generate the code and check its length and dimension. During the construction, we do arithmetic operations to get the group algebra elements in base matrices A and B. Here x is the generator of the group algebra, i.e., offset-1 cyclic permutation, and GA(1) is the unit element.\n\njulia> import Hecke: group_algebra, GF, abelian_group, gens; import LinearAlgebra: diagind; using QuantumClifford.ECC;\n\njulia> l = 63; GA = group_algebra(GF(2), abelian_group(l)); x = gens(GA)[];\n\njulia> A = zeros(GA, 7, 7);\n\njulia> A[diagind(A)] .= x^27;\n\njulia> A[diagind(A, -1)] .= x^54;\n\njulia> A[diagind(A, 6)] .= x^54;\n\njulia> A[diagind(A, -2)] .= GA(1);\n\njulia> A[diagind(A, 5)] .= GA(1);\n\njulia> B = reshape([1 + x + x^6], (1, 1));\n\njulia> c1 = LPCode(A, B);\n\njulia> code_n(c1), code_k(c1)\n(882, 24)\n\nA [[175, 19, d ≤ 10]] code from Eq. (18) in Appendix A of (Raveendran et al., 2022), following the 4th constructor.\n\njulia> import Hecke; using QuantumClifford.ECC;\n\njulia> base_matrix = [0 0 0 0; 0 1 2 5; 0 6 3 1]; l = 7;\n\njulia> c2 = LPCode(base_matrix, l .- base_matrix', l);\n\njulia> code_n(c2), code_k(c2)\n(175, 19)\n\nCode subfamilies and convenience constructors for them\n\nWhen the base matrices of the LPCode are 1×1, the code is called a two-block group-algebra code two_block_group_algebra_codes.\nWhen the base matrices of the LPCode are 1×1 and their elements are sums of cyclic permutations, the code is called a generalized bicycle code generalized_bicycle_codes.\nWhen the two matrices are adjoint to each other, the code is called a bicycle code bicycle_codes.\n\nThe representation function\n\nWe use the default representation function Hecke.representation_matrix to convert a GF(2)-group algebra element to a binary matrix. The default representation, provided by Hecke, is the permutation representation.\n\nWe also accept a custom representation function as detailed in LiftedCode.\n\nSee also: LiftedCode, two_block_group_algebra_codes, generalized_bicycle_codes, bicycle_codes, haah_cubic_codes.\n\nAll fields:\n\nA::Union{LinearAlgebra.Adjoint{<:Hecke.GroupAlgebraElem, <:Matrix{<:Hecke.GroupAlgebraElem}}, Matrix{<:Hecke.GroupAlgebraElem}}: the first base matrix of the code, whose elements are in a group algebra.\nB::Union{LinearAlgebra.Adjoint{<:Hecke.GroupAlgebraElem, <:Matrix{<:Hecke.GroupAlgebraElem}}, Matrix{<:Hecke.GroupAlgebraElem}}: the second base matrix of the code, whose elements are in the same group algebra as A.\nGA::Hecke.GroupAlgebra: the group algebra for which elements in A and B are from.\nA_repr::Function: a function that converts a group algebra element to a binary matrix for A; default to be the right regular representation for GF(2)-algebra.\nB_repr::Function: a function that converts a group algebra element to a binary matrix for B; default to be the left regular representation for GF(2)-algebra.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QuantumCliffordHeckeExt.LaCross","page":"API","title":"QuantumCliffordHeckeExt.LaCross","text":"struct LaCross <: AbstractCSSCode\n\nThe La-cross code is a quantum LDPC code constructed using the hypergraph product of two classical seed LDPC codes. It is characterized by its parity check matrix H, which is derived from circulant matrices with specific properties. These codes were introduced in (Pecorari et al., 2025).\n\nThe La-cross code has two families, distinguished by their boundary conditions:\n\nPeriodic boundary (full_rank = false):\n\nbeginaligned\nleftleft2n^2 2k^2 d rightright\nendaligned\n\nOpen boundary (full_rank = true): \n\nbeginaligned\nleftleft(n - k)^2 + n^2 k^2 d rightright\nendaligned\n\nnote: Note\nWhen H is square and circulant (full_rank=false), classical checks connect opposite endpoints of the length-n classical code and give rise to a quantum code with stabilizers connecting opposite array boundaries, i.e. with periodic boundary conditions. On the contrary, rectangular parity-check matrices in mathbbF_2^(nk)n give rise to a quantum code with stabilizers stretching up to the array extent, i.e. with open boundary conditions.\n\nCyclic Codes and Circulant Matrices\n\nA cyclic code is a linear code in which codewords remain valid under cyclic shifts. A circulant matrix is a square matrix where each row is a cyclic shift of the first row. When the parity-check matrix H is circulant, the code is fully determined by its first row:\n\nbeginaligned\nH = textcirc(c_0 c_1 dots c_k 0 dots 0) in mathbbF_2^n times n\nendaligned\n\nThe elements c_i (for i = 0 1 dots k) correspond to the coefficients of a degree-k polynomial:\n\nbeginaligned\nh(x) = 1 + sum_i=1^k c_i x^i in mathbbF_2x(x^n - 1)\nendaligned\n\nThis establishes a mapping between mathbbF_2^n and the quotient ring mathbbF_2x(x^n - 1), where cyclic shifts in mathbbF_2^n correspond to multiplications by x in the polynomial ring. Since multiplication by x preserves the ideal structure of mathbbF_2x(x^n - 1), cyclic codes correspond to ideals in this ring. These ideals are in one-to-one correspondence with unitary mod-2 divisors of x^n - 1 with a leading coefficient of 1. Consequently, the fundamental building blocks of cyclic codes correspond to the factorization of x^n - 1.\n\nnote: Note\nFor k = 1, the generator polynomial h(x) = 1 + x defines the repetition code.\n\nPolynomial Representation\n\nThe first row of a circulant matrix H = textcirc(c_0 c_1 c_2 dots c_n-1) can be mapped to the coefficients of a polynomial h(x). For instance, if the first row is 1 1 0 1, the polynomial is: h(x) = 1 + x + x^3. This polynomial-based representation aids in the analysis and design of cyclic codes. For our implementation of La-cross codes, we leverage Hecke.polynomial_ring to work directly with polynomial rings rather than manipulating coefficient arrays explicitly.\n\nnote: Note\nThe next-to-next-to-nearest neighbor connectivity implies the use of a degree-3 seed polynomial h(x) = 1 + x + x^2 + x^3 in the ring mathbbF_2x(x^n - 1) for a specific code length n. Additionally, the condition of low stabilizer weight requires the polynomial 1 + x + x^3.\n\n[[2n², 2k², d]] La-cross Code\n\nHere is [[98, 18, 4]] La-cross code from with h(x) = 1 + x + x^3, n = 7, and k = 3 from Appendix A of (Pecorari et al., 2025).\n\njulia> using QuantumClifford; using QuantumClifford.ECC; # hide\n\njulia> import Hecke: GF, polynomial_ring;\n\njulia> n = 7; k = 3; F = GF(2);\n\njulia> R, x = polynomial_ring(F, \"x\");\n\njulia> h = 1 + x + x^k;\n\njulia> c = LaCross(n, h, false);\n\njulia> import HiGHS;\n\njulia> code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n(98, 18, 4)\n\n[[(n - k)² + n², k², d]] La-cross Code\n\nHere is [[65, 9, 4]] La-cross code from with h(x) = 1 + x + x^3, n = 7, k = 3 and full rank seed rectangular circulant matrix from Appendix A of (Pecorari et al., 2025).\n\njulia> c = LaCross(n, h, true);\n\njulia> code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n(65, 9, 4)\n\nHere is [[400, 16, 8]] La-cross code from with h(x) = 1 + x + x^4, n = 16, k = 4 from (Pecorari et al., 2025).\n\njulia> n = 16; k = 4;\n\njulia> R, x = polynomial_ring(F, \"x\");\n\njulia> h = 1 + x + x^k;\n\njulia> full_rank = true;\n\njulia> c = LaCross(n, h, full_rank);\n\njulia> code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n(400, 16, 8)\n\nThe ECC Zoo has an entry for this family.\n\nFields\n\nn::Int64: The block length of the classical seed code.\nh::Nemo.FqPolyRingElem: The seed vector is represented with a degree-n polynomial of the form h(x) = sum_i=0^n-1 c_i x^i.\nfull_rank::Bool: A flag indicating whether to use the full-rank rectangular matrix (true) or the original circulant matrix (false).\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QuantumCliffordHeckeExt.LiftedCode","page":"API","title":"QuantumCliffordHeckeExt.LiftedCode","text":"struct LiftedCode <: AbstractCECC\n\nClassical codes lifted over a group algebra, used for lifted product code construction ((Panteleev and Kalachev, 2021), (Panteleev and Kalachev, Jun 2022))\n\nThe parity-check matrix is constructed by applying repr to each element of A, which is mathematically a linear map from a group algebra element to a binary matrix. The size of the parity check matrix will enlarged with each element of A being inflated into a matrix. The procedure is called a lift (Panteleev and Kalachev, Jun 2022).\n\nConstructors\n\nA lifted code can be constructed via the following approaches:\n\nA matrix of group algebra elements.\nA matrix of group elements, where a group element will be considered as a group algebra element by assigning a unit coefficient.\nA matrix of integers, where each integer represent the shift of a cyclic permutation. The order of the cyclic permutation should be specified.\n\nThe default GA is the group algebra of A[1, 1], the default representation repr is the permutation representation.\n\nBelow is a list of all constructors:\n\nLiftedCode(A; GA, repr)\n\ndefined at /home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted.jl:58.\n\nLiftedCode(A; GA)\n\ndefined at /home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted.jl:68.\n\nLiftedCode(group_elem_array; GA, repr)\n\ndefined at /home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted.jl:74.\n\nLiftedCode(shift_array, l; GA, repr)\n\ndefined at /home/runner/work/QuantumClifford.jl/QuantumClifford.jl/ext/QuantumCliffordHeckeExt/lifted.jl:87.\n\nThe representation function repr\n\nWe use the default representation function Hecke.representation_matrix to convert a GF(2)-group algebra element to a binary matrix. The default representation, provided by Hecke, is the permutation representation.\n\nWe also accept a custom representation function (the repr field of the constructor). Whatever the representation, the matrix elements need to be convertible to Integers (e.g. permit lift(ZZ, ...)). Such a customization would be useful to reduce the number of bits required by the code construction.\n\nFor example, if we use a D4 group for lifting, our default representation will be 8×8 permutation matrices, where 8 is the group's order. However, we can find a 4×4 matrix representation for the group, e.g. by using the typical 2×2 representation and converting it into binary representation by replacing \"1\" with the Pauli I, and \"-1\" with the Pauli X matrix.\n\nSee also: QuantumClifford.ECC.LPCode.\n\nAll fields:\n\nA::Union{LinearAlgebra.Adjoint{<:Hecke.GroupAlgebraElem, <:Matrix{<:Hecke.GroupAlgebraElem}}, Matrix{<:Hecke.GroupAlgebraElem}}: the base matrix of the code, whose elements are in a group algebra.\nGA::Hecke.GroupAlgebra: the group algebra for which elements in A are from.\nrepr::Function: a function that converts a group algebra element to a binary matrix; default to be the permutation representation for GF(2)-algebra.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QuantumClifford.ECC.bicycle_codes-Tuple{Array{Int64}, Int64}","page":"API","title":"QuantumClifford.ECC.bicycle_codes","text":"bicycle_codes(a_shifts::Array{Int64}, l::Int64) -> Any\n\n\nBicycle codes are a special case of generalized bicycle codes, where a and b are conjugate to each other. The order of the cyclic group is l, and the shifts a_shifts and b_shifts are reverse to each other. Thus you need to provide only the a_shifts and the rest of the conversions and conjugations are taken care of.\n\nSee also: two_block_group_algebra_codes, generalized_bicycle_codes, haah_cubic_codes.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.generalized_bicycle_codes-Tuple{Array{Int64}, Array{Int64}, Int64}","page":"API","title":"QuantumClifford.ECC.generalized_bicycle_codes","text":"generalized_bicycle_codes(\n    a_shifts::Array{Int64},\n    b_shifts::Array{Int64},\n    l::Int64\n) -> Any\n\n\nGeneralized bicycle codes, which are a special case of abelian 2GBA codes (and therefore of lifted product codes). Here the group is chosen as the cyclic group of order l, and the base matrices a and b are the sum of the group algebra elements corresponding to the shifts a_shifts and b_shifts.\n\nBehind the scenes, the shifts are converted to the corresponding group algebra elements and piped to two_block_group_algebra_codes.\n\nSee also: two_block_group_algebra_codes, bicycle_codes.\n\nExamples\n\nA [[254, 28, 14 ≤ d ≤ 20]] code from (A1) in Appendix B of (Panteleev and Kalachev, 2021).\n\njulia> import Hecke; using QuantumClifford.ECC\n\njulia> c = generalized_bicycle_codes([0, 15, 20, 28, 66], [0, 58, 59, 100, 121], 127);\n\njulia> code_n(c), code_k(c)\n(254, 28)\n\nAn [[70, 8, 10]] abelian 2BGA code from Table 1 of (Lin and Pryadko, 2024), with cyclic group of order l = 35, illustrates that abelian 2BGA codes can be viewed as GB codes.\n\njulia> import Hecke; using QuantumClifford.ECC\n\njulia> l = 35;\n\njulia> c1 = generalized_bicycle_codes([0, 15, 16, 18], [0, 1, 24, 27], l);\n\njulia> code_n(c1), code_k(c1)\n(70, 8)\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.haah_cubic_codes-Tuple{Array{Int64}, Array{Int64}, Int64}","page":"API","title":"QuantumClifford.ECC.haah_cubic_codes","text":"haah_cubic_codes(\n    a_shifts::Array{Int64},\n    b_shifts::Array{Int64},\n    l::Int64\n) -> Any\n\n\nHaah’s cubic codes (Haah, 2011) can be viewed as generalized bicycle (GB) codes with the group G = Cₗ × Cₗ × Cₗ, where l denotes the lattice size. In particular, a GB code with the group G = ℤ₃ˣ³ corresponds to a cubic code.\n\nBehind the scenes, this function is just a simple shortcut for preparing the group G, before piping the arguments to generalized_bicycle_codes.\n\nThe ECC Zoo has an entry for this family.\n\nSee also: bicycle_codes, generalized_bicycle_codes, two_block_group_algebra_codes.\n\nExamples\n\njulia> import Hecke; using QuantumClifford.ECC;\n\njulia> c = haah_cubic_codes([0, 15, 20, 28, 66], [0, 58, 59, 100, 121], 6);\n\njulia> code_n(c), code_k(c)\n(432, 8)\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.haah_cubic_codes-Tuple{Int64}","page":"API","title":"QuantumClifford.ECC.haah_cubic_codes","text":"Haah’s cubic code is defined as textLP(1 + x + y + z 1 + xy + xz + yz) where textLP is the lifted product code, and x, y, z are elements of the ring R = mathbbF_2x y z  (x^L - 1 y^L - 1 z^L - 1). Here mathbbF_2 is the finite field of order 2 and L is the lattice size. The ring R is the group algebra mathbbF_qG of a finite group G, where G = (C_L)^3 and C_L is the cyclic group of order L. This method of Haah's cubic code construction is outlined in Appendix B of (Panteleev and Kalachev, Jun 2022).\n\nHere is an example of a [[1024, 30, 13 ≤ d ≤ 32]] Haah's cubic code from Appendix B, code D of (Panteleev and Kalachev, 2021) on the 8 × 8 × 8 Lattice.\n\njulia> import Hecke; using QuantumClifford.ECC;\n\njulia> l = 8;\n\njulia> c = haah_cubic_codes(l);\n\njulia> code_n(c), code_k(c)\n(1024, 30)\n\nSee also: bicycle_codes, generalized_bicycle_codes, two_block_group_algebra_codes, honeycomb_color_codes.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.honeycomb_color_codes-Tuple{Int64, Int64}","page":"API","title":"QuantumClifford.ECC.honeycomb_color_codes","text":"The honeycomb color codes (Eberhardt and Steffan, 2024) are exactly the Bivariate Bicycle (BB) codes defined by the polynomials c = 1 + x + xy and d = 1 + y + xy, provided that both ℓ and m are divisible by three. This 6.6.6 code is an example of BB code, as it represents a special case.\n\nThe ECC Zoo has an entry for this family.\n\njulia> import Hecke; using QuantumClifford.ECC;\n\njulia> ℓ = 9; m = 6;\n\njulia> c = honeycomb_color_codes(ℓ, m);\n\njulia> code_n(c), code_k(c)\n(108, 4)\n\nSee also: bicycle_codes, generalized_bicycle_codes, two_block_group_algebra_codes, honeycomb_color_codes.\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.two_block_group_algebra_codes-Tuple{Hecke.GroupAlgebraElem, Hecke.GroupAlgebraElem}","page":"API","title":"QuantumClifford.ECC.two_block_group_algebra_codes","text":"two_block_group_algebra_codes(\n    a::Hecke.GroupAlgebraElem,\n    b::Hecke.GroupAlgebraElem\n) -> Any\n\n\nTwo-block group algebra (2BGA) codes, which are a special case of lifted product codes from two group algebra elements a and b, used as 1×1 base matrices. To build them, you pick a group and specific generators for that group, then you pick two polynomials made of the group generators, and then, behind the scenes, these two polynomials a and b are piped to the lifted product code constructor as the elements of 1×1 matrices.\n\nSee also: LPCode, generalized_bicycle_codes, bicycle_codes, haah_cubic_codes, honeycomb_color_codes.\n\nExamples of 2BGA code subfamilies\n\nC₄ x C₂\n\nHere is an example of a [[56, 28, 2]] 2BGA code from Table 2 of (Lin and Pryadko, 2024) build out of polymonials of generators of the direct product C₄ × C₂.\n\njulia> import Hecke: group_algebra, GF, abelian_group, gens; using QuantumClifford.ECC;\n\njulia> GA = group_algebra(GF(2), abelian_group([14,2]));\n\njulia> x, s = gens(GA);\n\njulia> A = 1 + x^7;\n\njulia> B = 1 + x^7 + s + x^8 + s*x^7 + x;\n\njulia> c = two_block_group_algebra_codes(A,B);\n\njulia> import HiGHS;\n\njulia> code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n(56, 28, 2)\n\nBivariate Bicycle codes\n\nBivariate Bicycle codes are a class of Abelian 2BGA codes formed by the direct product of two cyclic groups ℤₗ × ℤₘ. The parameters l and m represent the orders of the first and second cyclic groups, respectively.\n\nThe ECC Zoo has an entry for this family.\n\nA [[756, 16, ≤ 34]] code from Table 3 of (Bravyi et al., 2024):\n\njulia> import Hecke: group_algebra, GF, abelian_group, gens; using QuantumClifford.ECC;\n\njulia> l=21; m=18;\n\njulia> GA = group_algebra(GF(2), abelian_group([l, m]));\n\njulia> x, y = gens(GA);\n\njulia> A = x^3 + y^10 + y^17;\n\njulia> B = y^5 + x^3  + x^19;\n\njulia> c = two_block_group_algebra_codes(A,B);\n\njulia> code_n(c), code_k(c)\n(756, 16)\n\nMultivariate Bicycle code\n\nThe group algebra of the qubit multivariate bicycle (MB) code with r variables is 𝔽₂[𝐺ᵣ], where 𝐺ᵣ = ℤ/l₁ × ℤ/l₂ × ... × ℤ/lᵣ.\n\nA [[48, 4, 6]] Weight-6 TB-QLDPC code from Appendix A Table 2 of (Voss et al., 2024).\n\njulia> import Hecke: group_algebra, GF, abelian_group, gens; using QuantumClifford.ECC;\n\njulia> l=4; m=6;\n\njulia> GA = group_algebra(GF(2), abelian_group([l, m]));\n\njulia> x, y = gens(GA);\n\njulia> z = x*y;\n\njulia> A = x^3 + y^5;\n\njulia> B = x + z^5 + y^5 + y^2;\n\njulia> c = two_block_group_algebra_codes(A, B);\n\njulia> import HiGHS\n\njulia> code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n(48, 4, 6)\n\nCoprime Bivariate Bicycle code\n\nThe coprime bivariate bicycle (BB) codes are defined by two polynomials 𝑎(𝑥,𝑦) and 𝑏(𝑥,𝑦), where 𝑙 and 𝑚 are coprime, and can be expressed as univariate polynomials 𝑎(𝜋) and 𝑏(𝜋), with generator 𝜋 = 𝑥𝑦. They can be viewed as a special case of Lifted Product construction based on abelian group ℤₗ x ℤₘ where ℤⱼ cyclic group of order j.\n\n[[108, 12, 6]] coprime-bivariate bicycle (BB) code from Table 2 of (Wang and Mueller, 2024).\n\njulia> import Hecke: group_algebra, GF, abelian_group, gens; using QuantumClifford.ECC;\n\njulia> l=2; m=27;\n\njulia> GA = group_algebra(GF(2), abelian_group([l*m]));\n\njulia> 𝜋 = gens(GA)[1];\n\njulia> A = 𝜋^2 + 𝜋^5  + 𝜋^44;\n\njulia> B = 𝜋^8 + 𝜋^14 + 𝜋^47;\n\njulia> c = two_block_group_algebra_codes(A, B);\n\njulia> import HiGHS\n\njulia> code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n(108, 12, 6)\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#Implemented-in-an-extension-requiring-Oscar.jl","page":"API","title":"Implemented in an extension requiring Oscar.jl","text":"","category":"section"},{"location":"ECC_API/#QuantumCliffordOscarExt.DDimensionalSurfaceCode","page":"API","title":"QuantumCliffordOscarExt.DDimensionalSurfaceCode","text":"struct DDimensionalSurfaceCode <: QuantumCliffordOscarExt.DDimensionalCode\n\nConstructs the D-dimensional surface code using chain complexes and mathbbF_2-homology.\n\nHomological Algebra Foundations of Quantum Error Correction\n\nThe theory of chain complexes over mathbbF_2 provides a unified framework for understanding error-correcting codes, where classical n k d codes correspond to 2-term complexes and quantum CSS codes arise naturally as 3-term complexes satisfying the commutativity condition H_Z^T H_X = 0. The homological framework reveals that:\n\nQuantum CSS codes arise from chain complexes where boundary operators correspond to parity checks.\nLogical operators correspond to homology classes.\nHigher-dimensional codes can be constructed through products of complexes.\n\nChain Complex Structure\n\nA chain complex C of length n is a sequence of finite-dimensional vector spaces C_j over mathbbF_2 connected by boundary operators that are linear transformations partial_j colon C_j to C_j-1:\n\nbeginaligned\nC  0 longrightarrow C_n xrightarrowpartial_n C_n-1 xrightarrowpartial_n-1 cdots xrightarrowpartial_2 C_1 xrightarrowpartial_1 C_0 longrightarrow 0\nendaligned\n\nwith boundary operators satisfying partial_i circ partial_i+1 = 0 (equivalently, textim partial_j+1 subseteq ker partial_j).We define:\n\ni-chains: Elements of C_i\ni-cycles: Z_i(C) = ker partial_i\ni-boundaries: B_i(C) = mathrmim partial_i+1\ni-th homology: H_i(C) = Z_i(C)B_i(C)\n\nCohomology of the Dual Complex\n\nGiven a chain complex C with boundary operators partial_j, its cochain complex widetildeC is the dual sequence with coboundary maps delta^i = partial_i+1^T:\n\nbeginaligned\nwidetildeC  0 longleftarrow C_0^* xleftarrowpartial_1^T C_1^* xleftarrowpartial_2^T cdots xleftarrowpartial_n^T C_n^* longleftarrow 0\nendaligned\n\nwhere\n\ni-cocycles: Z^i(widetildeC) = ker partial_i+1^T\ni-coboundaries: B^i(widetildeC) = mathrmim partial_i^T\ni-th cohomology: H^i(widetildeC) = Z^i(widetildeC)B^i(widetildeC)\n\nnote: Note\nThe cohomology group H^i(widetildeC) = H(partial_i+1^T partial_i^T) has the same rank as the homology group H_i(C) and corresponds to X-type logical operators in the CSS code CSS(partial_i partial_i+1^T), while H_i(C) corresponds to Z-type operators. \n\nClassical Codes via Chain Complexes and mathbbF_2 Homology\n\nAn nkd classical code corresponds to a 2-term complex:\n\nbeginaligned\n0 longrightarrow C_1 xrightarrowpartial_1 = H C_0 longrightarrow 0\nendaligned\n\nwhere\n\nC_1 = mathbbF_2^n (codeword space)\nC_0 = mathbbF_2^n-k (syndrome space)\nH is the parity check matrix\n\nQuantum CSS Codes via Chain Complexes and mathbbF_2 Homology\n\nQuantum CSS codes extend this to 3-term complexes:\n\nbeginaligned\n0 longrightarrow C_2 xrightarrowpartial_2 = H_Z^T C_1 xrightarrowpartial_1 = H_X C_0 longrightarrow 0\nendaligned\n\nwhere\n\nC_1 = mathbbF_2^n (physical qubits)\nC_2 = mathbbF_2^m_Z (Z-stabilizers)\nC_0 = mathbbF_2^m_X (X-stabilizers)\n\nwith the condition partial_1 partial_2 = H_Z^TH_X = 0 ensuring that CSS orthogonality is satisfied.\n\nFor any chain complex, selecting two consecutive boundary operators defines a valid CSS code. When qubits are identified with the space C_i, the code parameters are:\n\nnumber of physical qubits: n = dim C_i\nnumber of logical qubits: k = dim H_i(C) = dim H^i(C)\ncode distance: d = mintextwt(v)  v in (H_i(C) cup H^i(C))backslash0\n\nnote: Note\nQuantum error-correcting codes, which are represented as 3-term chain complexes, can be constructed by applying the homological or hypergraph product to two 2-term chain complexes.\n\nFor a detailed explanation, see the ECC Zoo's writeup on the  CSS-to-homology correspondence.\n\nD-dimensional Surface Code ((Berthusen et al., 2024), (Zeng and Pryadko, 2019))\n\nWe provide an explicit construction of the D-dimensional surface code within the framework of chain complexes and homology over mathbbF_2.\n\nThe quantum code is obtained by applying the homological product (or hypergraph product) to two 2-term chain complexes. Our construction relies on taking the hypergraph product of these complexes.\n\nDouble Complex\n\nGiven chain complexes C and D, we construct a double complex derived from the tensor product of two 2-term chain complexes:\n\nbeginaligned\nC boxtimes D quad textwith quad partial_i^v = partial_i^C otimes I_D_i quad textand quad partial_i^h = I_C_i otimes partial_i^D\nendaligned\n\nTotal Complex\n\nThe total complex is derived from a double complex by taking the direct sum of vector spaces and boundary maps that share the same dimension:\n\nbeginaligned\ntextTot(C boxtimes D)_i = bigoplus_i=j+k C_j otimes D_k = E_i\nendaligned\n\nwith boundary maps:\n\nbeginaligned\npartial_i^E = bigoplus_i=j+k partial_j^v oplus partial_k^h\nendaligned\n\nThe resulting chain complex, called the tensor product of C and D, C  D, enables the construction of a CSS code when selecting any three consecutive terms in its sequence.\n\nSubfamilies\n\n[[L² + (L − 1)², 1, L]] 2D Surface Code\n\nThe 2D surface code is constructed using the hypergraph product of two repetition codes.Thus, we obtain a new 3-term chain complex:\n\nbeginaligned\nE_2 xrightarrowpartial_2^E E_1 xrightarrowpartial_1^E E_0\nendaligned\n\nExamples\n\njulia> using Oscar; using QuantumClifford; using QuantumClifford.ECC;\n\njulia> D = 2; L = 2;\n\njulia> c = DDimensionalSurfaceCode(D, L);\n\njulia> code = parity_checks(c)\n+ X_X_X\n+ _X_XX\n+ ZZ__Z\n+ __ZZZ\n\njulia> import HiGHS; import JuMP;\n\njulia> code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n(5, 1, 2)\n\nWhen L = 4, we get [[25,1, 4]] 2D surface code from (Berthusen et al., 2024).\n\njulia> using Oscar; using QuantumClifford; using QuantumClifford.ECC;\n\njulia> D = 2; L = 4;\n\njulia> c = DDimensionalSurfaceCode(D, L);\n\njulia> code = parity_checks(c)\n+ X___X___________X________\n+ _X___X__________XX_______\n+ __X___X__________XX______\n+ ___X___X__________X______\n+ ____X___X__________X_____\n+ _____X___X_________XX____\n+ ______X___X_________XX___\n+ _______X___X_________X___\n+ ________X___X_________X__\n+ _________X___X________XX_\n+ __________X___X________XX\n+ ___________X___X________X\n+ ZZ______________Z________\n+ _ZZ______________Z_______\n+ __ZZ______________Z______\n+ ____ZZ__________Z__Z_____\n+ _____ZZ__________Z__Z____\n+ ______ZZ__________Z__Z___\n+ ________ZZ_________Z__Z__\n+ _________ZZ_________Z__Z_\n+ __________ZZ_________Z__Z\n+ ____________ZZ________Z__\n+ _____________ZZ________Z_\n+ ______________ZZ________Z\n\njulia> import HiGHS; import JuMP;\n\njulia> code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n(25, 1, 4)\n\nChain Complex\n\nThe construction is as follows:\n\nbeginaligned\nC = left( C_1 xrightarrowpartial C_0 right) quad textand quad D = left( D_1 xrightarrowpartial^T D_0 right)\nendaligned\n\nwhere partial is the (L-1) times L parity check matrix:\n\nbeginaligned\nH = beginpmatrix\n1  1   \n  1  ddots  \n   ddots  1 \n    1\nendpmatrix\nendaligned\n\n[[L³ + 2L(L − 1)², 1, min(L, L²)]] 3D Surface Code\n\nThe 3D surface code is obtained by taking the hypergraph product of a 2D surface code with a repetition code. Thus, we obtain a new 4-term chain complex:\n\nbeginaligned\nF_3 xrightarrowpartial_3^F F_2 xrightarrowpartial_2^F F_1 xrightarrowpartial_1^F F_0\nendaligned\n\nMetachecks\n\nZ-type metachecks: M_Z^T = partial_3^F\n\nExample\n\nHere is an example of [[12, 1, 2]] 3D Surface code with L = 2 from (Berthusen et al., 2024).\n\njulia> using Oscar; using QuantumClifford; using QuantumClifford.ECC;\n\njulia> D = 3; L = 2;\n\njulia> c = DDimensionalSurfaceCode(D, L);\n\njulia> code = parity_checks(c)\n+ XX__X_____X_\n+ __XXX______X\n+ _____XX__XX_\n+ _______XXX_X\n+ Z_Z_Z_______\n+ _Z_ZZ_______\n+ _____Z_Z_Z__\n+ ______Z_ZZ__\n+ Z____Z____Z_\n+ _Z____Z___Z_\n+ __Z____Z___Z\n+ ___Z____Z__Z\n+ ____Z____ZZZ\n\njulia> code_n(c), code_k(c)\n(12, 1)\n\nnote: Note\nFor the 3D surface code, there is an asymmetry between the Z- and X-bases (Berthusen et al., 2024). Specifically, the Z-distance (d_Z) is 4, whereas the X-distance (d_X) is 2. As a result, the code has the parameters [[12, 1, 2]].\n\njulia> import HiGHS; import JuMP;\n\njulia> dz = distance(c, DistanceMIPAlgorithm(solver=HiGHS, logical_operator_type=:Z))\n4\n\njulia> dx = distance(c, DistanceMIPAlgorithm(solver=HiGHS, logical_operator_type=:X))\n2\n\n[[6L⁴ − 12L³ + 10L² − 4L + 1, 1, L²]] 4D Surface Code\n\nThe 4D surface code is constructed by taking the hypergraph product of a 3D surface code with a repetition code.  Thus, we obtain a new 5-term chain complex:\n\nbeginaligned\nG_4 xrightarrowpartial_4^G G_3 xrightarrowpartial_3^G G_2 xrightarrowpartial_2^G G_1 xrightarrowpartial_1^G G_0\nendaligned\n\n[[33, 1, 4]]\n\nHere is an example of [[33, 1, 4]] 4D Surface code with L = 2 from (Berthusen et al., 2024).\n\njulia> using Oscar; using QuantumClifford; using QuantumClifford.ECC;\n\njulia> D = 4; L = 2;\n\njulia> c = DDimensionalSurfaceCode(D, L);\n\njulia> import HiGHS; import JuMP;\n\njulia> code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n(33, 1, 4)\n\nMetachecks\n\nBoth X and Z-type metachecks available:\n\nM_Z^T = partial_4^G\nM_X = partial_1^G\n\nTo obtain surface codes of greater dimensionality, we alternate between C and D and then form a product with the chain complex representing the DDimensionalSurfaceCode (Berthusen et al., 2024).\n\nnote: Note\nThe procedure described above for the DDimensionalSurfaceCode can alternatively be performed using an L × L repetition code and only the chain complex C. In this case, the result would be the DDimensionalToricCode.\n\nSee also: DDimensionalToricCode\n\nFields\n\nD::Int64: Dimension of the Surface code (must be ≥ 2).\nL::Int64: Size parameter determining the D-dimensional Surface code family, constructed via hypergraph product of (L - 1) × L repetition code chain complexes.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QuantumCliffordOscarExt.DDimensionalToricCode","page":"API","title":"QuantumCliffordOscarExt.DDimensionalToricCode","text":"struct DDimensionalToricCode <: QuantumCliffordOscarExt.DDimensionalCode\n\nD-dimensional Toric Code ((Berthusen et al., 2024), (Zeng and Pryadko, 2019))\n\nThe D-dimensional toric code is obtained by taking the iterated tensor product of a single chain complex:\n\nbeginaligned\nC = left( mathbbF_2^L xrightarrowH mathbbF_2^L right)\nendaligned\n\nwhere H is the L times L parity check matrix of the repetition code. The total complex is built by taking the tensor product C^otimes D and forming the associated total complex via direct sums.\n\nnote: Note\nD-dimensional toric code construction differs from the surface code as we use the full L times L repetition code (rather than (L-1) times L). The tensor products with identical complexes (rather than alternating complexes) are used.\n\nSubfamilies\n\n[[2L², 2, L]] 2D Toric Code\n\njulia> using Oscar; using QuantumClifford; using QuantumClifford.ECC;\n\njulia> D = 2; L = 2;\n\njulia> c = DDimensionalToricCode(D, L);\n\njulia> code = parity_checks(c)\n+ X_X_XX__\n+ _X_XXX__\n+ X_X___XX\n+ _X_X__XX\n+ ZZ__Z_Z_\n+ ZZ___Z_Z\n+ __ZZZ_Z_\n+ __ZZ_Z_Z\n\njulia> import HiGHS; import JuMP;\n\njulia> code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n(8, 2, 2)\n\n[[3L³, 3, min(L, L²)]] 3D Toric Code\n\njulia> using Oscar; using QuantumClifford; using QuantumClifford.ECC;\n\njulia> D = 3; L = 2;\n\njulia> c = DDimensionalToricCode(D, L);\n\njulia> import HiGHS; import JuMP;\n\njulia> code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n(24, 3, 2)\n\n[[6L⁴, 6, L²]] 4D Toric Code\n\njulia> using Oscar; using QuantumClifford; using QuantumClifford.ECC;\n\njulia> D = 4; L = 2;\n\njulia> c = DDimensionalToricCode(D, L);\n\njulia> import HiGHS; import JuMP;\n\njulia> code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n(96, 6, 4)\n\nSee also: DDimensionalSurfaceCode\n\nFields\n\nD::Int64: Dimension of the Toric code (must be ≥ 2).\nL::Int64: Size parameter determining the D-dimensional Toric code family, constructed via hypergraph product of L × L repetition code chain complexes.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QuantumCliffordOscarExt.DoubleHomologicalProductCode","page":"API","title":"QuantumCliffordOscarExt.DoubleHomologicalProductCode","text":"Constructs the Double Homological Product code from (Campbell, 2019).\n\n4-term Chain Complex\n\nTo construct a quantum error-correcting code with metachecks, we require a length-4 chain complex. This can be built by taking the homological product of two length-2 chain complexes.\n\nThe length-4 chain complex, structured as:  \n\nbeginaligned\nbreveC_-2 xrightarrowbrevedelta_-2 breveC_-1 xrightarrowbrevedelta_-1 breveC_0 xrightarrowbrevedelta_0 breveC_1 xrightarrowbrevedelta_1 breveC_2\nendaligned\n\nThe homological product of two 2D chain complexes produces this length-4 complex, following the general rule:  \n\nbeginaligned\nbreveC_m = bigoplus_i - j = m tildeC_i otimes tildeC_j\nendaligned\n\nThe boundary maps are represented as block matrices and are defined as:  \n\nbeginalign\nbrevedelta_-2 = beginpmatrix \nI otimes tildedelta_0^T  \ntildedelta_-1 otimes I \nendpmatrix \nbrevedelta_-1 = beginpmatrix \nI otimes tildedelta_-1^T  0 \ntildedelta_-1 otimes I  I otimes tildedelta_0^T \n0  tildedelta_0 otimes I \nendpmatrix \nbrevedelta_0 = beginpmatrix \ntildedelta_-1 otimes I  I otimes tildedelta_-1^T  0 \n0  tildedelta_0 otimes I  I otimes tildedelta_0^T \nendpmatrix \nbrevedelta_1 = beginpmatrix \ntildedelta_0 otimes I  I otimes tildedelta_-1^T \nendpmatrix\nendalign\n\nThe condition brevedelta_j+1 brevedelta_j = 0 holds for all j, which follows from the corresponding property of the tildedelta matrices.  \n\nExample\n\nHere is [[241, 1, 9]] double homological product code from Table I of (Campbell, 2019).\n\njulia> using Oscar; using QuantumClifford; using QuantumClifford.ECC; using QECCore;\n\njulia> δ = [1 1 0;\n            0 1 1];\n\njulia> c = DoubleHomologicalProductCode(δ);\n\njulia> import HiGHS; import JuMP;\n\njulia> code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n(241, 1, 9)\n\nFields\n\nH::AbstractMatrix: The parity-check matrix of a classical error-correcting code.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QuantumCliffordOscarExt.GeneralizedToricCode","page":"API","title":"QuantumCliffordOscarExt.GeneralizedToricCode","text":"struct GeneralizedToricCode <: AbstractCSSCode\n\nThe generalized toric code is specified by two Laurent polynomials f(xy) and g(xy) over mathbbF_2. These polynomials encode the local stabilizers of the X and Z-type operators. The parameters (α, β, γ) define the geometry of the underlying twisted torus:\n\nalpha: vertical period from lattice vector a_1 = (0 alpha)\nbeta: horizontal extent from lattice vector a_2 = (beta gamma)\ngamma: vertical shift applied when wrapping horizontally\n\nLaurent Polynomial Formalism\n\nAny two-dimensional translation-invariant Pauli stabilizer code over mathbbZ_2 qubits that satisfies the topological order condition can be transformed via a finite-depth quantum circuit into a direct sum of Kitaev toric codes ((Liang et al., 2025), (Liang et al., 2024)).\n\n(Liang et al., 2025) employ a ring-theoretic approach within the framework of topological order to study two-dimensional topological CSS codes using Laurent polynomial formalism. This technique allows for efficient construction of new quantum LDPC codes.\n\nnote: Note\nThe use of twisted tori enables stabilizers with more localized support compared to prior methods.  \n\nBy leveraging Laurent polynomial rings, (Liang et al., 2025) derive the topological order associated with Pauli stabilizer codes. Extending this framework, it introduces a ring-theoretic method that simplifies computations for CSS codes. Specifically, Gröbner basis techniques are utilized to classify anyons in these topological orders (Liang et al., 2025).  \n\nFor simplicity, (Liang et al., 2025) focus on the square lattice. On the square lattice, a unit cell consisting of two edges, representing their Pauli operators as 4-dimensional vectors:  \n\nbeginaligned\nX_1 = beginbmatrix 1  0  0  0 endbmatrix quad\nX_2 = beginbmatrix 0  1  0  0 endbmatrix quad\nZ_1 = beginbmatrix 0  0  1  0 endbmatrix quad\nZ_2 = beginbmatrix 0  0  0  1 endbmatrix\nendaligned\n\nTranslated Pauli operators are obtained by multiplying these basis vectors by the monomial x^n y^m (where n, m may be negative), implementing a shift of n steps in the x-direction and m steps in the y-direction. In this formalism, the product of two Pauli operators corresponds to the sum of their 4-dimensional vectors.  \n\nThe Pauli operator vectors form a module over the Laurent polynomial ring R = mathbbZ_2x y x^-1 y^-1.  \n\nThe translation-invariant mathbbZ_2 CSS code with stabilizers expressed as:  \n\nbeginaligned\nA_v = beginbmatrix f(x y)  g(x y)  hline 0  0 endbmatrix quad\nB_p = beginbmatrix 0  0  hline overlineg(x y)  overlinef(x y) endbmatrix\nendaligned\n\nwhere overlinex^n y^m = x^-n y^-m. A_v and B_p denote the X and Z stabilizer generators, respectively, forming the stabilizer group S. Specifically, S is generated by all lattice translations of A_v and B_p, i.e., the set of operators x^n y^m A_v x^n y^m B_p mid n m in mathbbZ (Liang et al., 2025).\n\nUtilizing Laurent polynomial formalism, (Liang et al., 2025) introduces the generalized toric code, a subclass of bivariate bicycle codes, defined by:  \n\nbeginaligned\nf(x y) = 1 + x + x^a y^b quad \ng(x y) = 1 + y + x^c y^d\nendaligned\n\nTopological Order Condition\n\nA key condition (Liang et al., 2025) for these polynomials is:  \n\nbeginaligned\nlangle f(x y) rangle cap langle g(x y) rangle = langle f(x y) g(x y) rangle\nendaligned\n\nwhere langle p(x y) rangle denotes the ideal in R generated by p(x y). This implies that f(x y) and g(x y) are coprime.  \n\nConsider the [[396, 8, ≤ 26]] Generalized Toric Code from Table IV of (Liang et al., 2025). The TO condition is proved using Oscarjl as follows:\n\njulia> using Oscar; using QuantumClifford; using QuantumClifford.ECC;\n\njulia> R, (x, y, x⁻¹, y⁻¹) = polynomial_ring(GF(2), [:x, :y, :x⁻¹, :y⁻¹]);\n\njulia> rels = [x*x⁻¹ - 1, y*y⁻¹ - 1];\n\njulia> R_q = quo(R, rels)[1];\n\njulia> f = 1 + x + x⁻¹*y⁻¹^3;\n\njulia> g = 1 + y + x^3*y⁻¹;\n\njulia> I = ideal(R_q, [f]);\n\njulia> J = ideal(R_q, [g]);\n\njulia> I_cap_J = intersect(I, J);\n\njulia> I_times_J = ideal(R_q, [f*g]);\n\njulia> I_cap_J == I_times_J\ntrue\n\njulia> is_coprime(f, g)\ntrue\n\nGröbner basis Computation\n\nA useful computational technique involves computing the Gröbner basis for the polynomials f(x y) = xf(x y) and g(x y) = yg(x y) to ensure non-negative exponents. Alternatively, one may introduce auxiliary variables overlinex overliney to represent x^-1 y^-1 and include the relations overlinexx - 1 and overlineyy - 1 in the Gröbner basis computation (Liang et al., 2025).\n\nExample\n\nHere is an example of computing the maximum logical dimension of Example 5 (−1, −4, 4, −1)-generalized toric code from (Liang et al., 2025).\n\njulia> using Oscar; using QuantumClifford.ECC: max_xy_exponents;\n\njulia> R, (x, y) = polynomial_ring(GF(2), [\"x\", \"y\"]);\n\njulia> f = x*y^4 + x^2*y^4 + 1;\n\njulia> g = y + y^2 + x^4;\n\njulia> I = ideal(R, [f, g]);\n\njulia> G = groebner_basis(I, ordering=lex([x,y])) # Eq. 51\nGröbner basis with elements\n  1: y^20 + y^17 + 1\n  2: x + y^16 + y^13 + y^12 + y^9 + y^2 + y\nwith respect to the ordering\n  lex([x, y])\n\njulia> H = groebner_basis(I, ordering=lex([y,x])) # Eq. 54\nGröbner basis with elements\n  1: x^20 + x^18 + x^2 + x + 1\n  2: y + x^18 + x^17 + x^8 + x^4 + 1\nwith respect to the ordering\n  lex([y, x])\n\njulia> a, b = max_xy_exponents(G);\n\njulia> all_monomials = [x^i * y^j for i in 0:a-1 for j in 0:b-1] # Eq. 52\n20-element Vector{FqMPolyRingElem}:\n 1\n y\n y^2\n y^3\n y^4\n y^5\n y^6\n y^7\n y^8\n y^9\n y^10\n y^11\n y^12\n y^13\n y^14\n y^15\n y^16\n y^17\n y^18\n y^19\n\njulia> k_max = 2*length(all_monomials)\n40\n\nParity Checks\n\nThe total number of physical qubits is n = 2*alphabeta, corresponding to horizontal and vertical edges in each unit cell. The parity-check matrices H_X and H_Z are constructed following approach in Appendix B of (Liang et al., 2025). Qubits are indexed row-by-row: for each y-coordinate, horizontal edges are listed first, then vertical edges. Stabilizers are generated by translating the origin stabilizer, defined by the monomial supports of f and g, across all (l_x l_y) in 0  l_x  beta, 0  l_y  alpha. Translations obey twisted boundary conditions determined by (alpha beta gamma), ensuring the matrices retain a generalized cyclic structure.\n\nThe notable cases of Generalized toric codes include:\n\nKitaev Toric Code\n\nThe Kitaev Toric code is defined by the Laurent polynomials f(x y) = 1 + x and g(x y) = 1 + y. The only independent monomial is 1, as all other monomials x^a y^b can be expressed as:  \n\nbeginaligned\n    x^a y^b = a_1 + p(x y)f(x y) + q(x y)g(x y)\nendaligned\n\nwhere a_1 in mathbbZ_2 and p(x y) q(x y) in R. For instance: x^2 = 1 + (1 + x)(1 + x). \n\nExample\n\njulia> using Oscar; using QuantumClifford; using QuantumClifford.ECC;\n\njulia> R, (x,y) = laurent_polynomial_ring(GF(2), [:x, :y]);\n\njulia> f = 1 + x;\n\njulia> g = 1 + y;\n\njulia> α1 = (0, 6);\n\njulia> α2 = (3, 3);\n\njulia> c = GeneralizedToricCode(f, g, α1, α2);\n\njulia> code_n(c), code_k(c)\n(36, 2)\n\nColor Code\n\nThe Color code is defined by the Laurent polynomials f(x y) = 1 + x + xy and g(x y) = 1 + y + xy. The independent monomials are 1 and x. Other monomials follow:\n\nbeginaligned\n    x^a y^b = a_1 + a_x x + p(x y)f(x y) + q(x y)g(x y)\nendaligned\n\nThe code has k_textmax = 4, reflecting its structure as a direct sum of two Kitaev codes.  \n\nnote: Note\nFor simple polynomials, independent monomials can be identified manually. However, a systematic approach using Gröbner basis is necessary for general cases.  \n\nExample\n\njulia> using Oscar; using QuantumClifford; using QuantumClifford.ECC;\n\njulia> R, (x, y) = laurent_polynomial_ring(GF(2), [:x, :y]);\n\njulia> f = 1 + x + x*y;\n\njulia> g = 1 + y + x*y;\n\njulia> α1 = (0, 6);\n\njulia> α2 = (3, 3);\n\njulia> c = GeneralizedToricCode(f, g, α1, α2);\n\njulia> code_n(c), code_k(c)\n(36, 4)\n\n(-1 3 3 -1)-Generalized Toric Code\n\nThe (-1 3 3 -1)-Generalized Toric code corresponds to stabilizers in the Gross code and (3 3)-BB code. The Laurent polynomials are:\n\nbeginaligned\n    f(x y) = 1 + x + x^-1y^3 quad g(x y) = 1 + y + x^3 y^-1  \nendaligned\n\nExample\n\njulia> using Oscar; using QuantumClifford; using QuantumClifford.ECC;\n\njulia> R, (x, y) = laurent_polynomial_ring(GF(2), [:x, :y]);\n\njulia> f = 1 + x + x^-1*y^3;\n\njulia> g = 1 + y + x^3*y^-1;\n\njulia> α1 = (0, 12);\n\njulia> α2 = (6, 0);\n\njulia> c = GeneralizedToricCode(f, g, α1, α2);\n\njulia> code_n(c), code_k(c)\n(144, 12)\n\n(-1 -3 3 -1)-Generalized Toric Code\n\nThe (-1 -3 3 -1)-Generalized Toric code corresponds to the (3, -3)-BB code. The Laurent polynomials are:\n\nbeginaligned \n    f(x y) = 1 + x + x^-1y^-3 quad g(x y) = 1 + y + x^3 y^-1  \nendaligned\n\nExample\n\njulia> using Oscar; using QuantumClifford; using QuantumClifford.ECC;\n\njulia> R, (x, y) = laurent_polynomial_ring(GF(2), [:x, :y]);\n\njulia> f = 1 + x + x^-1*y^-3;\n\njulia> g = 1 + y + x^3*y^-1;\n\njulia> α1 = (0, 12);\n\njulia> α2 = (6, 0);\n\njulia> c = GeneralizedToricCode(f, g, α1, α2);\n\njulia> code_n(c), code_k(c)\n(144, 12)\n\nExample from Tables I-IV of (Liang et al., 2025)\n\nHere is an example of [[396, 8, ≤ 26]] Generalized Toric Code from Table IV of (Liang et al., 2025).\n\njulia> using Oscar; using QuantumClifford; using QuantumClifford.ECC;\n\njulia> R, (x,y) = laurent_polynomial_ring(GF(2), [:x, :y]);\n\njulia> f = 1 + x + x^-1*y^-3;\n\njulia> g = 1 + y + x^3*y^-1;\n\njulia> α1 = (0, 66);\n\njulia> α2 = (3, 18);\n\njulia> c = GeneralizedToricCode(f, g, α1, α2);\n\njulia> code_n(c), code_k(c)\n(396, 8)\n\nHere is an example of [[292, 18, 8]] Generalized Toric Code from Appendix B of (Liang et al., 2025).\n\njulia> using Oscar; using QuantumClifford; using QuantumClifford.ECC;\n\njulia> R, (x,y) = laurent_polynomial_ring(GF(2), [:x, :y]);\n\njulia> f = 1 + x + y^2;\n\njulia> g = 1 + y + x^-4*y;\n\njulia> α1 = (0, 73);\n\njulia> α2 = (2, 32);\n\njulia> c = GeneralizedToricCode(f, g, α1, α2);\n\njulia> code_n(c), code_k(c)\n(292, 18)\n\nFields\n\nf::AbstractAlgebra.Generic.LaurentMPolyWrap: Laurent polynomial over mathbbF_2 defining horizontal–edge action of the X-type stabilizer\ng::AbstractAlgebra.Generic.LaurentMPolyWrap: Laurent polynomial over mathbbF_2 defining vertical–edge action of the X-type stabilizer\na1::Tuple{Int64, Int64}: First lattice vector mathbfa_1 = (p_1 q_1), from which (alpha beta gamma) can be computed so that a_1 = (0 alpha) represents the same generic twisted torus under a unimodular transformation.\na2::Tuple{Int64, Int64}: Second lattice vector mathbfa_2 = (p_2 q_2), from which (alpha beta gamma) can be computed so that a_2 = (beta gamma) represents the same generic twisted torus under a unimodular transformation.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QuantumCliffordOscarExt.HomologicalProductCode","page":"API","title":"QuantumCliffordOscarExt.HomologicalProductCode","text":"struct HomologicalProductCode{T<:AbstractAlgebra.MatElem} <: AbstractCSSCode\n\nConstructs a D-dimensional CSS quantum code (D ≥ 2) from D classical parity-check matrices via iterated homological products.\n\nSeveral interpretations of the homological product exist. For example, (Bravyi and Hastings, 2013) employ a simplified version known as the single-sector homological product. In contrast, the HomologicalProductCode adopts a more conventional definition, which (Bravyi and Hastings, 2013) would refer to as the multi-sector homological product.\n\nThe term \"homological product codes\" can broadly encompass various constructions involving the product of quantum codes ((Bravyi and Hastings, 2013), (Campbell, 2019)). However, HomologicalProductCode focuses specifically on a particular subset—namely, the product of classical codes, which can also be described as length-1 chain complexes (sometimes called high-dimensional hypergraph product codes (Zeng and Pryadko, 2019)).\n\nProduct Complex\n\nGiven D chain complexes mathcalB^i_iinD, where mathcalB^i = B^i_x_i_x_i partial^i_x_i_x_i, the D-dimensional product complex is defined as:\n\nbeginaligned\nmathcalD = D_vecx_vecx=(x_1dotsx_D)^T in mathbbZ^D partial^i_vecx D_vecx to D_vecx-vece_i_iinDvecxinmathbbZ^D = textProd(mathcalB^i_iinD)\nendaligned\n\nthe tensor product of these chain complexes, where:\n\nbeginaligned\nD_vecx = bigotimes_i=1^D B^i_x_i \npartial^i_vecx = bigotimes_j=1^D (partial^j_x_j)^delta_ij\nendaligned\n\nwhere delta_ij is the Kronecker delta function and (partial^j_x_j)^0 is defined as the identity map (Xu et al., 2024).\n\nA product complex is a high-dimensional generalization of the chain complex.\n\nTotal Complex\n\nThe mathcalD-product complex is constructed from D base chain complexes with vector spaces D_vecx_vecx and boundary maps partial^i_vecx_iinDvecx. It's total chain complex mathcalT = T_k_k delta_k_k = textTot(mathcalD) as follows:\n\nbeginaligned\nT_k = bigoplus_vecx=k D_vecx\nendaligned\n\nand the boundary maps:\n\nbeginaligned\ndelta_kleft(bigoplus_vecx=k a_vecxright) = sum_vecx=k left(bigoplus_vecy=k-1 partial_vecyvecx a_vecxright)\nendaligned\n\nfor any a_vecx in D_vecx, and\n\nbeginaligned\npartial_vecyvecx = \nbegincases \npartial^i_vecx  textif  vecx - vecy = vece_i text for some  i in D \n0  textotherwise\nendcases\nendaligned\n\nnote: Note\nThe total complex is obtained by projecting the D-dimensional complex along the \"diagonal\" direction. Once a total chain complex is derived from a product complex (with length greater than 2), a quantum code can be defined from a length-2  subcomplex (Xu et al., 2024).\n\n(Xu et al., 2024) focuses on product complexes with length-1 base complexes mathcalC^i_iinD (classical codes). In this case, the total complex mathcalT = textTot(textProd(mathcalC^i_iinD)) has length D:\n\nbeginaligned\nT_D xrightarrowdelta_D T_D-1 xrightarrowdelta_D-1 cdots xrightarrowdelta_1 T_0\nendaligned\n\n(Xu et al., 2024) considers dimensions D = 2 3 4.\n\nFor D = 2, the standard hypergraph product code is obtained, with planar surface codes as a special case (Xu et al., 2024).\nFor D = 3 and D = 4, the construction yields 3D and 4D homological product codes, with 3D surface/toric codes serving as specific instances (Xu et al., 2024).\n\nExamples\n\nHere is a 3D Homological product code from (Quintavalle et al., 2021).\n\njulia> using Oscar; using QuantumClifford; using QuantumClifford.ECC; using QECCore;\n\njulia> δ = matrix(GF(2), parity_matrix(RepCode(3)));\n\njulia> c = HomologicalProductCode([δ,δ,δ]);\n\njulia> import HiGHS; import JuMP;\n\njulia> code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n(81, 3, 3)\n\nHere is the [[117, 9, 4]] Homological product code construct from classical quasi-cyclic code from Table III of (Xu et al., 2024).\n\njulia> using Oscar; using QuantumClifford; using QuantumClifford.ECC; using QECCore;\n\njulia> R, x = polynomial_ring(GF(2), \"x\");\n\njulia> l = 3;\n\njulia> H = matrix(R, 2, 3, [x^2 x^2 x^2;\n                            x   x^2  0]);\n\njulia> c = HomologicalProductCode([H,transpose(H)], l);\n\njulia> import HiGHS; import JuMP;\n\njulia> code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n(117, 9, 4)\n\nHere is a Homological product of (3,4)-classical LDPC codes.\n\njulia> using Oscar; using QuantumClifford; using QuantumClifford.ECC; using QECCore;\n\njulia> μ = 2; wc = 3; wr = 4;\n\njulia> c = GallagerLDPC(μ, wc, wr);\n\njulia> H = matrix(GF(2), parity_matrix(c));\n\njulia> c = HomologicalProductCode([H,transpose(H)]);\n\njulia> import HiGHS; import JuMP;\n\njulia> code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n(100, 20, 2)\n\nFields\n\nboundary_maps::Vector{T} where T<:AbstractAlgebra.MatElem: A length-D vector of parity-check matrices of classical error-correcting codes.\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QuantumCliffordOscarExt.TrivariateTricycleCode","page":"API","title":"QuantumCliffordOscarExt.TrivariateTricycleCode","text":"struct TrivariateTricycleCode <: AbstractCSSCode\n\nA quantum CSS code constructed from three trivariate polynomials over a finite field from (Jacob et al., 2025).\n\n(Jacob et al., 2025) first define arbitrary 3-block group algebra codes (for an abelian group G. The group algebra mathbbF_2G consists of formal sums of the form sum_g in G a_g g, with a_g in mathbbF_2.\n\nFor a 3-block code, we consider the three length-1 chain complexes:\n\nbeginaligned\nA_1 xrightarrowquad a quad A_0 quad\nB_1 xrightarrowquad b quad B_0 quad\nC_1 xrightarrowquad c quad C_0\nendaligned\n\nwhere A_i B_i C_i = mathbbF_2G and the boundary maps a b c in mathbbF_2G.\n\nThe tensor (balanced) product complex is formed from these three complexes using the isomorphism mathbbF_2G otimes_G mathbbF_2G simeq mathbbF_2G which is used to simplify the general definition. The resulting tensor product complex is:\n\nbeginaligned\nA_1 otimes_G B_1 otimes_G C_1\nxrightarrowquad partial_3 quad\nbigoplus_i+j+k=2 A_i otimes_G B_j otimes_G C_k\nxrightarrowquad partial_2 quad\nbigoplus_i+j+k=1 A_i otimes_G B_j otimes_G C_k\nxrightarrowquad partial_1 quad A_0 otimes_G B_0 otimes_G C_0\nendaligned\n\nThe boundary maps can be written explicitly in terms of a, b, and c as:\n\nbeginaligned\npartial_3 = beginbmatrix a  b  c endbmatrix \npartial_2 = beginbmatrix\n0  c  b \nc  0  a \nb  a  0\nendbmatrix \npartial_1 = beginbmatrix a  b  c endbmatrix\nendaligned\n\nThe trivariate tricycle codes from this complex by considering G = Z_ell times Z_m times Z_p for integers ell, m, and p. The following matrices which generate this group:\n\nbeginaligned\nx = S_ell otimes I_m otimes I_p \ny = I_ell otimes S_m otimes I_p \nz = I_ell otimes I_m otimes S_p\nendaligned\n\nwhere S_n is the n times n cyclic shift matrix with elements (S_n)_ij = delta_i j oplus 1 and oplus denotes addition modulo n.\n\nWe consider A, B, and C to be be polynomials in the non-commuting variables x, y, and z. An initial symmetric choice is:\n\nbeginaligned\nA = A_1 + A_2 + A_3 \nB = B_1 + B_2 + B_3 \nC = C_1 + C_2 + C_3\nendaligned\n\nthough this restriction can be relaxed (Jacob et al., 2025).\n\nWe then define the parity-check matrices for the CSS code as:\n\nbeginaligned\nH_X equiv partial_1 quad H_Z = partial_2^top quad M_Z = partial_3^top\nendaligned\n\nwhere H_X and H_Z are the X and Z stabilizer generators, and M_Z is a matrix of meta-checks encoding the redundancy in the Z checks. It can be verified that:\n\nbeginaligned\nH_XH_Z^top = 0 quad textand quad M_ZH_Z = 0\nendaligned\n\nThis results in the chain complex structure:\n\nbeginaligned\nC_M xleftarrowquad M_Z quad C_Z xleftarrowquad H_Z quad Q xrightarrowquad H_X quad C_X\nendaligned\n\nwhere the vector spaces over mathbbF_2G.\n\nThe matrices are given by:\n\nbeginaligned\nM_Z = beginbmatrix A^top  B^top  C^top endbmatrix \nH_Z = beginbmatrix\n0  C^top  B^top \nC^top  0  A^top \nB^top  A^top  0\nendbmatrix \nH_X = beginbmatrix A  B  C endbmatrix\nendaligned\n\nnote: Note\nWe leverage the isomorphism between the group algebra mathbbF_2mathbbZ_ell times mathbbZ_m times mathbbZ_p and the multivariate polynomial quotient ring fracmathbbF_2x y zlangle x^ell-1 y^m-1 z^p-1 rangle to introduce a novel realization of the Trivariate Tricycle codes of (Jacob et al., 2025).\n\nThe generalization of the TrivariateTricycleCode codes to an arbitrary number of groups (Λ ≥ 3) remains a conjecture; for details, see Section 5.3.2, Product of Λ ≥ 3 group algebra codes of (Breuckmann et al., 2024). The parity-check and metacheck matrices for the TrivariateTricycleCode codes—which are equivalent to the boundary maps of the underlying 3-term chain complex, see equation 2, 3, and 4 of (Jacob et al., 2025)—are constructed explicitly in (Breuckmann et al., 2024). These matrices serve as the fundamental building blocks and provide the key theoretical insight underlying this family of quantum codes.\n\nExamples\n\nHere is the [[72, 6, 6]] trivariate tricycle code from Table I from (Jacob et al., 2025).\n\njulia> using Oscar; using QuantumClifford.ECC;\n\njulia> l, m, p = 4, 3, 2;\n\njulia> R, (x, y, z) = polynomial_ring(GF(2), [:x, :y, :z]);\n\njulia> I = ideal(R, [x^l - 1, y^m - 1, z^p - 1]);\n\njulia> S, _ = quo(R, I);\n\njulia> A = S(1 + y + x*y^2);\n\njulia> B = S(1 + y*z + x^2*y^2);\n\njulia> C = S(1 + x*y^2*z + x^2*y);\n\njulia> c = TrivariateTricycleCode(l, m, p, A, B, C);\n\njulia> code_n(c), code_k(c)\n(72, 6)\n\nHere is the [[432, 12, 12]] trivariate tricycle code from Table I from (Jacob et al., 2025).\n\njulia> using Oscar; using QuantumClifford.ECC;\n\njulia> l, m, p = 6, 6, 4;\n\njulia> R, (x, y, z) = polynomial_ring(GF(2), [:x, :y, :z]);\n\njulia> I = ideal(R, [x^l - 1, y^m - 1, z^p - 1]);\n\njulia> S, _ = quo(R, I);\n\njulia> A = S(1 + x*y*z^3 + x^3*y^4*z^2);\n\njulia> B = S(1 + x^3*y*z^2 + x^3*y^2*z^3);\n\njulia> C = S(1 + x^4*y^3*z^3 + x^5*z^2);\n\njulia> c = TrivariateTricycleCode(l, m, p, A, B, C);\n\njulia> code_n(c), code_k(c)\n(432, 12)\n\nFields\n\nl::Int64: Order of the first abelian group in mathbbF_2mathbbZ_ell times mathbbZ_m times mathbbZ_p\nm::Int64: Order of the second abelian group in mathbbF_2mathbbZ_ell times mathbbZ_m times mathbbZ_p\np::Int64: Order of the third abelian group in mathbbF_2mathbbZ_ell times mathbbZ_m times mathbbZ_p\nA::Oscar.MPolyQuoRingElem{Nemo.FqMPolyRingElem}: First trivariate polynomial in quotient ring fracmathbbF_2x y zlangle x^ell-1 y^m-1 z^p-1 rangle\nB::Oscar.MPolyQuoRingElem{Nemo.FqMPolyRingElem}: Second trivariate polynomial in quotient ring fracmathbbF_2x y zlangle x^ell-1 y^m-1 z^p-1 rangle\nC::Oscar.MPolyQuoRingElem{Nemo.FqMPolyRingElem}: Third trivariate polynomial in quotient ring fracmathbbF_2x y zlangle x^ell-1 y^m-1 z^p-1 rangle\n\n\n\n\n\n","category":"type"},{"location":"ECC_API/#QuantumClifford.ECC.boundary_maps-Tuple{QuantumCliffordOscarExt.DDimensionalSurfaceCode}","page":"API","title":"QuantumClifford.ECC.boundary_maps","text":"Returns all boundary maps of the chain complex, including both parity check and metacheck matrices.\n\nHere are the boundary maps of [[12, 1, 2]] 3D Surface code with L = 2 from (Berthusen et al., 2024).\n\njulia> using Oscar; using QuantumClifford; using QECCore;\n\njulia> using QuantumClifford.ECC: DDimensionalSurfaceCode, boundary_maps, metacheck_matrix_z;\n\njulia> D = 3; L = 2;\n\njulia> c = DDimensionalSurfaceCode(D, L);\n\njulia> Mz, Hz, Hx = boundary_maps(c);\n\nThe parity check matrices of [[12, 1, 2]] 3D Surface code are\n\njulia> Hx\n4×12 Matrix{Int64}:\n 1  1  0  0  1  0  0  0  0  0  1  0\n 0  0  1  1  1  0  0  0  0  0  0  1\n 0  0  0  0  0  1  1  0  0  1  1  0\n 0  0  0  0  0  0  0  1  1  1  0  1\n\nnote: Note\nFor 3D and higher-dimensional codes, Oscar returns Z-type parity check matrix as transpose (H_Z^T). We transpose it to convert it back to H_Z. See B3, page 11 of (Berthusen et al., 2024).\n\njulia> Hz'\n9×12 adjoint(::Matrix{Int64}) with eltype Int64:\n 1  0  1  0  1  0  0  0  0  0  0  0\n 0  1  0  1  1  0  0  0  0  0  0  0\n 0  0  0  0  0  1  0  1  0  1  0  0\n 0  0  0  0  0  0  1  0  1  1  0  0\n 1  0  0  0  0  1  0  0  0  0  1  0\n 0  1  0  0  0  0  1  0  0  0  1  0\n 0  0  1  0  0  0  0  1  0  0  0  1\n 0  0  0  1  0  0  0  0  1  0  0  1\n 0  0  0  0  1  0  0  0  0  1  1  1\n\nAlong with the Z- and X-type parity check matrices, we have a metacheck matrix specifically for the Z-type checks. The classical code derived from this metacheck matrix has a distance of d = 2 meaning it can identify (but not correct) a single error in the Z-type syndrome measurements. See page 12 of (Berthusen et al., 2024) for details.\n\njulia> Mz'\n2×9 adjoint(::Matrix{Int64}) with eltype Int64:\n 1  0  1  0  1  0  1  0  1\n 0  1  0  1  0  1  0  1  1\n\nWe can use metacheck_matrix_z directly instead of using boundary_maps.\n\njulia> metacheck_matrix_z(c)\n2×9 Matrix{Int64}:\n 1  0  1  0  1  0  1  0  1\n 0  1  0  1  0  1  0  1  1\n\nMetachecks in CSS Codes\n\nThe parity-check matrices M_Z and M_X are called metachecks in CSS codes. These matrices emerge from the constraints imposed by boundary maps, which satisfy the condition partial_i+1 partial_i = 0. This guarantees that:\n\nbeginaligned\nM_Z H_Z = 0 quad textand quad M_X H_X = 0\nendaligned\n\nmeaning that:\n\nValid Z-type syndromes must be in ker M_Z\nValid X-type syndromes must be in ker M_X\n\nWhen measurement errors occur, they distort the syndrome vector mathbfs, generating a detectable metasyndrome. By examining mathbfm, we can identify and correct errors in mathbfs before proceeding with standard decoding. This technique is called syndrome repair decoding (Higgott and Breuckmann, 2023).\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.twobga_from_direct_product-Tuple{Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}}, Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}}, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}","page":"API","title":"QuantumClifford.ECC.twobga_from_direct_product","text":"twobga_from_direct_product(\n    a_elts::Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}},\n    b_elts::Vector{Hecke.GroupAlgebraElem{Nemo.FqFieldElem, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}}},\n    F2G::Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.DirectProductGroup, Oscar.BasicGAPGroupElem{Oscar.DirectProductGroup}}\n) -> Any\n\n\nConstructing two block group algebra codes by specifying the direct product to be used. See also the more general two_block_group_algebra_codes.\n\nTwo block group algebra codes are constructed by choosing a group (and specific generators), then choosing two polynomials made out of these generators, then piping these two polynomials as the elements of 1×1 matrices to the lifted product code constructors.\n\nThe Hecke library, for which we already have an extension, provides for a fairly easy way to construct such polynomials for many abelian and small groups. See two_block_group_algebra_codes for those capabilities.\n\nHowever, more esoteric groups can be specified as the direct product of other groups. To support arbitrary direct products we use Oscar, which builds upon Hecke. Oscar supports the direct product operation between two or more arbitrary general groups, including non-abelian groups such as alternating_group, dihedral_group, symmetric_group, and even arbitrary finitely presented groups (e.g., free_group). This capability is not available in Hecke.jl. The 2BGA codes discovered in (Lin and Pryadko, 2024) rely on direct products of two or more general groups, which necessitate the use of Oscar.direct_product.\n\nThis particular function is nothing more than a simple wrapper that takes care of argument conversions. Of note, the polynomials here are given as lists of monomials.\n\nOf course, if you are comfortable with Oscar, you can use two_block_group_algebra_codes directly.\n\nSee also: two_block_group_algebra_codes, twobga_from_fp_group\n\nExamples\n\nThe [[56, 28, 2]] abelian 2BGA code from Appendix C, Table II in (Lin and Pryadko, 2024) can be constructed using the direct product of two cyclic groups. Specifically, the group C₂₈ of order l = 28 can be represented as C₁₄ × C₂, where the first group has order m = 14 and the second group has order n = 2.\n\njulia> import Oscar: cyclic_group, small_group_identification, describe, order\n\njulia> import Hecke: gens, quo, group_algebra, GF, one, direct_product, sub\n\njulia> using QuantumClifford, QuantumClifford.ECC\n\njulia> m = 14; n = 2;\n\njulia> C₁₄ = cyclic_group(m);\n\njulia> C₂ = cyclic_group(n);\n\njulia> G = direct_product(C₁₄, C₂);\n\njulia> GA = group_algebra(GF(2), G);\n\njulia> x, s = gens(GA)[1], gens(GA)[3];\n\njulia> a = [one(GA), x^7];\n\njulia> b = [one(GA), x^7, s, x^8, s * x^7, x];\n\njulia> c = twobga_from_direct_product(a, b, GA);\n\njulia> order(G)\n28\n\njulia> code_n(c), code_k(c)\n(56, 28)\n\njulia> describe(G), small_group_identification(G)\n(\"C14 x C2\", (28, 4))\n\ndanger: Danger\nWhen using the direct product, there isn't necessarily a unique set of generators. It is essential to verify that Oscar is providing you with the generators you expect, e.g. for a cycling group that you have the presentation Cₘ = ⟨x, s | xᵐ = s² = xsx⁻¹s⁻¹ = 1⟩. For situations where the generators provided by Oscar are not the ones you want, you can also use twobga_from_fp_group where you specify the group presentation directly.\n\nAs a verification that you have the correct generators, Oscar.sub can be used to determine if H is a subgroup of G and to confirm that both C₁₄ and C₂ are subgroups of C₂₈.\n\njulia> order(gens(G)[1])\n14\n\njulia> order(gens(G)[3])\n2\n\njulia> x^14 == s^2 == x * s * x^-1 * s^-1\ntrue\n\njulia> H, _  = sub(G, [gens(G)[1], gens(G)[3]]);\n\njulia> H == G\ntrue\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#QuantumClifford.ECC.twobga_from_fp_group-Tuple{Vector{Oscar.FPGroupElem}, Vector{Oscar.FPGroupElem}, Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.FPGroup, Oscar.FPGroupElem}}","page":"API","title":"QuantumClifford.ECC.twobga_from_fp_group","text":"twobga_from_fp_group(\n    a_elts::Vector{Oscar.FPGroupElem},\n    b_elts::Vector{Oscar.FPGroupElem},\n    F2G::Hecke.GroupAlgebra{Nemo.FqFieldElem, Oscar.FPGroup, Oscar.FPGroupElem}\n) -> Any\n\n\nConstructing two block group algebra codes by specifying the group presentation.\n\nTwo block group algebra codes are constructed by choosing a group (and specific generators), then choosing two polynomials made out of these generators, then piping these two polynomials as the elements of 1×1 matrices to the lifted product code constructors.\n\nThe Hecke library, for which we already have an extension, provides for a fairly easy way to construct such polynomials for many abelian and small groups. See two_block_group_algebra_codes for those capabilities.\n\nHowever, more esoteric groups are usually specified by a group presentation ⟨S | R⟩, where S is a set of generators and R is the relations those generators obey. To support arbitrary group presentations we use Oscar, which builds upon Hecke. We use Oscar.free_group and quo in order to first prepare the free group generated by S, and then the group obeying also the relations R, i.e. the ⟨S | R⟩ presentation.\n\nAfter that point we proceed as usual, creating two polynomials of generators and piping them to two_block_group_algebra_codes.\n\nThis particular function is nothing more than a simple wrapper that takes care of argument conversions. Of note, the polynomials here are given as lists of monomials.\n\nOf course, if you are comfortable with Oscar, you can use two_block_group_algebra_codes directly.\n\nSee also: two_block_group_algebra_codes, twobga_from_direct_product\n\nExamples\n\nThe [[96, 12, 10]] 2BGA code from Table I in (Lin and Pryadko, 2024) has the group presentation ⟨r, s | s⁶ = r⁸ = r⁻¹srs = 1⟩ (the group C₂ × (C₃ ⋉ C₈)).\n\njulia> import Oscar: free_group, small_group_identification, describe, order\n\njulia> import Hecke: gens, quo, group_algebra, GF, one\n\njulia> using QuantumClifford, QuantumClifford.ECC\n\njulia> F = free_group([\"r\", \"s\"]);\n\njulia> r, s = gens(F); # generators\n\njulia> G, = quo(F, [s^6, r^8, r^(-1) * s * r * s]);  # relations\n\njulia> GA = group_algebra(GF(2), G);\n\njulia> r, s = gens(G);\n\njulia> a = [one(G), r, s^3 * r^2, s^2 * r^3];\n\njulia> b = [one(G), r, s^4 * r^6, s^5 * r^3];\n\njulia> c = twobga_from_fp_group(a, b, GA);\n\njulia> order(G)\n48\n\njulia> code_n(c), code_k(c)\n(96, 12)\n\njulia> describe(G), small_group_identification(G)\n(\"C2 x (C3 : C8)\", (48, 9))\n\nCyclic Groups\n\nCyclic groups with specific group presentations, given by Cₘ = ⟨x, s | xᵐ = s² = xsx⁻¹s⁻¹ = 1⟩, where the order is 2m as seen in Table II of (Lin and Pryadko, 2024).\n\nThe [[56, 28, 2]] abelian 2BGA code from Appendix C, Table II in (Lin and Pryadko, 2024) is constructed using the group presentation ⟨x, s | xs = sx, xᵐ = s² = 1⟩ (the cyclic group C₂₈ = C₁₄ × C₂).\n\njulia> m = 14;\n\njulia> F = free_group([\"x\", \"s\"]);\n\njulia> x, s = gens(F); # generators\n\njulia> G, = quo(F, [x^m, s^2, x * s * x^-1 * s^-1]); # relations\n\njulia> GA = group_algebra(GF(2), G);\n\njulia> x, s = gens(G);\n\njulia> a = [one(G), x^7];\n\njulia> b = [one(G), x^7, s, x^8, s * x^7, x];\n\njulia> c = twobga_from_fp_group(a, b, GA);\n\njulia> order(G)\n28\n\njulia> code_n(c), code_k(c)\n(56, 28)\n\njulia> describe(G), small_group_identification(G)\n(\"C14 x C2\", (28, 4))\n\nDihedral Groups\n\nDihedral (non-abelian) groups with group presentations given by Dₘ = ⟨r, s | rᵐ = s² = (rs)² = 1⟩, where the order is 2m.\n\nThe [[24, 8, 3]] 2BGA code from Appendix C, Table III in (Lin and Pryadko, 2024) is constructed by specifying a group presentation below (giving the group D₆ = C₆ ⋉ C₂).\n\njulia> m = 6;\n\njulia> F = free_group([\"r\", \"s\"]);\n\njulia> r, s = gens(F); # generators\n\njulia> G, = quo(F, [r^m, s^2, (r*s)^2]); # relations\n\njulia> GA = group_algebra(GF(2), G);\n\njulia> r, s = gens(G);\n\njulia> a = [one(G), r^4];\n\njulia> b = [one(G), s*r^4, r^3, r^4, s*r^2, r];\n\njulia> c = twobga_from_fp_group(a, b, GA);\n\njulia> order(G)\n12\n\njulia> code_n(c), code_k(c)\n(24, 8)\n\njulia> describe(G), small_group_identification(G)\n(\"D12\", (12, 4))\n\nnote: Note\nNotice how in all of these construction we are specifying a group presentation. We are explicitly not picking a group by name and getting its \"canonical\" generators, as we do not a priori know whether Oscar would give us the generating set we need (generating sets are not unique).\n\n\n\n\n\n","category":"method"},{"location":"ECC_API/#Implemented-in-an-extension-requiring-JuMP.jl","page":"API","title":"Implemented in an extension requiring JuMP.jl","text":"","category":"section"},{"location":"ECC_API/#QECCore.distance-Tuple{AbstractECC, DistanceMIPAlgorithm}","page":"API","title":"QECCore.distance","text":"distance(\n    code::AbstractECC,\n    alg::DistanceMIPAlgorithm\n) -> Any\n\n\nCompute the distance of a code using mixed integer programming. See QuantumClifford.ECC.DistanceMIPAlgorithm for configuration options.\n\nSpecifically, it computes the minimum distance of a Calderbank-Shor-Steane code by solving two independent Mixed Integer Programs for X-type (d_X) and Z-type (d_Z) distances. The code distance is d = min(d_X d_Z).\n\nBackground on Minimum Distance\n\nFor classical codes, the minimum distance, which measures a code's error-correcting capability, is equivalent to its minimum weight. This can be computed by generating all possible codewords from combinations of the generator matrix rows, calculating their weights, and finding the smallest. While accurate, this method takes exponential time. Vardy (Vardy, 1997) demonstrated that computing the minimum distance is NP-hard, and the corresponding decision problem is NP-complete, making polynomial-time algorithms unlikely.\n\nFor quantum codes, classical intuition does not always apply. The minimum distance is given by the minimum weight of a non-trivial logical operator. This is generally unrelated to the minimum distance of the corresponding stabilizer code when viewed as a classical, additive code. White and Grassl (White and Grassl, 2006) proposed mapping quantum codes to higher-dimensional classical linear codes. This mapping allows the minimum distance of the quantum additive code to be inferred from that of the classical linear code but increases parameters from n to 3n and d to 2d, adding complexity. Furthermore, once a minimal weight vector is identified, it is essential to verify whether it belongs to the Pauli group 𝒫ₙ over n qubits (Sabo, 2022).\n\nnote: Note\nThe minimum distance problem for quantum codes is NP-hard, and this hardness extends to multiplicative and additive approximations, even when restricted to stabilizer or CSS codes, with the result established through a reduction from classical problems in the CWS framework using a 4-cycle free graph (Kapshikar and Kundu, 2023). Despite this, methods that improve on brute-force approaches are actively explored.\n\nFor a more in-depth background on minimum distance, see Chapter 3 of (Sabo, 2022).\n\nQuantum Error Correction and Code Distance\n\nThe foundation of quantum error correction lies in protecting logical quantum information from physical errors by encoding it across multiple qubits. A quantum code's performance is fundamentally characterized by its distance (d), which quantifies the code's ability to detect and correct errors. Practically, the distance represents the minimum number of physical qubit errors required to cause an undetectable logical error - one that corrupts encoded information while evading the code's error detection mechanisms.\n\nFundamentals of Quantum Code Distance\n\nThe distance d of a quantum error-correcting code represents its robustness against physical errors and is defined as (Ekert et al., undated):\n\nbeginaligned\nd = min_P in N(S)setminus S mathrmwt(P)\nendaligned\n\nwhere:\n\nN(S) denotes the normalizer of the stabilizer group S.\nmathrmwt(P) represents the weight of Pauli operator P.\nThe minimization is taken over all logical operators that are not stabilizers.\n\nThe distance reveals the essential property that it equals the smallest number of qubits that must be affected to produce a logical error undetectable by stabilizer measurements. The normalizer condition P in N(S) ensures the operator commutes with all stabilizers, while P notin S guarantees it performs a non-trivial logical operation (Ekert et al., undated).\n\nMixed Integer Programming\n\nWe compute the minimum code distance for CSS (Calderbank-Shor-Steane) codes by solving MIPs. \n\nThe distance is computed separately for X-type (d_X) and Z-type (d_Z) logical operators, then combined to give the true code distance: d = min(d_X d_Z).\n\nX-type and Z-type Distances\n\nThe X-type distance (d_X) and Z-type distance (d_Z) are defined as the minimum number of errors required to implement a non-trivial logical operator of the opposite type, subject to the following constraints: \n\nFor d_X (where U = X), the errors are Z-type (phase flips), and the constraints involve the X-stabilizer matrix mathbfH_X and X-logical operators mathbfL_X. The error vector is denoted as mathbfe_Z.\nFor d_Z (where U = Z), the errors are X-type (bit flips), with constraints given by the Z-stabilizer matrix mathbfH_Z and Z-logical operators mathbfL_Z, and the error vector is mathbfe_X.  \n\nbeginaligned\ntextMinimize quad  sum_i=1^n e_Vi quad text(Hamming weight of errors) \ntextSubject to quad  mathbfH_U cdot mathbfe_V equiv mathbf0 pmod2 quad text(Commutes with U-stabilizers) \n                       mathbfL_U cdot mathbfe_V equiv 1 pmod2 quad text(Anti-commutes with U-logical) \n                       e_Vi in 01 quad text(Binary error variables)\nendaligned\n\nExample\n\nA [[40, 8, 5]] 2BGA code with the minimum distance of 5 from Table 2 of (Lin and Pryadko, 2024).\n\njulia> import Hecke: group_algebra, GF, abelian_group, gens; import HiGHS; import JuMP;\n\njulia> using QuantumClifford, QuantumClifford.ECC\n\njulia> l = 10; m = 2;\n\njulia> GA = group_algebra(GF(2), abelian_group([l,m]));\n\njulia> x, s = gens(GA);\n\njulia> A = 1 + x^6;\n\njulia> B = 1 + x^5 + s + x^6 + x + s*x^2;\n\njulia> c = two_block_group_algebra_codes(A,B);\n\njulia> code_n(c), code_k(c), distance(c, DistanceMIPAlgorithm(solver=HiGHS))\n(40, 8, 5)\n\nA [[48, 6, 8]] GB code with the minimum distance of 8 from (A3) in Appendix B of (Panteleev and Kalachev, 2021).\n\njulia> l = 24;\n\njulia> c1 = generalized_bicycle_codes([0, 2, 8, 15], [0, 2, 12, 17], l);\n\njulia> code_n(c1), code_k(c1), distance(c1, DistanceMIPAlgorithm(solver=HiGHS))\n(48, 6, 8)\n\nApplications\n\nMixed-integer programming (MIP) is applied in quantum error correction, notably for decoding and minimum distance computation. Some applications are as follows:\n\nThe first usecase of the MIP approach was the code capacity Most Likely Error (MLE) decoder for color codes introduced in (Landahl et al., 2011).\nFor all quantum LDPC codes presented in (Panteleev and Kalachev, 2021), the lower and upper bounds on the minimum distance was obtained by reduction to a mixed integer linear program and using the GNU Linear Programming Kit ((Makhorin, 2008)).\nFor all the Bivariate Bicycle (BB) codes presented in (Bravyi et al., 2024), the code distance was calculated using the mixed integer programming approach.\n(Lacroix et al., 2024) developed a MLE decoder that finds the most likely chain of Pauli errors given the observed error syndrome by solving a mixed-integer program using HiGHS package ((Huangfu and Hall, 2018)).\n(Cain et al., 2025) formulate maximum-likelihood decoding as a mixed-integer program maximizing prod_j=1^M p_j^E_j(1-p_j)^1-E_j (where binary variables E_j in 01 indicate error occurrence) subject to syndrome constraints, solved optimally via MIP solvers despite its NP-hard complexity.\n\n\n\n\n\n","category":"method"},{"location":"allops/#all-operations","page":"All Gates","title":"Operations - Gates, Measurements, and More","text":"","category":"section"},{"location":"allops/#Operations","page":"All Gates","title":"Operations","text":"","category":"section"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"Acting on quantum states can be performed either:","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"In a \"linear algebra\" language where unitaries, measurements, and other operations have separate interfaces. This is an explicitly deterministic lower-level interface, which provides a great deal of control over how tableaux are manipulated. See the Stabilizer Tableau Algebra Manual as a primer on these approaches.\nOr in a \"circuit\" language, where the operators (and measurements and noise) are represented as circuit gates. This is a higher-level interface in which the outcome of an operation can be stochastic. The API for it is centered around the apply! function. Particularly useful for Monte Carlo simulations and Perturbative Expansion Symbolic Results.","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"In the circuit language, all operations can be applied on a state with the apply! function. Whether they are deterministic and their computational complexity is listed in the table below. A list of lower-level \"linear algebra style\" functions for more control over how an operation is performed is also given.","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"<style>\ntd > code {\n    white-space: pre;\n}\n.content table td, .content table th {\n\tpadding: 0 1em;\n}\n</style>","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"Type Deterministic 𝒪(nˣ) Low-level functions\nAbstractOperation   \n├─ AbstractCliffordOperator   \n│   ├─ AbstractSymbolicOperator   \n│   │   ├─ AbstractSingleQubitOperator   \n│   │   │   ├─ SingleQubitOperator ✔️ n \n│   │   │   ├─ sHadamard ✔️ n \n│   │   │   ├─ sId1 ✔️ n \n│   │   │   ├─ sInvPhase ✔️ n \n│   │   │   ├─ sPhase ✔️ n \n│   │   │   ├─ sX ✔️ n \n│   │   │   ├─ sY ✔️ n \n│   │   │   └─ sZ ✔️ n \n│   │   └─ AbstractTwoQubitOperator   \n│   │       ├─ sCNOT ✔️ n \n│   │       ├─ sCPHASE ✔️ n \n│   │       └─ sSWAP ✔️ n \n│   │   \n│   ├─ CliffordOperator ✔️ n³ \n│   ├─ PauliOperator ✔️ n² \n│   └─ SparseGate ✔️ kn² \n├─ AbstractMeasurement   \n│   ├─ PauliMeasurement ❌ n² project!, projectrand!\n│   ├─ sMX ❌ n² projectX!\n│   ├─ sMY ❌ n² projectY!\n│   └─ sMZ ❌ n² projectZ!\n│   \n├─ AbstractResetMeasurement   \n│   ├─ sMRX ❌ n² projectX!\n│   ├─ sMRY ❌ n² projectY!\n│   └─ sMRZ ❌ n² projectZ!\n│   \n├─ BellMeasurement ❌ n² \n├─ NoiseOp ❌ ? applynoise!\n├─ NoiseOpAll ❌ ? applynoise!\n├─ NoisyGate ❌ ? applynoise!\n└─ Reset ✔️ kn² reset_qubits!","category":"page"},{"location":"allops/#Details-of-Operations-Supported-by-[apply!](@ref)","page":"All Gates","title":"Details of Operations Supported by apply!","text":"","category":"section"},{"location":"allops/#Unitary-Gates","page":"All Gates","title":"Unitary Gates","text":"","category":"section"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"We distinguish between symbolic gates like sCNOT that have specialized (fast) apply! methods (usually just for single and two qubit gates) and general tableau representation of gates like CliffordOperator that can represent any multi-qubit gate.","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"Predefined unitary gates are available, like sCNOT, sHadamard, etc.","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"using QuantumClifford # hide\nusing QuantumClifford.Experimental.NoisyCircuits # hide\nusing Quantikz # hide\n[sCNOT(2,4),sHadamard(2),sCPHASE(1,3),sSWAP(2,4)]","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"Any arbitrary tableaux can be used as a gate too. ","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"They can be specified by giving a Clifford operator tableaux and the indices on which it acts (particularly useful for gates acting on a small part of a circuit):","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"using QuantumClifford # hide\nusing QuantumClifford.Experimental.NoisyCircuits # hide\nusing Quantikz # hide\nSparseGate(tCNOT, [2,4])","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"The Clifford operator tableaux can be completely arbitrary.","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"SparseGate(random_clifford(3), [2,4,5])","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"If the Clifford operator acts on all qubits, we do not need to specify indices, just use the operator.","category":"page"},{"location":"allops/#Noisy-Gates","page":"All Gates","title":"Noisy Gates","text":"","category":"section"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"Each gate can be followed by noise applied to the qubits on which it has acted. This is done by wrapping the given gate into a NoisyGate","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"ε = 0.03 # X/Y/Z error probability\nnoise = UnbiasedUncorrelatedNoise(ε)\nnoisy_gate = NoisyGate(SparseGate(tCNOT, [2,4]), noise)","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"In circuit diagrams the noise is not depicted, but after each application of the gate defined in noisy_gate, a noise operator will also be applied. The example above is of Pauli Depolarization implemented by UnbiasedUncorrelatedNoise.","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"One can also apply only the noise operator by using NoiseOp which acts only on specified qubits. Or alternatively, one can use NoiseOpAll in order to apply noise to all qubits.","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"[NoiseOp(noise, [4,5]), NoiseOpAll(noise)]","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"The machinery behind noise processes and different types of noise is detailed in the section on noise","category":"page"},{"location":"allops/#Coincidence-Measurements","page":"All Gates","title":"Coincidence Measurements","text":"","category":"section"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"Global parity measurements involving single-qubit projections and classical communication are implemented with BellMeasurement. One needs to specify the axes of measurement and the qubits being measured. If the parity is trivial, the circuit continues, if the parity is non-trivial, the circuit ends and reports a detected failure. This operator is frequently used in the simulation of entanglement purification.","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"BellMeasurement([sMX(1), sMY(3), sMZ(4)])","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"There is also NoisyBellMeasurement that takes the bit-flip probability of a single-qubit measurement as a third argument.","category":"page"},{"location":"allops/#Stabilizer-Measurements","page":"All Gates","title":"Stabilizer Measurements","text":"","category":"section"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"A measurement over one or more qubits can also be performed, e.g., a direct stabilizer measurement on multiple qubits without the use of ancillary qubits. When applied to multiple qubits, this differs from BellMeasurement as it performs a single projection, unlike BellMeasurement which performs a separate projection for every single qubit involved. This measurement is implemented in PauliMeasurement which requires a Pauli operator on which to project and the index of the classical bit in which to store the result. Alternatively, there are sMX, sMZ, sMY if you are measuring a single qubit.","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"[PauliMeasurement(P\"XYZ\", 1), sMZ(2, 2)]","category":"page"},{"location":"allops/#Reset-Operations","page":"All Gates","title":"Reset Operations","text":"","category":"section"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"The Reset operations lets you trace out the specified qubits and set their state to a specific tableau.","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"new_state = random_stabilizer(3)\nqubit_indices = [1,2,3]\nReset(new_state, qubit_indices)","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"It can be done anywhere in a circuit, not just at the beginning.","category":"page"},{"location":"noisycircuits/#Simulation-of-Noisy-Clifford-Circuits","page":"Simulation of Noisy Circuits","title":"Simulation of Noisy Clifford Circuits","text":"","category":"section"},{"location":"noisycircuits/","page":"Simulation of Noisy Circuits","title":"Simulation of Noisy Circuits","text":"warning: Unstable\nThis is unfinished experimental functionality that will change significantly.","category":"page"},{"location":"noisycircuits/","page":"Simulation of Noisy Circuits","title":"Simulation of Noisy Circuits","text":"We have experimental support for simulation of noisy Clifford circuits which can be imported with using QuantumClifford.Experimental.NoisyCircuits.","category":"page"},{"location":"noisycircuits/","page":"Simulation of Noisy Circuits","title":"Simulation of Noisy Circuits","text":"Both Monte Carlo and Perturbative Expansion approaches are supported. When performing a perturbative expansion in the noise parameter, the expansion can optionally be performed symbolically, to arbitrary high orders.","category":"page"},{"location":"noisycircuits/","page":"Simulation of Noisy Circuits","title":"Simulation of Noisy Circuits","text":"Multiple notebooks with examples are also available. For instance, see this tutorial on entanglement purification for many examples.","category":"page"},{"location":"ECC_evaluating/#ecc_evaluating","page":"Evaluating codes and decoders","title":"Evaluating an ECC code and decoders","text":"","category":"section"},{"location":"ECC_evaluating/","page":"Evaluating codes and decoders","title":"Evaluating codes and decoders","text":"warning: The documentation is incomplete\nWhile waiting for a better documentation than the small example below, consider looking into evaluate_decoder, TableDecoder, BeliefPropDecoder, PyBeliefPropDecoder, PyMatchingDecoder, CommutationCheckECCSetup, NaiveSyndromeECCSetup, ShorSyndromeECCSetup","category":"page"},{"location":"ECC_evaluating/","page":"Evaluating codes and decoders","title":"Evaluating codes and decoders","text":"This is a quick and durty example on how to use some of the decoders.","category":"page"},{"location":"ECC_evaluating/","page":"Evaluating codes and decoders","title":"Evaluating codes and decoders","text":"A function to plot the results of ","category":"page"},{"location":"ECC_evaluating/","page":"Evaluating codes and decoders","title":"Evaluating codes and decoders","text":"using CairoMakie\n\nfunction make_decoder_figure(phys_errors, results, title=\"\")\n    minlim = min(minimum(phys_errors),minimum(results[results.!=0]))\n    maxlim = min(1, max(maximum(phys_errors),maximum(results[results.!=0])))\n\n    fresults = copy(results)\n    fresults[results.==0] .= NaN\n\n    f = Figure()\n    a = Axis(f[1,1],\n        xscale=log10, yscale=log10,\n        limits=(minlim,maxlim,minlim,maxlim),\n        aspect=DataAspect(),\n        xlabel=\"physical error rate\",\n        ylabel=\"logical error rate\",\n        title=title)\n    lines!(a, [minlim,maxlim],[minlim,maxlim], color=:black)\n    for (i,sresults) in enumerate(eachslice(fresults, dims=1))\n        scatter!(a, phys_errors, sresults[:,1], marker=:+, color=Cycled(i))\n        scatter!(a, phys_errors, sresults[:,2], marker=:x, color=Cycled(i))\n    end\n    f\nend","category":"page"},{"location":"ECC_evaluating/","page":"Evaluating codes and decoders","title":"Evaluating codes and decoders","text":"Testing out a lookup table decoder on a small code.","category":"page"},{"location":"ECC_evaluating/","page":"Evaluating codes and decoders","title":"Evaluating codes and decoders","text":"using QuantumClifford\nusing QuantumClifford.ECC\n\nmem_errors = 0.001:0.0005:0.01\ncodes = [Shor9()]\nresults = zeros(length(codes), length(mem_errors), 2)\n\nfor (ic, c) in pairs(codes)\n    for (i,m) in pairs(mem_errors)\n        setup = CommutationCheckECCSetup(m)\n        decoder = TableDecoder(c)\n        r = evaluate_decoder(decoder, setup, 10000)\n        results[ic,i,:] .= r\n    end\nend\n\nmake_decoder_figure(mem_errors, results, \"Shor's code with a lookup table decoder\")","category":"page"},{"location":"ECC_evaluating/","page":"Evaluating codes and decoders","title":"Evaluating codes and decoders","text":"Testing out the toric code with a decoder provided by the python package pymatching (provided in julia by the meta package PyQDecoders.jl).","category":"page"},{"location":"ECC_evaluating/","page":"Evaluating codes and decoders","title":"Evaluating codes and decoders","text":"import PyQDecoders\n\nmem_errors = 0.001:0.005:0.1\ncodes = [Toric(4,4), Toric(6,6)]\nresults = zeros(length(codes), length(mem_errors), 2)\n\nfor (ic, c) in pairs(codes)\n    for (i,m) in pairs(mem_errors)\n        setup = ShorSyndromeECCSetup(m, 0)\n        decoder = PyMatchingDecoder(c)\n        r = evaluate_decoder(decoder, setup, 1000)\n        results[ic,i,:] .= r\n    end\nend\n\nmake_decoder_figure(mem_errors, results, \"Toric code with a MWPM decoder\")","category":"page"},{"location":"canonicalization/#Canonicalization-operations","page":"Canonicalization","title":"Canonicalization operations","text":"","category":"section"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"Different types of canonicalization operations are implemented. All of them are types of Gaussian elimination.","category":"page"},{"location":"canonicalization/#[canonicalize!](@ref)","page":"Canonicalization","title":"canonicalize!","text":"","category":"section"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"First do elimination on all X components and only then perform elimination on the Z components. Based on (Garcia et al., 2012). It is used in logdot for inner products of stabilizer states.","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"The final tableaux, if square should look like the following (Image: )","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"If the tableaux is shorter than a square, the diagonals might not reach all the way to the right.","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"using QuantumClifford, CairoMakie\nf=Figure()\nstabilizerplot_axis(f[1,1], canonicalize!(random_stabilizer(20,30)))\nf","category":"page"},{"location":"canonicalization/#[canonicalize_rref!](@ref)","page":"Canonicalization","title":"canonicalize_rref!","text":"","category":"section"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"Cycle between elimination on X and Z for each qubit. Particularly useful for tracing out qubits. Based on (Audenaert and Plenio, 2005). For convenience reasons, the canonicalization starts from the bottom row, and you can specify as a second argument which columns to be canonicalized (useful for tracing out arbitrary qubits, e.g., in traceout!).","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"The tableau canonicalization is done in recursive steps, each one of which results in something akin to one of these three options (Image: )","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"using QuantumClifford, CairoMakie\nf=Figure()\nstabilizerplot_axis(f[1,1], canonicalize_rref!(random_stabilizer(20,30),1:30)[1])\nf","category":"page"},{"location":"canonicalization/#[canonicalize_gott!](@ref)","page":"Canonicalization","title":"canonicalize_gott!","text":"","category":"section"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"First do elimination on all X components and only then perform elimination on the Z components, but without touching the qubits that were eliminated during the X pass. Unlike other canonicalization operations, qubit columns are reordered, providing for a straight diagonal in each block. Particularly useful as certain blocks of the new created matrix are related to logical operations of the corresponding code, e.g. computing the logical X and Z operators of a MixedDestabilizer. Based on (Gottesman, 1997).","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"A canonicalized tableau would look like the following (the right-most block does not exist for square tableaux). (Image: )","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"using QuantumClifford, CairoMakie\nf=Figure()\nstabilizerplot_axis(f[1,1], canonicalize_gott!(random_stabilizer(30))[1])\nf","category":"page"},{"location":"canonicalization/#[canonicalize_clip!](@ref)","page":"Canonicalization","title":"canonicalize_clip!","text":"","category":"section"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"Convert to the \"clipped\" gauge of a stabilizer state resulting in a \"river\" of non-identity operators around the diagonal.","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"using QuantumClifford, CairoMakie\nf=Figure()\nstabilizerplot_axis(f[1,1], canonicalize_clip!(random_stabilizer(30)))\nf","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"The properties of the clipped gauge are:","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"Each qubit is the left/right \"endpoint\" of exactly two stabilizer rows.\nFor the same qubit the two endpoints are always different Pauli operators.","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"This canonicalization is used to derive the bigram a stabilizer state, which is also related to entanglement entropy in the state.","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"Introduced in (Nahum et al., 2017), with a more detailed explanation of the algorithm in Appendix A of (Li et al., 2019).","category":"page"},{"location":"noisycircuits_mc/#noisycircuits_mc","page":"Monte Carlo","title":"Monte Carlo simulations of noisy Clifford circuits","text":"","category":"section"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"warning: Unstable\nThis is experimental functionality with an unstable API.","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"Import with using QuantumClifford.Experimental.NoisyCircuits.","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"This module enables the simulation of noisy Clifford circuits through a Monte Carlo method where the same circuit is evaluated multiple times with random errors interspersed through it as prescribed by a given error model.","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"Below is an example of a purification circuit. We first prepare the circuit we desire to use, including a noise model. Quantikz.jl is used to visualize the circuit.","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"using QuantumClifford # hide\nusing QuantumClifford.Experimental.NoisyCircuits # hide\nusing Quantikz # hide\ngood_bell_state = S\"XX\n                    ZZ\"\ninitial_state = MixedDestabilizer(good_bell_state⊗good_bell_state)\n\ng1 = sCNOT(1,3) # CNOT between qubit 1 and qubit 3 (both with Alice)\ng2 = sCNOT(2,4) # CNOT between qubit 2 and qubit 4 (both with Bob)\nm = BellMeasurement([sMX(3),sMX(4)]) # Bell measurement on qubit 3 and 4\nv = VerifyOp(good_bell_state,[1,2]) # Verify that qubit 1 and 2 indeed form a good Bell pair\nepsilon = 0.01 # The error rate\nn = NoiseOpAll(UnbiasedUncorrelatedNoise(epsilon))\n\n# This circuit performs a depolarization at rate `epsilon` to all qubits,\n# then bilater CNOT operations\n# then a Bell measurement\n# followed by checking whether the final result indeed corresponds to the correct Bell pair.\ncircuit = [n,g1,g2,m,v]","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"And we can run a Monte Carlo simulation of that circuit with mctrajectories.","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"mctrajectories(initial_state, circuit, trajectories=500)","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"For more examples, see the notebook comparing the Monte Carlo and Perturbative method or this tutorial on entanglement purification for many examples.","category":"page"},{"location":"noisycircuits_mc/#Interface-for-custom-operations","page":"Monte Carlo","title":"Interface for custom operations","text":"","category":"section"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"If you want to create a custom gate type (e.g. calling it Operation), you need to definite the following methods.","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"applywstatus!(s::T, g::Operation)::Tuple{T,Symbol} where T is a tableaux type like Stabilizer or a Register. The Symbol is the status of the operation. Predefined statuses are kept in the registered_statuses list, but you can add more. Be sure to expand this list if you want the trajectory simulators using your custom statuses to output all trajectories.","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"There is also applynoise! which is a convenient way to create a noise model that can then be plugged into the NoisyGate struct, letting you reuse the predefined perfect gates and measurements. However, you can also just make up your own noise operator simply by implementing applywstatus! for it.","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"You can also consult the list of implemented operators.","category":"page"},{"location":"commonstates/#Useful-States-and-Operators","page":"Useful States","title":"Useful States and Operators","text":"","category":"section"},{"location":"commonstates/#States","page":"Useful States","title":"States","text":"","category":"section"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"Stabilizer states can be represented with the Stabilizer, Destabilizer, MixedStabilizer, and MixedDestabilizer tableau data structures. You probably want to use MixedDestabilizer which supports the widest set of operations.","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"Moreover, a MixedDestabilizer can be stored inside a Register together with a set of classical bits in which measurement results can be written.","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"Below are convenience constructors for common types of states and operators, already implemented in this library.","category":"page"},{"location":"commonstates/#Pauli-Operators","page":"Useful States","title":"Pauli Operators","text":"","category":"section"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"Single qubit PauliOperator is implemented in [single_z] and [single_x].","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"julia> single_z(4,2)\n+ _Z__\n\njulia> single_x(4,3)\n+ __X_","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"All identity operators use zero.","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"julia> zero(PauliOperator, 3)\n+ ___\n\njulia> zero(P\"XYZXYZ\")\n+ ______","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"Random Pauli operators are implemented as well (with or without a random phase).","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"julia> using StableRNGs; rng = StableRNG(42);\n\njulia> random_pauli(rng, 4)\n+ ZYY_\n\njulia> random_pauli(rng, 4; nophase=false)\n- YZ_X","category":"page"},{"location":"commonstates/#Stabilizer-States","page":"Useful States","title":"Stabilizer States","text":"","category":"section"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"An all-identity stabilizer can be created with zero.","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"julia> zero(Stabilizer, 3)\n+ ___\n+ ___\n+ ___\n\njulia> zero(Stabilizer, 2, 3)\n+ ___\n+ ___\n\njulia> zero(S\"XIZ\n              YZX\")\n+ ___\n+ ___","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"Diagonal stabilizers in different bases are available as well, through one.","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"julia> one(Stabilizer, 3)\n+ Z__\n+ _Z_\n+ __Z\n\njulia> one(Stabilizer, 3; basis=:Y)\n+ Y__\n+ _Y_\n+ __Y\n\njulia> one(S\"XX\n             ZZ\")\n+ Z_\n+ _Z","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"A random stabilizer (or destabilizers or Clifford operators) can be created as well. We use the algorithm described in (Bravyi and Maslov, 2021).","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"julia> random_stabilizer(rng, 2,5)\n+ YZXZZ\n- XZYYY","category":"page"},{"location":"commonstates/#Mixed-States","page":"Useful States","title":"Mixed States","text":"","category":"section"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"Similarly, one can create a diagonal mixed state.","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"julia> one(MixedDestabilizer, 2, 3)\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ X__\n+ _X_\n𝒳ₗ━━━\n+ __X\n𝒮𝓉𝒶𝒷━\n+ Z__\n+ _Z_\n𝒵ₗ━━━\n+ __Z","category":"page"},{"location":"commonstates/#Enumerating-all-Clifford-Operations","page":"Useful States","title":"Enumerating all Clifford Operations","text":"","category":"section"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"The algorithm from (Koenig and Smolin, 2014) can be used to enumerate all Clifford operations on a given number of qubits through enumerate_cliffords. Or one can use random_clifford, random_stabilizer to directly sample from that set.","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"julia> length(enumerate_cliffords(1))\n6\n\njulia> length(enumerate_cliffords(2))\n720","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"To also enumerate possible phases, you can use enumerate_phases.","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"julia> length(collect(enumerate_phases(tCNOT)))\n16\n\njulia> length(collect(enumerate_phases(enumerate_cliffords(2))))\n11520","category":"page"},{"location":"commonstates/#Common-entangled-states","page":"Useful States","title":"Common entangled states","text":"","category":"section"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"Bell states and GHZ states have convenience constructors:","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"julia> bell()\n+ XX\n+ ZZ\n\njulia> bell(2)\n+ XX__\n+ ZZ__\n+ __XX\n+ __ZZ\n\njulia> ghz(4)\n+ XXXX\n+ ZZ__\n+ _ZZ_\n+ __ZZ","category":"page"},{"location":"API/#Full-API","page":"API","title":"Full API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API/#States","page":"API","title":"States","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Stabilizer states can be represented with the Stabilizer, Destabilizer, MixedStabilizer, and MixedDestabilizer tableau data structures. You probably want to use MixedDestabilizer which supports the widest set of operations.","category":"page"},{"location":"API/","page":"API","title":"API","text":"Moreover, a MixedDestabilizer can be stored inside a Register together with a set of classical bits in which measurement results can be written.","category":"page"},{"location":"API/","page":"API","title":"API","text":"Lastly, for Pauli frame simulations there is the PauliFrame type, a tableau in which each row represents a different Pauli frame.","category":"page"},{"location":"API/","page":"API","title":"API","text":"There are convenience constructors for common types of states and operators.","category":"page"},{"location":"API/#Operations","page":"API","title":"Operations","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Acting on quantum states can be performed either:","category":"page"},{"location":"API/","page":"API","title":"API","text":"In a \"linear algebra\" language where unitaries, measurements, and other operations have separate interfaces. This is an explicitly deterministic lower-level interface, which provides a great deal of control over how tableaux are manipulated. See the Stabilizer Tableau Algebra Manual as a primer on these approaches.\nOr in a \"circuit\" language, where the operators (and measurements and noise) are represented as circuit gates. This is a higher-level interface in which the outcome of an operation can be stochastic. The API for it is centered around the apply! function. Particularly useful for Monte Carlo simulations and Perturbative Expansion Symbolic Results.","category":"page"},{"location":"API/","page":"API","title":"API","text":"See the full list of operations for a list of implemented operations.","category":"page"},{"location":"API/#Autogenerated-API-list","page":"API","title":"Autogenerated API list","text":"","category":"section"},{"location":"API/#QuantumClifford.QuantumClifford","page":"API","title":"QuantumClifford.QuantumClifford","text":"A module for using the Stabilizer formalism and simulating Clifford circuits.\n\n\n\n\n\n","category":"module"},{"location":"API/#QuantumClifford.continue_stat","page":"API","title":"QuantumClifford.continue_stat","text":"Returned by applywstatus! if the circuit simulation should continue.\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumClifford.failure_stat","page":"API","title":"QuantumClifford.failure_stat","text":"Returned by applywstatus! if the circuit reports a failure.\n\nSee also: VerifyOp, BellMeasurement.\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumClifford.false_success_stat","page":"API","title":"QuantumClifford.false_success_stat","text":"Returned by applywstatus! if the circuit reports a success, but it is a false positive (i.e., there was an undetected error).\n\nSee also: VerifyOp, BellMeasurement.\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumClifford.true_success_stat","page":"API","title":"QuantumClifford.true_success_stat","text":"Returned by applywstatus! if the circuit reports a success and there is no undetected error.\n\nSee also: VerifyOp, BellMeasurement.\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumClifford.AbstractSingleQubitOperator","page":"API","title":"QuantumClifford.AbstractSingleQubitOperator","text":"Supertype of all single-qubit symbolic operators.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.AbstractSymbolicOperator","page":"API","title":"QuantumClifford.AbstractSymbolicOperator","text":"Supertype of all symbolic operators. Subtype of AbstractCliffordOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.AbstractTwoQubitOperator","page":"API","title":"QuantumClifford.AbstractTwoQubitOperator","text":"Supertype of all two-qubit symbolic operators.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.BellMeasurement","page":"API","title":"QuantumClifford.BellMeasurement","text":"A Bell measurement performing the correlation measurement corresponding to the given pauli projections on the qubits at the selected indices.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.CircuitStatus","page":"API","title":"QuantumClifford.CircuitStatus","text":"A convenience struct to represent the status of a circuit simulated by mctrajectories\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.ClassicalXOR","page":"API","title":"QuantumClifford.ClassicalXOR","text":"Applies an XOR gate to classical bits. Currently only implemented for functionality with pauli frames.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.CliffordOperator","page":"API","title":"QuantumClifford.CliffordOperator","text":"Clifford Operator specified by the mapping of the basis generators.\n\njulia> tCNOT\nX₁ ⟼ + XX\nX₂ ⟼ + _X\nZ₁ ⟼ + Z_\nZ₂ ⟼ + ZZ\n\njulia> phase_gate = C\"Y\n                      Z\"\nX₁ ⟼ + Y\nZ₁ ⟼ + Z\n\njulia> stab = S\"XI\n                IZ\";\n\n\njulia> entangled = tCNOT*stab\n+ XX\n+ ZZ\n\njulia> CliffordOperator(T\"YY\")\nERROR: DimensionMismatch: Input tableau should be of size 2n×n (top half is the X mappings and the bottom half are the Z mappings).\n[...]\n\nDestabilizer can also be converted.\n\njulia> d = Destabilizer(S\"Y\")\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ X\n𝒮𝓉𝒶𝒷\n+ Y\n\njulia> CliffordOperator(d)\nX₁ ⟼ + X\nZ₁ ⟼ + Y\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.Destabilizer","page":"API","title":"QuantumClifford.Destabilizer","text":"A tableau representation of a pure stabilizer state. The tableau tracks the destabilizers as well, for efficient projections.\n\nFor full-rank tableaux, the stabilizer part of the tableau is guaranteed to be kept the same as the input stabilizer tableau given to the constructor (a guarantee not kept by MixedDestabilizer).\n\nOn initialization there are no checks that the provided state is indeed pure. This enables the use of this data structure for mixed stabilizer state, but usually a better choice would be MixedDestabilizer.\n\njulia> Destabilizer(S\"ZZI XXX\")\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z__\n+ _X_\n𝒮𝓉𝒶𝒷━\n+ XXX\n+ ZZ_\n\njulia> Destabilizer(S\"ZZI XXX IZZ\")\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ X__\n+ _Z_\n+ __X\n𝒮𝓉𝒶𝒷━\n+ ZZ_\n+ XXX\n+ _ZZ\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.GeneralizedStabilizer","page":"API","title":"QuantumClifford.GeneralizedStabilizer","text":"mutable struct GeneralizedStabilizer{T, F} <: QuantumClifford.AbstractQCState\n\nRepresents mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is a pure stabilizer state.\n\njulia> GeneralizedStabilizer(S\"-X\")\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n- X\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 1.0+0.0im | + _ | + _\n\njulia> pcT\nA unitary Pauli channel P = ∑ ϕᵢ Pᵢ with the following branches:\nwith ϕᵢ | Pᵢ\n 0.853553+0.353553im | + _\n 0.146447-0.353553im | + Z\n\njulia> apply!(GeneralizedStabilizer(S\"-X\"), pcT)\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n- X\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 0.0+0.353553im | + _ | + Z\n 0.0-0.353553im | + Z | + _\n 0.853553+0.0im | + _ | + _\n 0.146447+0.0im | + Z | + Z\n\nSee also: PauliChannel\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.MixedDestabilizer","page":"API","title":"QuantumClifford.MixedDestabilizer","text":"A tableau representation for mixed stabilizer states that keeps track of the destabilizers in order to provide efficient projection operations.\n\nThe rank r of the n-qubit tableau is tracked, either so that it can be used to represent a mixed stabilizer state, or so that it can be used to represent an n-r logical-qubit code over n physical qubits. The \"logical\" operators are tracked as well.\n\nWhen the constructor is called on an incomplete Stabilizer it automatically calculates the destabilizers and logical operators, following chapter 4 of (Gottesman, 1997). Under the hood the conversion uses the canonicalize_gott! canonicalization. That canonicalization permutes the columns of the tableau, but we automatically undo the column permutation in the preparation of a MixedDestabilizer so that qubits are not reindexed. The boolean keyword arguments undoperm and reportperm can be used to control this behavior and to report the permutations explicitly.\n\nSee also: stabilizerview, destabilizerview, logicalxview, logicalzview\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.MixedStabilizer","page":"API","title":"QuantumClifford.MixedStabilizer","text":"A slight improvement of the Stabilizer data structure that enables more naturally and completely the treatment of mixed states, in particular when the project! function is used.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.NoiseOp","page":"API","title":"QuantumClifford.NoiseOp","text":"An operator that applies the given noise model to the qubits at the selected indices.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.NoiseOpAll","page":"API","title":"QuantumClifford.NoiseOpAll","text":"An operator that applies the given noise model to all qubits.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.NoisyGate","page":"API","title":"QuantumClifford.NoisyGate","text":"A gate consisting of the given noise applied after the given perfect Clifford gate.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.PauliChannel","page":"API","title":"QuantumClifford.PauliChannel","text":"A Pauli channel datastructure, mainly for use with GeneralizedStabilizer\n\nSee also: UnitaryPauliChannel\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.PauliFrame","page":"API","title":"QuantumClifford.PauliFrame","text":"struct PauliFrame{T, S} <: QuantumClifford.AbstractQCState\n\nThis is a wrapper around a tableau. This \"frame\" tableau is not to be viewed as a normal stabilizer tableau, although it does conjugate the same under Clifford operations. Each row in the tableau refers to a single frame. The row represents the Pauli operation by which the frame and the reference differ.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.PauliFrame-Tuple{Any, Any, Any}","page":"API","title":"QuantumClifford.PauliFrame","text":"PauliFrame(\n    frames,\n    qubits,\n    measurements\n) -> PauliFrame{T} where T<:(Stabilizer{T} where T<:(QuantumClifford.Tableau{P, LinearAlgebra.Adjoint{UInt64, Matrix{UInt64}}} where P<:(AbstractVector{<:Unsigned})))\n\n\nPrepare an empty set of Pauli frames with the given number of frames and qubits. Preallocates spaces for measurement number of measurements.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.PauliMeasurement","page":"API","title":"QuantumClifford.PauliMeasurement","text":"A Stabilizer measurement on the entirety of the quantum register.\n\nprojectrand!(state, pauli) and apply!(state, PauliMeasurement(pauli)) give the same (possibly non-deterministic) result. Particularly useful when acting on Register.\n\nSee also: apply!, projectrand!.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.PauliNoise","page":"API","title":"QuantumClifford.PauliNoise","text":"Pauli noise model with probabilities px, py, and pz respectively for the three types of Pauli errors.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.PauliNoise-Tuple{Any}","page":"API","title":"QuantumClifford.PauliNoise","text":"Constructs an unbiased Pauli noise model with total probability of error p.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.PauliOperator","page":"API","title":"QuantumClifford.PauliOperator","text":"A multi-qubit Pauli operator (1iIZXY^otimes n).\n\nA Pauli can be constructed with the P custom string macro or by building up one through products and tensor products of smaller operators.\n\njulia> pauli3 = P\"-iXYZ\"\n-iXYZ\n\njulia> pauli4 = 1im * pauli3 ⊗ X\n+ XYZX\n\njulia> Z*X\n+iY\n\nWe use a typical F(2,2) encoding internally. The X and Z bits are stored in a single concatenated padded array of UInt chunks of a bit array.\n\njulia> p = P\"-IZXY\";\n\n\njulia> p.xz\n2-element Vector{UInt64}:\n 0x000000000000000c\n 0x000000000000000a\n\nYou can access the X and Z bits through getters and setters or through the xview, zview, xbit, and zbit functions.\n\njulia> p = P\"XYZ\"; p[1]\n(true, false)\n\njulia> p[1] = (true, true); p\n+ YYZ\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.Register","page":"API","title":"QuantumClifford.Register","text":"A register, representing the state of a computer including both a tableaux and an array of classical bits (e.g. for storing measurement results)\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.Reset","page":"API","title":"QuantumClifford.Reset","text":"Reset the specified qubits to the given state.\n\nBe careful, this operation implies first tracing out the qubits, which can lead to mixed states if these qubits were entangled with the rest of the system.\n\nSee also: sMRZ\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.SingleQubitOperator","page":"API","title":"QuantumClifford.SingleQubitOperator","text":"A \"symbolic\" general single-qubit operator which permits faster multiplication than an operator expressed as an explicit tableau.\n\njulia> op = SingleQubitOperator(2, true, true, true, false, true, true) # Tableau components and phases\nSingleQubitOperator on qubit 2\nX₁ ⟼ - Y\nZ₁ ⟼ - X\n\njulia> typeof(op)\nSingleQubitOperator\n\njulia> t_op = CliffordOperator(op, 3) # Transforming it back into an explicit tableau representation (specifying the size)\nX₁ ⟼ + X__\nX₂ ⟼ - _Y_\nX₃ ⟼ + __X\nZ₁ ⟼ + Z__\nZ₂ ⟼ - _X_\nZ₃ ⟼ + __Z\n\njulia> typeof(t_op)\nCliffordOperator{QuantumClifford.Tableau{Vector{UInt8}, Matrix{UInt64}}, PauliOperator{Array{UInt8, 0}, Vector{UInt64}}}\n\njulia> CliffordOperator(op, 1, compact=true) # You can also extract just the non-trivial part of the tableau\nX₁ ⟼ - Y\nZ₁ ⟼ - X\n\nSee also: sHadamard, sPhase, sId1, sX, sY, sZ, CliffordOperator\n\nOr simply consult subtypes(QuantumClifford.AbstractSingleQubitOperator) and subtypes(QuantumClifford.AbstractTwoQubitOperator) for a full list. You can think of the s prefix as \"symbolic\" or \"sparse\".\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.SparseGate","page":"API","title":"QuantumClifford.SparseGate","text":"A Clifford gate, applying the given cliff operator to the qubits at the selected indices.\n\napply!(state, cliff, indices) and apply!(state, SparseGate(cliff, indices)) give the same result.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.Stabilizer","page":"API","title":"QuantumClifford.Stabilizer","text":"Stabilizer, i.e. a list of commuting multi-qubit Hermitian Pauli operators.\n\nInstances can be created with the S custom string macro or as direct sum of other stabilizers.\n\ntip: Stabilizers and Destabilizers\nIn many cases you probably would prefer to use the MixedDestabilizer data structure, as it caries a lot of useful additional information, like tracking rank and destabilizer operators. Stabilizer has mostly a pedagogical value, and it is also used for slightly faster simulation of a particular subset of Clifford operations.\n\njulia> s = S\"XXX\n             ZZI\n             IZZ\"\n+ XXX\n+ ZZ_\n+ _ZZ\n\njulia> s⊗s\n+ XXX___\n+ ZZ____\n+ _ZZ___\n+ ___XXX\n+ ___ZZ_\n+ ____ZZ\n\nIt has an indexing API, looking like a list of PauliOperators.\n\njulia> s[2]\n+ ZZ_\n\nPauli operators can act directly on the a stabilizer.\n\njulia> P\"YYY\" * s\n- XXX\n+ ZZ_\n+ _ZZ\n\nThere are a number of ways to create a Stabilizer, including:\n\ngenerate Stabilizers from a list of Pauli operators\n\njulia> Stabilizer([P\"XX\", P\"ZZ\"])\n+ XX\n+ ZZ\n\ngenerate Stabilizers from boolean matrices\n\njulia> a = [true true; false false]; b = [false true; true true];\n\njulia> Stabilizer(a, b)\n+ XY\n+ ZZ\n\njulia> Stabilizer([0x0, 0x2], a, b)\n+ XY\n- ZZ\n\ninitialize an empty Stabilizer and fill it through indexing\n\njulia> s = zero(Stabilizer, 2)\n+ __\n+ __\n\njulia> s[1,1] = (true, false); s\n+ X_\n+ __\n\nThere are no automatic checks for correctness (i.e. independence of all rows, commutativity of all rows, hermiticity of all rows). The rank (number of rows) is permitted to be less than the number of qubits (number of columns): canonilization, projection, etc. continue working in that case. To great extent this library uses the Stabilizer data structure simply as a tableau. This might be properly abstracted away in future versions.\n\nSee also: PauliOperator, canonicalize!\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.Stabilizer-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"API","title":"QuantumClifford.Stabilizer","text":"Convert a graph representing a stabilizer state to an explicit Stabilizer.\n\nSee also: graphstate\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.SubsystemCodeTableau","page":"API","title":"QuantumClifford.SubsystemCodeTableau","text":"A tableau representation of the non-commutative canonical form of a set of Paulis, which is used in commutify.\n\nThey are organized in the same form as MixedDestabilizer with a stabilizer, destabilizer, logical X, and logical Z components.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.UnbiasedUncorrelatedNoise","page":"API","title":"QuantumClifford.UnbiasedUncorrelatedNoise","text":"Depolarization noise model with total probability of error p.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.UnitaryPauliChannel","page":"API","title":"QuantumClifford.UnitaryPauliChannel","text":"A Pauli channel datastructure, mainly for use with GeneralizedStabilizer.\n\nMore convenient to use than PauliChannel when you know your Pauli channel is unitary.\n\njulia> Tgate = UnitaryPauliChannel(\n           (I, Z),\n           ((1+exp(im*π/4))/2, (1-exp(im*π/4))/2)\n       )\nA unitary Pauli channel P = ∑ ϕᵢ Pᵢ with the following branches:\nwith ϕᵢ | Pᵢ\n 0.853553+0.353553im | + _\n 0.146447-0.353553im | + Z\n\njulia> PauliChannel(Tgate)\nPauli channel ρ ↦ ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† with the following branches:\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 0.853553+0.0im | + _ | + _\n 0.0+0.353553im | + _ | + Z\n 0.0-0.353553im | + Z | + _\n 0.146447+0.0im | + Z | + Z\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.VerifyOp","page":"API","title":"QuantumClifford.VerifyOp","text":"A \"probe\" to verify that the state of the qubits corresponds to a desired good_state, e.g. at the end of the execution of a circuit.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sCNOT","page":"API","title":"QuantumClifford.sCNOT","text":"A \"symbolic\" CNOT. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sCPHASE","page":"API","title":"QuantumClifford.sCPHASE","text":"A \"symbolic\" CPHASE. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sCXSWAP","page":"API","title":"QuantumClifford.sCXSWAP","text":"A \"symbolic\" CXSWAP. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sCXYZ","page":"API","title":"QuantumClifford.sCXYZ","text":"A \"symbolic\" single-qubit CXYZ. See also: SingleQubitOperator, AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sCZSWAP","page":"API","title":"QuantumClifford.sCZSWAP","text":"A \"symbolic\" CZSWAP. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sCZYX","page":"API","title":"QuantumClifford.sCZYX","text":"A \"symbolic\" single-qubit CZYX. See also: SingleQubitOperator, AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sHadamard","page":"API","title":"QuantumClifford.sHadamard","text":"A \"symbolic\" single-qubit Hadamard. See also: SingleQubitOperator, AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sHadamardXY","page":"API","title":"QuantumClifford.sHadamardXY","text":"A \"symbolic\" single-qubit HadamardXY. See also: SingleQubitOperator, AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sHadamardYZ","page":"API","title":"QuantumClifford.sHadamardYZ","text":"A \"symbolic\" single-qubit HadamardYZ. See also: SingleQubitOperator, AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sISWAP","page":"API","title":"QuantumClifford.sISWAP","text":"A \"symbolic\" ISWAP. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sId1","page":"API","title":"QuantumClifford.sId1","text":"A \"symbolic\" single-qubit Identity operation.\n\nSee also: SingleQubitOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sInvISWAP","page":"API","title":"QuantumClifford.sInvISWAP","text":"A \"symbolic\" InvISWAP. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sInvPhase","page":"API","title":"QuantumClifford.sInvPhase","text":"A \"symbolic\" single-qubit InvPhase. See also: SingleQubitOperator, AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sInvSQRTX","page":"API","title":"QuantumClifford.sInvSQRTX","text":"A \"symbolic\" single-qubit InvSQRTX. See also: SingleQubitOperator, AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sInvSQRTXX","page":"API","title":"QuantumClifford.sInvSQRTXX","text":"A \"symbolic\" InvSQRTXX. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sInvSQRTY","page":"API","title":"QuantumClifford.sInvSQRTY","text":"A \"symbolic\" single-qubit InvSQRTY. See also: SingleQubitOperator, AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sInvSQRTYY","page":"API","title":"QuantumClifford.sInvSQRTYY","text":"A \"symbolic\" InvSQRTYY. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sInvSQRTZZ","page":"API","title":"QuantumClifford.sInvSQRTZZ","text":"A \"symbolic\" InvSQRTZZ. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sInvSWAPCX","page":"API","title":"QuantumClifford.sInvSWAPCX","text":"A \"symbolic\" InvSWAPCX. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sInvZCrY","page":"API","title":"QuantumClifford.sInvZCrY","text":"A \"symbolic\" InvZCrY. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sMRX","page":"API","title":"QuantumClifford.sMRX","text":"Measure a qubit in the X basis and reset to the |+⟩ state.\n\nSee also: sMRZ, Reset, sMZ\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sMRY","page":"API","title":"QuantumClifford.sMRY","text":"Measure a qubit in the Y basis and reset to the |i₊⟩ state.\n\nSee also: sMRZ, Reset, sMZ\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sMRZ","page":"API","title":"QuantumClifford.sMRZ","text":"Measure a qubit in the Z basis and reset to the |0⟩ state.\n\nwarning: It does not trace out the qubit!\nAs described below there is a difference between measuring the qubit (followed by setting it to a given known state) and \"tracing out\" the qubit. By reset here we mean \"measuring and setting to a known state\", not \"tracing out\".\n\njulia> s = MixedDestabilizer(S\"XXX ZZI IZZ\") # |000⟩+|111⟩\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z__\n+ _X_\n+ __X\n𝒮𝓉𝒶𝒷━\n+ XXX\n+ ZZ_\n+ Z_Z\n\njulia> traceout!(copy(s), 1) # = I⊗(|00⟩⟨00| + |11⟩⟨11|)\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ _X_\n𝒳ₗ━━━\n+ _XX\n+ Z__\n𝒮𝓉𝒶𝒷━\n+ _ZZ\n𝒵ₗ━━━\n+ Z_Z\n+ XXX\n\njulia> projectZ!(traceout!(copy(s), 1), 1)[1] # = |000⟩⟨000|+|011⟩⟨011| or |100⟩⟨100|+|111⟩⟨111| (use projectZrand! to actually get a random result)\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ _X_\n+ XXX\n𝒳ₗ━━━\n+ _XX\n𝒮𝓉𝒶𝒷━\n+ _ZZ\n+ Z__\n𝒵ₗ━━━\n+ Z_Z\n\njulia> projectZ!(copy(s), 1)[1] # = |000⟩ or |111⟩ (use projectZrand! to actually get a random result)\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ XXX\n+ _X_\n+ __X\n𝒮𝓉𝒶𝒷━\n+ Z__\n+ ZZ_\n+ Z_Z\n\njulia> apply!(Register(copy(s)), sMRZ(1)) |> quantumstate # |000⟩ or |011⟩, depending on randomization\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ XXX\n+ _X_\n+ __X\n𝒮𝓉𝒶𝒷━\n+ Z__\n- ZZ_\n- Z_Z\n\nSee also: Reset, sMZ\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sMX","page":"API","title":"QuantumClifford.sMX","text":"Symbolic single qubit X measurement. See also Register, projectXrand!, sMY, sMZ\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sMY","page":"API","title":"QuantumClifford.sMY","text":"Symbolic single qubit Y measurement. See also Register, projectYrand!, sMX, sMZ\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sMZ","page":"API","title":"QuantumClifford.sMZ","text":"Symbolic single qubit Z measurement. See also Register, projectZrand!, sMX, sMY\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sPhase","page":"API","title":"QuantumClifford.sPhase","text":"A \"symbolic\" single-qubit Phase. See also: SingleQubitOperator, AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sSQRTX","page":"API","title":"QuantumClifford.sSQRTX","text":"A \"symbolic\" single-qubit SQRTX. See also: SingleQubitOperator, AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sSQRTXX","page":"API","title":"QuantumClifford.sSQRTXX","text":"A \"symbolic\" SQRTXX. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sSQRTY","page":"API","title":"QuantumClifford.sSQRTY","text":"A \"symbolic\" single-qubit SQRTY. See also: SingleQubitOperator, AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sSQRTYY","page":"API","title":"QuantumClifford.sSQRTYY","text":"A \"symbolic\" SQRTYY. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sSQRTZZ","page":"API","title":"QuantumClifford.sSQRTZZ","text":"A \"symbolic\" SQRTZZ. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sSWAP","page":"API","title":"QuantumClifford.sSWAP","text":"A \"symbolic\" SWAP. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sSWAPCX","page":"API","title":"QuantumClifford.sSWAPCX","text":"A \"symbolic\" SWAPCX. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sX","page":"API","title":"QuantumClifford.sX","text":"A \"symbolic\" single-qubit X. See also: SingleQubitOperator, AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sXCX","page":"API","title":"QuantumClifford.sXCX","text":"A \"symbolic\" XCX. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sXCY","page":"API","title":"QuantumClifford.sXCY","text":"A \"symbolic\" XCY. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sXCZ","page":"API","title":"QuantumClifford.sXCZ","text":"A \"symbolic\" XCZ. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sY","page":"API","title":"QuantumClifford.sY","text":"A \"symbolic\" single-qubit Y. See also: SingleQubitOperator, AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sYCX","page":"API","title":"QuantumClifford.sYCX","text":"A \"symbolic\" YCX. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sYCY","page":"API","title":"QuantumClifford.sYCY","text":"A \"symbolic\" YCY. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sYCZ","page":"API","title":"QuantumClifford.sYCZ","text":"A \"symbolic\" YCZ. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sZ","page":"API","title":"QuantumClifford.sZ","text":"A \"symbolic\" single-qubit Z. See also: SingleQubitOperator, AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sZCX","page":"API","title":"QuantumClifford.sZCX","text":"A \"symbolic\" ZCX. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sZCY","page":"API","title":"QuantumClifford.sZCY","text":"A \"symbolic\" ZCY. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sZCZ","page":"API","title":"QuantumClifford.sZCZ","text":"A \"symbolic\" ZCZ. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sZCrY","page":"API","title":"QuantumClifford.sZCrY","text":"A \"symbolic\" ZCrY. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.PauliError","page":"API","title":"QuantumClifford.PauliError","text":"A convenient constructor for various types of Pauli errors, that can be used as circuit gates in simulations. Returns more specific types when necessary.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.PauliError-NTuple{4, Any}","page":"API","title":"QuantumClifford.PauliError","text":"\"Construct a gate operation that applies a biased Pauli error on all qubits independently, each with  probabilities px, py, pz. Note that the probability of any error occurring is px+py+pz. Because of this, PauliError(1, p) is equivalent to PauliError(1,p/3,p/3,p/3). Similarly, if one wanted to exclude Z errors from PauliError(1,p/3,p/3,p/3) while mainting the same rate of X errors, one could write PauliError(1, p*2/3, 0, 0) (in the sense that Y errors can be interpreted as an X and a Z happening at the same time).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.PauliError-Tuple{Any, Any}","page":"API","title":"QuantumClifford.PauliError","text":"\"Construct a gate operation that applies an unbiased Pauli error on all qubits, each with independent probability p.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.PauliError-Tuple{Int64, Any, Any, Any}","page":"API","title":"QuantumClifford.PauliError","text":"\"Construct a gate operation that applies a biased Pauli error on  qubit q with independent probabilities px, py, pz. Note that the probability of any error occurring is px+py+pz. Because of this, PauliError(1, p) is equivalent to PauliError(1,p/3,p/3,p/3). Similarly, if one wanted to exclude Z errors from PauliError(1,p/3,p/3,p/3) while mainting the same rate of X errors, one could write PauliError(1, p*2/3, 0, 0) (in the sense that Y errors can be interpreted as an X and a Z happening at the same time).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.PauliError-Tuple{Int64, Any}","page":"API","title":"QuantumClifford.PauliError","text":"\"Construct a gate operation that applies an unbiased Pauli error on qubit q with probability p.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.affectedqubits","page":"API","title":"QuantumClifford.affectedqubits","text":"A method giving the qubits acted upon by a given operation. Part of the Noise interface.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.apply_inv!","page":"API","title":"QuantumClifford.apply_inv!","text":"apply_inv!\n\nApply the inverse of any quantum operation to a stabilizer state.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.apply_right!","page":"API","title":"QuantumClifford.apply_right!","text":"the apply_right! function is used to right multiply any quantum operation to unitary  Clifford operation or Pauli product\n\njulia> apply_right!(C\"X Z\", sHadamard(1))\nX₁ ⟼ + Z\nZ₁ ⟼ + X\njulia> apply_right!(C\"Y Z\", C\"Z Y\")\nX₁ ⟼ + Z\nZ₁ ⟼ - X\njulia> apply_right!(C\"Y Z\", P\"X\")\nX₁ ⟼ + Y\nZ₁ ⟼ - Z\n\nExample: Build a bell state decoder\n\njulia> cliff = one(CliffordOperator, 2)\nX₁ ⟼ + X_\nX₂ ⟼ + _X\nZ₁ ⟼ + Z_\nZ₂ ⟼ + _Z\njulia> apply_right!(cliff, sHadamard(1))\nX₁ ⟼ + Z_\nX₂ ⟼ + _X\nZ₁ ⟼ + X_\nZ₂ ⟼ + _Z\njulia> apply_right!(cliff, sCNOT(1, 2))\nX₁ ⟼ + ZX\nX₂ ⟼ + _X\nZ₁ ⟼ + X_\nZ₂ ⟼ + XZ\njulia> apply!(bell(), cliff)\n+ Z_\n+ _Z\n\nSee also: apply!, apply_inv!\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.applybranches","page":"API","title":"QuantumClifford.applybranches","text":"Compute all possible new states after the application of the given operator. Reports the probability of each one of them. Deterministic (as it reports all branches of potentially random processes), part of the Perturbative Expansion interface.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.applynoise!","page":"API","title":"QuantumClifford.applynoise!","text":"A method modifying a given state by applying the corresponding noise model. It is non-deterministic, part of the Noise interface.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.applywstatus!-Tuple{Any, Any}","page":"API","title":"QuantumClifford.applywstatus!","text":"Used for mctrajectories.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.bell","page":"API","title":"QuantumClifford.bell","text":"Prepare one or more Bell pairs (with optional phases).\n\njulia> bell()\n+ XX\n+ ZZ\n\njulia> bell(2)\n+ XX__\n+ ZZ__\n+ __XX\n+ __ZZ\n\njulia> bell((true, false))\n- XX\n+ ZZ\n\njulia> bell([true, false, true, true])\n- XX__\n+ ZZ__\n- __XX\n- __ZZ\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.bigram-Tuple{QuantumClifford.AbstractStabilizer}","page":"API","title":"QuantumClifford.bigram","text":"bigram(\n    state::QuantumClifford.AbstractStabilizer;\n    clip\n) -> Matrix{Int64}\n\n\nGet the bigram of a tableau.\n\nIt is the list of endpoints of a tableau in the clipped gauge.\n\nIf clip=true (the default) the tableau is converted to the clipped gauge in-place before calculating the bigram. Otherwise, the clip gauge conversion is skipped (for cases where the input is already known to be in the correct gauge).\n\nIntroduced in (Nahum et al., 2017), with a more detailed explanation of the algorithm in (Li et al., 2019) and (Gullans et al., 2021).\n\nSee also: canonicalize_clip!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.bitview","page":"API","title":"QuantumClifford.bitview","text":"A view of the classical bits stored with the state\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.canonicalize!-Tuple{QuantumClifford.AbstractStabilizer}","page":"API","title":"QuantumClifford.canonicalize!","text":"canonicalize!(\n    state::QuantumClifford.AbstractStabilizer;\n    phases,\n    ranks\n) -> Union{Tuple{QuantumClifford.AbstractStabilizer, Int64, Int64}, QuantumClifford.AbstractStabilizer}\n\n\nCanonicalize a stabilizer (in place).\n\nAssumes the input is a valid stabilizer (all operators commute and have real phases). It permits redundant generators and identity generators.\n\njulia> ghz = S\"XXXX\n               ZZII\n               IZZI\n               IIZZ\";\n\n\njulia> canonicalize!(ghz)\n+ XXXX\n+ Z__Z\n+ _Z_Z\n+ __ZZ\n\njulia> canonicalize!(S\"XXXX\n                       IZZI\n                       IIZZ\")\n+ XXXX\n+ _Z_Z\n+ __ZZ\n\nNot all rows in the tableau in the next example are independent:\n\njulia> canonicalize!(S\"XXXX\n                       ZZII\n                       IZZI\n                       IZIZ\n                       IIZZ\")\n+ XXXX\n+ Z__Z\n+ _Z_Z\n+ __ZZ\n+ ____\n\nIn cases of lower rank, more advanced tableau structures might be better. For instance the MixedStabilizer or MixedDestabilizer structures (you can read more about them in the Data Structures section of the documentation).\n\nIf phases=false is set, the canonicalization does not track the phases in the tableau, leading to significant (constant factor) speedup.\n\njulia> s = S\"-ZX\n              XZ\"\n- ZX\n+ XZ\n\njulia> canonicalize!(copy(s), phases=false)\n- XZ\n+ ZX\n\njulia> canonicalize!(copy(s))\n+ XZ\n- ZX\n\nIf ranks=true is set, the last pivot indices for the X and Z stage of the canonicalization are returned as well.\n\njulia> s = S\"XXXX\n             ZZII\n             IZIZ\n             ZIIZ\";\n\n\njulia> _, ix, iz = canonicalize!(s, ranks=true); ix, iz\n(1, 3)\n\njulia> s\n+ XXXX\n+ Z__Z\n+ _Z_Z\n+ ____\n\nBased on (Garcia et al., 2012).\n\nSee also: canonicalize_rref!, canonicalize_gott!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.canonicalize_clip!-Tuple{QuantumClifford.AbstractStabilizer}","page":"API","title":"QuantumClifford.canonicalize_clip!","text":"canonicalize_clip!(\n    state::QuantumClifford.AbstractStabilizer;\n    phases\n) -> QuantumClifford.AbstractStabilizer\n\n\nFix the clipped gauge of a stabilizer (in place).\n\nAssumes the input is a valid full-rank stabilizer (all operators commute and have real phases).\n\njulia> s = S\"- X_ZX_X\n             + XXYZ__\n             - YZ_Z_X\n             - XZX__Y\n             + _Z_Y_Y\n             - ____Z_\";\n\n\njulia> canonicalize_clip!(s)\n- X_XY__\n+ YZY___\n+ _XZX__\n- _ZYX_Z\n- __YZ_X\n- ____Z_\n\nIf phases=false is set, the canonicalization does not track the phases in the tableau, leading to a significant speedup.\n\nIntroduced in (Nahum et al., 2017), with a more detailed explanation of the algorithm in Appendix A of (Li et al., 2019)\n\nSee also: canonicalize!, canonicalize_rref!, canonicalize_gott!.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.canonicalize_gott!-Tuple{Stabilizer}","page":"API","title":"QuantumClifford.canonicalize_gott!","text":"Inplace Gottesman canonicalization of a tableau.\n\nThis uses different canonical form from canonicalize!. It is used in the computation of the logical X and Z operators of a MixedDestabilizer.\n\nIt returns the (in place) modified state, the indices of the last pivot of both Gaussian elimination steps, and the permutations that have been used to put the X and Z tableaux in standard form.\n\nBased on (Gottesman, 1997).\n\nSee also: canonicalize!, canonicalize_rref!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.canonicalize_noncomm-Tuple{QuantumClifford.Tableau}","page":"API","title":"QuantumClifford.canonicalize_noncomm","text":"For a not-necessarily commutative set of Paulis, return a generating set of the form ⟨A₁, A₂, ... Aₖ, Aₖ₊₁, ... Aₘ, B₁, B₂, ... Bₖ⟩ where pairs Aₖ, Bₖ anticommute and all other pairings commute. Based on (Terhal, 2015)\n\nReturns the generating set as a data structure of type SubsystemCodeTableau. The logicalxview function returns the ⟨A₁, A₂,... Aₖ⟩, and the logicalzview function returns ⟨B₁, B₂, ... Bₖ⟩. stabilizerview returns ⟨Aₖ₊₁, ... Aₘ⟩ as a Stabilizer, and destabilizerview returns the Destabilizer of that Stabilizer.\n\nPhases are zeroed-out in this canonicalization.\n\njulia> canonicalize_noncomm(T\"XX XZ XY\")\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z_\n𝒳━━\n+ XX\n𝒮𝓉𝒶𝒷\n+ X_\n𝒵━━\n+ XZ\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.canonicalize_rref!-Tuple{QuantumClifford.AbstractStabilizer, Any}","page":"API","title":"QuantumClifford.canonicalize_rref!","text":"canonicalize_rref!(\n    state::QuantumClifford.AbstractStabilizer,\n    colindices;\n    phases\n) -> Tuple{QuantumClifford.AbstractStabilizer, Any}\n\n\nCanonicalize a stabilizer (in place) along only some columns.\n\nThis uses different canonical form from canonicalize!. It also indexes in reverse in order to make its use in traceout! more efficient. Its use in traceout! is its main application.\n\nIt returns the (in place) modified state and the index of the last pivot.\n\nBased on (Audenaert and Plenio, 2005).\n\nSee also: canonicalize!, canonicalize_gott!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.canonicalize_rref!-Tuple{QuantumClifford.AbstractStabilizer}","page":"API","title":"QuantumClifford.canonicalize_rref!","text":"canonicalize_rref!(\n    state::QuantumClifford.AbstractStabilizer;\n    phases\n) -> Tuple{QuantumClifford.AbstractStabilizer, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.centralizer-Tuple{QuantumClifford.Tableau}","page":"API","title":"QuantumClifford.centralizer","text":"For a given set of Paulis (in the form of a Tableau), return the subset of Paulis that commute with all Paulis in set.\n\njulia> centralizer(T\"XX ZZ _Z\")\n+ ZZ\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.clifford_cardinality-Tuple{Int64}","page":"API","title":"QuantumClifford.clifford_cardinality","text":"The size of the Clifford group 𝒞 over a given number of qubits, possibly modulo the phases.\n\nFor n qubits, not accounting for phases is 2ⁿⁿΠⱼ₌₁ⁿ(4ʲ-1). There are 4ⁿ different phase configurations.\n\njulia> clifford_cardinality(7)\n457620995529680351512370381586432000\n\nWhen not accounting for phases (phases = false) the result is the same as the size of the Symplectic group Sp(2n) ≡ 𝒞ₙ/𝒫ₙ, where 𝒫ₙ is the Pauli group over n qubits.\n\njulia> clifford_cardinality(7, phases=false)\n27930968965434591767112450048000\n\nSee also: enumerate_cliffords.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.comm","page":"API","title":"QuantumClifford.comm","text":"Check whether two operators commute.\n\n0x0 if they commute, 0x1 if they anticommute.\n\njulia> P\"XX\"*P\"ZZ\", P\"ZZ\"*P\"XX\"\n(- YY, - YY)\n\njulia> comm(P\"ZZ\", P\"XX\")\n0x00\n\njulia> comm(P\"IZ\", P\"XX\")\n0x01\n\nSee also: comm!\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.comm!","page":"API","title":"QuantumClifford.comm!","text":"An in-place version of comm, storing its output in the given buffer.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.commutify-Tuple{Any}","page":"API","title":"QuantumClifford.commutify","text":"For a not-necessarily commutative set of Paulis S, computed S', the non-commutative canonical form of of S. For each pair Aₖ, Bₖ of anticommutative Paulis in S', add a qubit to each Pauli in the set: X to Aₖ, Z to Bₖ, and I to each other operator to produce S'', a fully commutative set. Return S'' as well as a list of the indices of the added qubits.\n\nThe returned object is a Stabilizer that is also useful for the matroid_parent function.\n\njulia> commutify(T\"XX XZ XY\")[1]\n+ XXX\n+ X__\n+ XZZ\n\njulia> commutify(T\"XX XZ XY\")[2]\n3:3\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.compactify_circuit-Tuple{Any}","page":"API","title":"QuantumClifford.compactify_circuit","text":"Convert a list of gates to a more optimized \"sum type\" format which permits faster dispatch.\n\nGenerally, this should be called on a circuit before it is used in a simulation.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.contractor-Tuple{Stabilizer, Any}","page":"API","title":"QuantumClifford.contractor","text":"Return the subset of Paulis in a Stabilizer that have identity operators on all qubits corresponding to the given subset, without the entries corresponding to subset. Based on (Goodenough et al., 2024)\n\njulia> contractor(S\"_X X_\", [1])\n+ X\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.delete_columns-Tuple{Stabilizer, Any}","page":"API","title":"QuantumClifford.delete_columns","text":"Return the given stabilizer without all the qubits in the given iterable.\n\nThe resulting tableaux is not guaranteed to be valid (to retain its commutation relationships).\n\njulia> delete_columns(S\"XYZ YZX ZXY\", [1,3])\n+ Y\n+ Z\n+ X\n\nSee also: traceout!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.destabilizerview-Tuple{Destabilizer}","page":"API","title":"QuantumClifford.destabilizerview","text":"A view of the subtableau corresponding to the destabilizer. See also tab, stabilizerview, logicalxview, logicalzview\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.enumerate_cliffords-Tuple{Any, Any}","page":"API","title":"QuantumClifford.enumerate_cliffords","text":"Give the i-th n-qubit Clifford operation, where i∈{1..2ⁿⁿΠⱼ₌₁ⁿ(4ʲ-1)}\n\nThe algorithm is detailed in (Koenig and Smolin, 2014).\n\nSee also: symplecticGS, clifford_cardinality.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.enumerate_cliffords-Tuple{Any}","page":"API","title":"QuantumClifford.enumerate_cliffords","text":"Give all n-qubit Clifford operations.\n\nThe algorithm is detailed in (Koenig and Smolin, 2014).\n\nSee also: symplecticGS, clifford_cardinality.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.enumerate_phases-Tuple{CliffordOperator}","page":"API","title":"QuantumClifford.enumerate_phases","text":"Given an operator, return all operators that have the same tableau but different phases.\n\njulia> length(collect(enumerate_phases(tCNOT)))\n16\n\nSee also: enumerate_cliffords, clifford_cardinality.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.enumerate_phases-Tuple{Union{Base.Generator, AbstractVector}}","page":"API","title":"QuantumClifford.enumerate_phases","text":"Given a set of operators, return all operators that have the same tableaux but different phases.\n\njulia> length(collect(enumerate_phases(enumerate_cliffords(2))))\n11520\n\nSee also: enumerate_cliffords, clifford_cardinality.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.enumerate_single_qubit_gates-Tuple{Any}","page":"API","title":"QuantumClifford.enumerate_single_qubit_gates","text":"Generate a symbolic single-qubit gate given its index. Optionally, set non-trivial phases.\n\njulia> enumerate_single_qubit_gates(6)\nsPhase on qubit 1\nX₁ ⟼ + Y\nZ₁ ⟼ + Z\n\njulia> enumerate_single_qubit_gates(6, qubit=2, phases=(true, true))\nSingleQubitOperator on qubit 2\nX₁ ⟼ - Y\nZ₁ ⟼ - Z\n\nSee also: enumerate_cliffords.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.fastcolumn","page":"API","title":"QuantumClifford.fastcolumn","text":"Convert a tableau to a memory layout that is fast for column operations.\n\nIn this layout a column of the tableau is stored (mostly) contiguously in memory. Due to bitpacking, e.g., packing 64 bits into a single UInt64, the memory layout is not perfectly contiguous, but it is still optimal given that some bitwrangling is required to extract a given bit.\n\nSee also: fastrow\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.fastrow","page":"API","title":"QuantumClifford.fastrow","text":"Convert a tableau to a memory layout that is fast for row operations.\n\nIn this layout a Pauli string (a row of the tableau) is stored contiguously in memory.\n\nSee also: fastrow\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.generate!-Tuple{PauliOperator, Stabilizer}","page":"API","title":"QuantumClifford.generate!","text":"Generate a Pauli operator by using operators from a given the Stabilizer.\n\nIt assumes the stabilizer is already canonicalized. It modifies the Pauli operator in place, generating it in reverse, up to a phase. That phase is left in the modified operator, which should be the identity up to a phase. Returns the new operator and the list of indices denoting the elements of stabilizer that were used for the generation.\n\njulia> ghz = S\"XXXX\n               ZZII\n               IZZI\n               IIZZ\";\n\n\njulia> canonicalize!(ghz)\n+ XXXX\n+ Z__Z\n+ _Z_Z\n+ __ZZ\n\njulia> generate!(P\"-ZIZI\", ghz)\n(- ____, [2, 4])\n\nWhen the Pauli operator can not be generated by the given tableau, nothing is returned.\n\njulia> generate!(P\"XII\",canonicalize!(S\"ZII\")) === nothing\ntrue\n\njulia> generate!(P\"XII\",canonicalize!(S\"XII\")) === nothing\nfalse\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.gf2_H_to_G-Tuple{Any}","page":"API","title":"QuantumClifford.gf2_H_to_G","text":"For a given F(2,2) parity check matrix, return the generator matrix.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.gf2_gausselim!-Tuple{Any}","page":"API","title":"QuantumClifford.gf2_gausselim!","text":"Gaussian elimination over the binary field.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.gf2_invert-Tuple{Any}","page":"API","title":"QuantumClifford.gf2_invert","text":"Invert a binary matrix.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.gf2_isinvertible-Tuple{Any}","page":"API","title":"QuantumClifford.gf2_isinvertible","text":"Check whether a binary matrix is invertible.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.ghz","page":"API","title":"QuantumClifford.ghz","text":"Prepare a GHZ state of n qubits.\n\njulia> ghz()\n+ XXX\n+ ZZ_\n+ _ZZ\n\njulia> ghz(2)\n+ XX\n+ ZZ\n\njulia> ghz(4)\n+ XXXX\n+ ZZ__\n+ _ZZ_\n+ __ZZ\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.graph_gate-NTuple{4, Any}","page":"API","title":"QuantumClifford.graph_gate","text":"A helper function converting the gate indices from graphstate into a Clifford operator.\n\njulia> s = S\" XXX\n              YZ_\n             -_ZZ\";\n\n\njulia> graph, h_idx, ip_idx, z_idx = graphstate(s);\n\n\njulia> gate = graph_gate(h_idx, ip_idx, z_idx, nqubits(s));\n\n\njulia> apply!(s, gate) # This is now a graph state (notice you need to multiply row 1 by row 2)\n+ YYZ\n+ XZ_\n+ _ZX\n\njulia> canonicalize!(s) == canonicalize!(Stabilizer(graph))\ntrue\n\nSee also: graph_gatesequence\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.graph_gatesequence-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}","page":"API","title":"QuantumClifford.graph_gatesequence","text":"A helper function converting the gate indices from graphstate into a sequence of gates.\n\njulia> s = S\" XXX\n              YZ_\n             -_ZZ\";\n\n\njulia> graph, h_idx, ip_idx, z_idx = graphstate(s);\n\n\njulia> gates = graph_gatesequence(h_idx, ip_idx, z_idx);\n\n\njulia> for gate in vcat(gates...) apply!(s, gate) end\n\n\njulia> s # This is now a graph state (notice you need to multiply row 1 by row 2)\n+ YYZ\n+ XZ_\n+ _ZX\n\njulia> canonicalize!(s) == canonicalize!(Stabilizer(graph))\ntrue\n\nSee also: graph_gatesequence\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.graphstate!-Tuple{Stabilizer}","page":"API","title":"QuantumClifford.graphstate!","text":"An in-place version of graphstate.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.graphstate-Tuple{QuantumClifford.AbstractStabilizer}","page":"API","title":"QuantumClifford.graphstate","text":"Convert any stabilizer state to a graph state\n\nGraph states are a special type of entangled stabilizer states that can be represented by a graph. For a graph G=(VE) the corresponding stabilizers are S_v = X_v prod_u  N(v) Z_u. Notice that such tableau rows contain only a single X operator. There is a set of single qubit gates that converts any stabilizer state to a graph state.\n\nThis function returns the graph state corresponding to a stabilizer and the gates that might be necessary to convert the stabilizer into a state representable as a graph.\n\nFor a tableau stab you can convert it with:\n\ngraph, hadamard_idx, iphase_idx, flips_idx = graphstate()\n\nwhere graph is the graph representation of stab, and the rest specifies the single-qubit gates converting stab to graph: hadamard_idx are the qubits that require a Hadamard gate (mapping X ↔ Z), iphase_idx are (different) qubits that require an inverse Phase gate (Y → X), and flips_idx are the qubits that require a phase flip (Pauli Z gate), after the previous two sets of gates.\n\njulia> using Graphs\n\njulia> s = S\" XXX\n              ZZ_\n             -_ZZ\";\n\n\njulia> g, h_idx, ip_idx, z_idx = graphstate(s);\n\n\njulia> collect(edges(g))\n2-element Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n Edge 1 => 3\n\njulia> h_idx\n2-element Vector{Int64}:\n 2\n 3\n\njulia> ip_idx\nInt64[]\n\njulia> z_idx\n1-element Vector{Int64}:\n 3\n\nThe Graphs.jl library provides many graph-theory tools and the MakieGraphs.jl library provides plotting utilities for graphs.\n\nYou can directly call the graph constructor on a stabilizer, if you just want the graph and do not care about the Clifford operation necessary to convert an arbitrary state to a state representable as a graph:\n\njulia> collect(edges( Graph(bell()) ))\n1-element Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n\nFor a version that does not copy the stabilizer, but rather performs transformations in-place, use graphstate!. It would perform canonicalize_gott! on its argument as it finds a way to convert it to a graph state.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.groupify-Tuple{Stabilizer}","page":"API","title":"QuantumClifford.groupify","text":"Return the full stabilizer group represented by the input generating set (a Stabilizer).\n\nThe returned object is exponentially long.\n\njulia> groupify(S\"XZ ZX\")\n+ __\n+ XZ\n+ ZX\n+ YY\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.logdot-Tuple{QuantumClifford.AbstractStabilizer, QuantumClifford.AbstractStabilizer}","page":"API","title":"QuantumClifford.logdot","text":"Logarithm of the inner product between to Stabilizer states.\n\nIf the result is nothing, the dot inner product is zero. Otherwise the inner product is 2^(-logdot/2).\n\nThe actual inner product can be computed with LinearAlgebra.dot.\n\nBased on (Garcia et al., 2012).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.logicalxview-Tuple{MixedDestabilizer}","page":"API","title":"QuantumClifford.logicalxview","text":"A view of the subtableau corresponding to the logical X operators. See also tab, stabilizerview, destabilizerview, logicalzview\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.logicalzview-Tuple{MixedDestabilizer}","page":"API","title":"QuantumClifford.logicalzview","text":"A view of the subtableau corresponding to the logical Z operators. See also tab, stabilizerview, destabilizerview, logicalxview\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.matroid_parent-Tuple{QuantumClifford.Tableau}","page":"API","title":"QuantumClifford.matroid_parent","text":"For a given set S of Paulis that does not necessarily represent a state, return a set of Paulis S' that represents a state. S' is a superset of commutified S. Additionally returns two arrays representing deletions needed to produce S. Based on (Goodenough et al., 2024)\n\nBy deleting the qubits in the first output array from S', taking the normalizer of S', then deleting the qubits in the second returned array from the normalizer of S', S is reproduced.\n\njulia> matroid_parent(T\"XX\")[1]\n+ X_X\n+ XX_\n+ ZZZ\n\njulia> matroid_parent(T\"XX\")[2]\n3:3\n\njulia> matroid_parent(T\"XX\")[3]\n3:2\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.maximally_mixed-Tuple{Any}","page":"API","title":"QuantumClifford.maximally_mixed","text":"Prepare a maximally mixed state of n qubits.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.mctrajectories-Tuple{Any, Any}","page":"API","title":"QuantumClifford.mctrajectories","text":"Run multiple Monte Carlo trajectories and report the aggregate final statuses of each.\n\nSee also: pftrajectories, petrajectories\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.mctrajectory!-Tuple{Any, Any}","page":"API","title":"QuantumClifford.mctrajectory!","text":"Run a single Monte Carlo sample, starting with (and modifying) state by applying the given circuit. Uses apply! under the hood.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.minimal_generating_set-Tuple{Stabilizer}","page":"API","title":"QuantumClifford.minimal_generating_set","text":"For a not-necessarily-minimal generating set, return the minimal generating set.\n\nThe input has to have only real phases.\n\njulia> minimal_generating_set(S\"__ XZ ZX YY\")\n+ XZ\n+ ZX\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.normalizer-Tuple{QuantumClifford.Tableau}","page":"API","title":"QuantumClifford.normalizer","text":"Return all Pauli operators with the same number of qubits as the given Tableau t that commute with all operators in t.\n\njulia> normalizer(T\"X\")\n+ _\n+ X\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.pauligroup-Tuple{Int64}","page":"API","title":"QuantumClifford.pauligroup","text":"Return the full Pauli group of a given length. Phases are ignored by default, but can be included by setting phases=true.\n\njulia> pauligroup(1)\n+ _\n+ X\n+ Z\n+ Y\n\njulia> pauligroup(1, phases=true)\n+ _\n+ X\n+ Z\n+ Y\n- _\n- X\n- Z\n- Y\n+i_\n+iX\n+iZ\n+iY\n-i_\n-iX\n-iZ\n-iY\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.petrajectories-Tuple{Any, Any}","page":"API","title":"QuantumClifford.petrajectories","text":"Run a perturbative expansion to a given order. This is the main public function for the perturbative expansion approach.\n\nSee also: pftrajectories, mctrajectories\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.pfmeasurements-Tuple{PauliFrame}","page":"API","title":"QuantumClifford.pfmeasurements","text":"pfmeasurements(frame::PauliFrame) -> Any\n\n\nReturns the measurement results for each frame in the PauliFrame instance.\n\nwarning: Relative measurements\nThe return measurements are relative to the reference measurements, i.e. they only say whether the reference measurements have been flipped in the given frame.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.pfmeasurements-Tuple{Register, PauliFrame}","page":"API","title":"QuantumClifford.pfmeasurements","text":"pfmeasurements(register::Register, frame::PauliFrame) -> Any\n\n\nTakes the references measurements from the given Register and applies the flips as prescribed by the PauliFrame relative measurements. The result is the actual (non-relative) measurement results for each frame.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.pfmeasurements-Tuple{Register}","page":"API","title":"QuantumClifford.pfmeasurements","text":"pfmeasurements(register::Register) -> Vector{Bool}\n\n\nReturns the measurements stored in the bits of the given Register.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.pftrajectories","page":"API","title":"QuantumClifford.pftrajectories","text":"Perform a \"Pauli frame\" style simulation of a quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.pftrajectories-Tuple{Any}","page":"API","title":"QuantumClifford.pftrajectories","text":"pftrajectories(\n    circuit;\n    trajectories,\n    threads\n) -> PauliFrame{Stabilizer{QuantumClifford.Tableau{Vector{UInt8}, LinearAlgebra.Adjoint{UInt64, Matrix{UInt64}}}}, Matrix{Bool}}\n\n\nThe main method for running Pauli frame simulations of circuits. See the other methods for lower level access.\n\nMultithreading is enabled by default, but can be disabled by setting threads=false. Do not forget to launch Julia with multiple threads enabled, e.g. julia -t4, if you want to use multithreading.\n\nSee also: mctrajectories, petrajectories\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.pftrajectories-Tuple{PauliFrame, Any}","page":"API","title":"QuantumClifford.pftrajectories","text":"pftrajectories(state::PauliFrame, circuit) -> PauliFrame\n\n\nEvolve each frame stored in PauliFrame by the given circuit.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.pftrajectories-Tuple{Register, Any}","page":"API","title":"QuantumClifford.pftrajectories","text":"pftrajectories(\n    register::Register,\n    circuit;\n    trajectories\n) -> Tuple{Register, PauliFrame{Stabilizer{QuantumClifford.Tableau{Vector{UInt8}, LinearAlgebra.Adjoint{UInt64, Matrix{UInt64}}}}, Matrix{Bool}}}\n\n\nFor a given Register and circuit, simulates the reference circuit acting on the register and then also simulate numerous PauliFrame trajectories. Returns the register and the PauliFrame instance.\n\nUse pfmeasurements to get the measurement results.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.phases-Tuple{QuantumClifford.Tableau}","page":"API","title":"QuantumClifford.phases","text":"The phases of a given tableau. It is a view, i.e. if you modify this array, the original tableau caries these changes.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.prodphase-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:Unsigned","page":"API","title":"QuantumClifford.prodphase","text":"Get the phase of the product of two Pauli operators.\n\nPhase is encoded as F(4) in the low qubits of an UInt8.\n\njulia> P\"ZZZ\"*P\"XXX\"\n-iYYY\n\njulia> prodphase(P\"ZZZ\", P\"XXX\")\n0x03\n\njulia> prodphase(P\"XXX\", P\"ZZZ\")\n0x01\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.projectXrand!-Tuple{Any, Any}","page":"API","title":"QuantumClifford.projectXrand!","text":"projectXrand!(state, qubit) -> Tuple{Register, UInt8}\n\n\nProject qubit of state along the X axis and randomize the phase if necessary.\n\nLower boilerplate version of project!.\n\nSee also: project!, projectX!, projectZrand!, projectYrand!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.projectYrand!-Tuple{Any, Any}","page":"API","title":"QuantumClifford.projectYrand!","text":"projectYrand!(state, qubit) -> Tuple{Register, UInt8}\n\n\nProject qubit of state along the Y axis and randomize the phase if necessary.\n\nLower boilerplate version of project!.\n\nSee also: project!, projectY!, projectXrand!, projectZrand!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.projectZrand!-Tuple{Any, Any}","page":"API","title":"QuantumClifford.projectZrand!","text":"projectZrand!(state, qubit) -> Tuple{Register, UInt8}\n\n\nProject qubit of state along the Z axis and randomize the phase if necessary.\n\nLower boilerplate version of project!.\n\nSee also: project!, projectZ!, projectXrand!, projectYrand!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.projectrand!-Tuple{Any, Any}","page":"API","title":"QuantumClifford.projectrand!","text":"projectrand!(\n    state,\n    pauli\n) -> Tuple{QuantumClifford.AbstractStabilizer, Any}\n\n\nMeasure pauli operator on state and randomize the phase if necessary.\n\nLower boilerplate version of project!.\n\nSee also: project!, projectXrand!, projectZrand!, projectYrand!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.projectrand!-Tuple{GeneralizedStabilizer, PauliOperator}","page":"API","title":"QuantumClifford.projectrand!","text":"projectrand!(\n    sm::GeneralizedStabilizer,\n    p::PauliOperator\n) -> Tuple{GeneralizedStabilizer, UInt8}\n\n\nPerforms a randomized projection of the state represented by the GeneralizedStabilizer sm, based on the measurement of a PauliOperator p.\n\nUnlike in the case of stabilizer states, the expectation value χ′ of a Pauli operator with respect to these more general states can be any real number between -1 and 1. The expectation value can be calculated with expect(p, sm).\n\nchi = langle p rangle = textexpect(p sm)\n\nTo convert χ′ into a probability of projecting on the +1 eigenvalue branch:\n\ntextprobability_1 = fractextreal(chi) + 12\n\nnote: Note\nBecause the possible measurement results are themselves not stabilizer states anymore, we can not use the project! API, which assumes a stabilizer tableau and reports detailed information about whether the tableau and measurement commute or anticommute.\n\njulia> sm = GeneralizedStabilizer(S\"-X\");\n\njulia> apply!(sm, pcT)\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n- X\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 0.0+0.353553im | + _ | + Z\n 0.0-0.353553im | + Z | + _\n 0.853553+0.0im | + _ | + _\n 0.146447+0.0im | + Z | + Z\n\njulia> χ′ = expect(P\"-X\", sm)\n0.7071067811865475 + 0.0im\n\njulia> prob₁ = (real(χ′)+1)/2\n0.8535533905932737\n\njulia> QuantumClifford._projectrand_notnorm(copy(sm), P\"X\", 0)[1]\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n- X\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 0.146447+0.0im | + Z | + Z\n\njulia> QuantumClifford._projectrand_notnorm(copy(sm), P\"X\", 1)[1]\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n- X\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 0.853553+0.0im | + _ | + _\n\nSee also: expect\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.puttableau!-Union{Tuple{M2}, Tuple{M1}, Tuple{T}, Tuple{V2}, Tuple{V1}, Tuple{B}, Tuple{QuantumClifford.Tableau{V1, M1}, QuantumClifford.Tableau{V2, M2}, Int64, Int64}} where {B, V1, V2, T<:Unsigned, M1<:AbstractMatrix{T}, M2<:AbstractMatrix{T}}","page":"API","title":"QuantumClifford.puttableau!","text":"Put source tableau in target tableau at given row and column. Assumes target location is zeroed out.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.quantumstate","page":"API","title":"QuantumClifford.quantumstate","text":"Only the quantum part of the state (excluding classical bits)\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.random_all_to_all_clifford_circuit-Tuple{Random.AbstractRNG, Int64, Int64}","page":"API","title":"QuantumClifford.random_all_to_all_clifford_circuit","text":"Random all-to-all Clifford circuit.\n\nThe circuit contains nqubits qubits and ngates gates. The connectivity is all to all. Each gate in the circuit is a random 2-qubit Clifford gate on randomly picked two qubits.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.random_brickwork_clifford_circuit-Tuple{Random.AbstractRNG, NTuple{N, Int64} where N, Int64}","page":"API","title":"QuantumClifford.random_brickwork_clifford_circuit","text":"Random brickwork Clifford circuit.\n\nThe connectivity of the random circuit is brickwork in some dimensions. Each gate in the circuit is a random 2-qubit Clifford gate.\n\nThe brickwork is defined as follows: The qubits are arranged as a lattice, and lattice_size contains side length in each dimension. For example, a chain of length five will have lattice_size = (5,), and a 5×5 lattice will have lattice_size = (5, 5).\n\nIn multi-dimensional cases, gate layers act alternatively along each direction. The nearest two layers along the same direction are offset by one qubit, forming a so-called brickwork. The boundary condition is chosen as open.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.random_clifford-Tuple{Random.AbstractRNG, Int64}","page":"API","title":"QuantumClifford.random_clifford","text":"A random Clifford operator generated by the Bravyi-Maslov Algorithm 2 from (Bravyi and Maslov, 2021).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.random_clifford1-Tuple{Random.AbstractRNG, Any}","page":"API","title":"QuantumClifford.random_clifford1","text":"Random symbolic single-qubit Clifford applied to qubit at index qubit.\n\nSee also: SingleQubitOperator, random_clifford\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.random_destabilizer-Tuple{Random.AbstractRNG, Int64}","page":"API","title":"QuantumClifford.random_destabilizer","text":"A random Stabilizer/Destabilizer tableau generated by the Bravyi-Maslov Algorithm 2 from (Bravyi and Maslov, 2021).\n\nrandom_destabilizer(n) gives a n-qubit tableau of rank n. random_destabilizer(r,n) gives a n-qubit tableau of rank r.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.random_pauli","page":"API","title":"QuantumClifford.random_pauli","text":"A random Pauli operator on n qubits.\n\nUse nophase=false to randomize the phase. Use realphase=false to get operators with phases including ±i.\n\nOptionally, a \"flip\" probability p can be provided specified, in which case each bit is set to I with probability 1-p and to X or Y or Z with probability p. Useful for simulating unbiased Pauli noise.\n\nSee also random_pauli!\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.random_pauli!","page":"API","title":"QuantumClifford.random_pauli!","text":"An in-place version of random_pauli\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.random_stabilizer-Tuple{Random.AbstractRNG, Int64}","page":"API","title":"QuantumClifford.random_stabilizer","text":"A random Stabilizer tableau generated by the Bravyi-Maslov Algorithm 2 from (Bravyi and Maslov, 2021).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.single_x-Tuple{Any, Any}","page":"API","title":"QuantumClifford.single_x","text":"A multiqubit operator corresponding to all identities except for Pauli X at i. See also: sX, sMX\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.single_y-Tuple{Any, Any}","page":"API","title":"QuantumClifford.single_y","text":"A multiqubit operator corresponding to all identities except for Pauli Y at i. See also: sY, sMY\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.single_z-Tuple{Any, Any}","page":"API","title":"QuantumClifford.single_z","text":"A multiqubit operator corresponding to all identities except for Pauli Z at i. See also: sY, sMY\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.stab_to_gf2-Tuple{QuantumClifford.Tableau}","page":"API","title":"QuantumClifford.stab_to_gf2","text":"The F(2,2) matrix of a given tableau, represented as the concatenation of two binary matrices, one for X and one for Z.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.stabilizerplot","page":"API","title":"QuantumClifford.stabilizerplot","text":"A Makie.jl recipe for pictorial representation of a tableau.\n\nRequires a Makie.jl backend to be loaded, e.g. using CairoMakie.\n\nAlternatively, you can use the Plots.jl plotting ecosystem, e.g. using Plots; plot(S\"XXX ZZZ\").\n\nConsult the documentation for more details on visualization options.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.stabilizerplot_axis","page":"API","title":"QuantumClifford.stabilizerplot_axis","text":"A Makie.jl recipe for pictorial representation of a tableau.\n\nRequires a Makie.jl backend to be loaded, e.g. using CairoMakie.\n\nAlternatively, you can use the Plots.jl plotting ecosystem, e.g. using Plots; plot(S\"XXX ZZZ\").\n\nConsult the documentation for more details on visualization options.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.stabilizerview-Tuple{Stabilizer}","page":"API","title":"QuantumClifford.stabilizerview","text":"A view of the subtableau corresponding to the stabilizer. See also tab, destabilizerview, logicalxview, logicalzview\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.symplecticGS-Tuple{PauliOperator}","page":"API","title":"QuantumClifford.symplecticGS","text":"Perform the Symplectic Gram-Schmidt procedure that gives a Clifford operator canonically related to a given Pauli operator.\n\nThe algorithm is detailed in (Koenig and Smolin, 2014).\n\njulia> symplecticGS(P\"X\", padded_n=3)\nX₁ ⟼ + X__\nX₂ ⟼ + _X_\nX₃ ⟼ + __X\nZ₁ ⟼ + Z__\nZ₂ ⟼ + _Z_\nZ₃ ⟼ + __Z\n\njulia> symplecticGS(P\"Z\")\nX₁ ⟼ + Z\nZ₁ ⟼ + X\n\nSee also: enumerate_cliffords, clifford_cardinality.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.tab-Tuple{QuantumClifford.AbstractStabilizer}","page":"API","title":"QuantumClifford.tab","text":"Extract the underlying tableau structure.\n\njulia> s = S\"X\"\n+ X\n\njulia> tab(s)\n+ X\n\njulia> tab(Destabilizer(s))\n+ Z\n+ X\n\njulia> tab(MixedDestabilizer(s))\n+ Z\n+ X\n\njulia> tab(tHadamard)\n+ Z\n+ X\n\njulia> typeof(tab(tHadamard))\nQuantumClifford.Tableau{Vector{UInt8}, Matrix{UInt64}}\n\nSee also: stabilizerview, destabilizerview, logicalxview, logicalzview\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.xbit-Tuple{PauliOperator}","page":"API","title":"QuantumClifford.xbit","text":"Extract as a new bit array the X part of the UInt array of packed qubits of a given Pauli operator.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.xview-Tuple{PauliOperator}","page":"API","title":"QuantumClifford.xview","text":"Get a view of the X part of the UInt array of packed qubits of a given Pauli operator.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.zbit-Tuple{PauliOperator}","page":"API","title":"QuantumClifford.zbit","text":"Extract as a new bit array the Z part of the UInt array of packed qubits of a given Pauli operator.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.zview-Tuple{PauliOperator}","page":"API","title":"QuantumClifford.zview","text":"Get a view of the Y part of the UInt array of packed qubits of a given Pauli operator.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.:⊗-Tuple{GeneralizedStabilizer, GeneralizedStabilizer}","page":"API","title":"QuantumInterface.:⊗","text":"⊗(\n    state₁::GeneralizedStabilizer,\n    state₂::GeneralizedStabilizer\n) -> GeneralizedStabilizer\n\n\nTensor product of GeneralizedStabilizer states.\n\nStabilizer state\n\njulia> sm = GeneralizedStabilizer(S\"-X\")\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n- X\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 1.0+0.0im | + _ | + _\n\njulia> sm ⊗ sm\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z_\n+ _Z\n𝒮𝓉𝒶𝒷\n- X_\n- _X\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 1.0+0.0im | + __ | + __\n\nArbitrary state\n\njulia> using LinearAlgebra; # hide\n\njulia> sm = GeneralizedStabilizer(ghz(2))\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z_\n+ _X\n𝒮𝓉𝒶𝒷\n+ XX\n+ ZZ\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 1.0+0.0im | + __ | + __\n\njulia> apply!(sm, embed(2, 2, pcT))\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z_\n+ _X\n𝒮𝓉𝒶𝒷\n+ XX\n+ ZZ\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 0.853553+0.0im | + __ | + __\n 0.0+0.353553im | + __ | + Z_\n 0.0-0.353553im | + Z_ | + __\n 0.146447+0.0im | + Z_ | + Z_\n\njulia> newsm = sm ⊗ sm\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z___\n+ _X__\n+ __Z_\n+ ___X\n𝒮𝓉𝒶𝒷━━\n+ XX__\n+ ZZ__\n+ __XX\n+ __ZZ\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 0.0-0.301777im | + Z___ | + ____\n -0.125+0.0im | + Z_Z_ | + ____\n 0.125+0.0im | + Z___ | + Z___\n 0.728553+0.0im | + ____ | + ____\n 0.0-0.0517767im | + Z_Z_ | + Z___\n 0.0-0.301777im | + __Z_ | + ____\n 0.0+0.301777im | + ____ | + Z___\n 0.125+0.0im | + __Z_ | + Z___\n 0.125+0.0im | + Z___ | + __Z_\n 0.0-0.0517767im | + Z_Z_ | + __Z_\n 0.0+0.0517767im | + Z___ | + Z_Z_\n 0.0+0.301777im | + ____ | + __Z_\n 0.0214466+0.0im | + Z_Z_ | + Z_Z_\n 0.125+0.0im | + __Z_ | + __Z_\n -0.125+0.0im | + ____ | + Z_Z_\n 0.0+0.0517767im | + __Z_ | + Z_Z_\n\njulia> real(tr(newsm))\n1.0\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.apply!","page":"API","title":"QuantumInterface.apply!","text":"apply!\n\nApply any quantum operation to a stabilizer state, including unitary Clifford operations, Pauli measurements, and noise. May result in a random/stochastic result (e.g. with measurements or noise).\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumInterface.apply!-Tuple{GeneralizedStabilizer, QuantumClifford.AbstractCliffordOperator}","page":"API","title":"QuantumInterface.apply!","text":"Apply a Clifford gate to a generalized stabilizer state, i.e. a weighted sum of stabilizer states.\n\njulia> sm = GeneralizedStabilizer(S\"-X\")\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n- X\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 1.0+0.0im | + _ | + _\n\njulia> apply!(sm, CliffordOperator(tHadamard))\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ X\n𝒮𝓉𝒶𝒷\n- Z\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 1.0+0.0im | + _ | + _\n\nSee also: GeneralizedStabilizer\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.apply!-Tuple{GeneralizedStabilizer, QuantumClifford.AbstractPauliChannel}","page":"API","title":"QuantumInterface.apply!","text":"Applies a (potentially non-unitary) Pauli channel to a generalized stabilizer.\n\nSee also: GeneralizedStabilizer, PauliChannel, UnitaryPauliChannel\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.embed-Tuple{Int64, Int64, PauliOperator}","page":"API","title":"QuantumInterface.embed","text":"Embed a Pauli operator in a larger Pauli operator.\n\njulia> embed(5, 3, P\"-Y\")\n- __Y__\n\njulia> embed(5, (3,5), P\"-YX\")\n- __Y_X\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.entanglement_entropy","page":"API","title":"QuantumInterface.entanglement_entropy","text":"Get bipartite entanglement entropy of a subsystem\n\nDefined as entropy of the reduced density matrix.\n\nIt can be calculated with multiple different algorithms, the most performant one depending on the particular case.\n\nCurrently implemented are the :clip (clipped gauge), :graph (graph state), and :rref (Gaussian elimination) algorithms. Benchmark your particular case to choose the best one.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumInterface.entanglement_entropy-Tuple{QuantumClifford.AbstractStabilizer, AbstractVector, Val{:graph}}","page":"API","title":"QuantumInterface.entanglement_entropy","text":"Get bipartite entanglement entropy by first converting the state to a graph and computing the rank of the adjacency matrix.\n\nBased on \"Entanglement in graph states and its applications\".\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.entanglement_entropy-Tuple{QuantumClifford.AbstractStabilizer, AbstractVector, Val{:rref}}","page":"API","title":"QuantumInterface.entanglement_entropy","text":"Get bipartite entanglement entropy by converting to RREF form (i.e., partial trace form).\n\nThe state will be partially canonicalized in an RREF form.\n\nSee also: canonicalize_rref!, traceout!.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.entanglement_entropy-Tuple{QuantumClifford.AbstractStabilizer, UnitRange, Val{:clip}}","page":"API","title":"QuantumInterface.entanglement_entropy","text":"Get bipartite entanglement entropy of a contiguous subsystem by passing through the clipped gauge.\n\nIf clip=false is set the canonicalization step is skipped, useful if the input state is already in the clipped gauge.\n\nSee also: bigram, canonicalize_clip!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.expect-Tuple{PauliOperator, GeneralizedStabilizer}","page":"API","title":"QuantumInterface.expect","text":"expect(p::PauliOperator, s::GeneralizedStabilizer) -> Any\n\n\nExpectation value for the PauliOperator observable given the GeneralizedStabilizer state s.\n\njulia> sm = GeneralizedStabilizer(S\"-X\")\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n- X\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 1.0+0.0im | + _ | + _\n\njulia> apply!(sm, pcT)\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n- X\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 0.0+0.353553im | + _ | + Z\n 0.0-0.353553im | + Z | + _\n 0.853553+0.0im | + _ | + _\n 0.146447+0.0im | + Z | + Z\n\njulia> χ′ = expect(P\"-X\", sm)\n0.7071067811865475 + 0.0im\n\njulia> prob = (real(χ′)+1)/2\n0.8535533905932737\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.expect-Tuple{PauliOperator, QuantumClifford.AbstractStabilizer}","page":"API","title":"QuantumInterface.expect","text":"expect(p::PauliOperator, st::AbstractStabilizer)\n\nCompute the expectation value of a Pauli operator p on a stabilizer state st. This function will allocate a temporary copy of the stabilizer state st.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.nqubits-Tuple{QuantumClifford.AbstractStabilizer}","page":"API","title":"QuantumInterface.nqubits","text":"The number of qubits of a given state.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.project!-Tuple{Any, PauliOperator}","page":"API","title":"QuantumInterface.project!","text":"project!(\n    state,\n    pauli::PauliOperator;\n    keep_result,\n    phases\n) -> Tuple{MixedStabilizer, Int64, Any}\n\n\nProject the state of a Stabilizer on the two eigenspaces of a Pauli operator.\n\nAssumes the input is a valid stabilizer. The projection is done inplace on that stabilizer and it does not modify the projection operator.\n\nIt returns\n\na stabilizer that might not be in canonical form\nthe index of the row where the non-commuting operator was (that row is now equal to pauli; its phase is not updated and for a faithful measurement simulation it needs to be randomized by the user)\nand the result of the projection if there was no non-commuting operator (nothing otherwise)\n\nIf keep_result==false that result of the projection in case of anticommutation is not computed, sparing a canonicalization operation. This canonicalization operation is the only one potentially of cubic complexity. The rest of the calculations are of quadratic complexity.\n\nIf you need to measure a single qubit instead of a multiqubit Pauli operator, the faster projectX!, projectY!, and projectZ! are available.\n\nFor less boilerplate and automatic randomization of the phase use projectrand!.\n\nHere is an example of a projection destroying entanglement:\n\njulia> ghz = S\"XXXX\n               ZZII\n               IZZI\n               IIZZ\";\n\n\njulia> canonicalize!(ghz)\n+ XXXX\n+ Z__Z\n+ _Z_Z\n+ __ZZ\n\njulia> state, anticom_index, result = project!(ghz, P\"ZIII\");\n\n\njulia> state\n+ Z___\n+ Z__Z\n+ _Z_Z\n+ __ZZ\n\njulia> canonicalize!(state)\n+ Z___\n+ _Z__\n+ __Z_\n+ ___Z\n\njulia> anticom_index, result\n(1, nothing)\n\nAnd an example of projection consistent with the stabilizer state.\n\njulia> s = S\"ZII\n             IXI\n             IIY\";\n\n\njulia> canonicalize!(s)\n+ _X_\n+ __Y\n+ Z__\n\njulia> state, anticom_index, result = project!(s, P\"-ZII\");\n\n\njulia> state\n+ _X_\n+ __Y\n+ Z__\n\njulia> anticom_index, result\n(0, 0x02)\n\nWhile not the best choice, Stabilizer can be used for mixed states, simply by providing an incomplete tableau. In that case it is possible to attempt to project on an operator that can not be generated by the provided stabilizer operators. In that case we have anticom_index==rank and result===nothing, where rank is the the new rank of the tableau, one more than the number of rows in the initial tableau. However, if keep_result was set to false, then anticom_index would stay at zero.\n\njulia> s = S\"XZI\n             IZI\";\n\n\njulia> project!(s, P\"IIX\")[1]\n+ X__\n+ _Z_\n\nIf we had used MixedStabilizer we would have added the projector to the list of stabilizers.\n\njulia> s = one(MixedStabilizer, 2, 3)\n+ Z__\n+ _Z_\n\njulia> project!(s, P\"IIX\")[1]\n+ Z__\n+ _Z_\n+ __X\n\nHowever, MixedDestabilizer would be an even better choice as it has mathcalO(n^2) complexity instead of the mathcalO(n^3) complexity of *Stabilizer.\n\njulia> s = one(MixedDestabilizer, 2, 3)\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ X__\n+ _X_\n𝒳ₗ━━━\n+ __X\n𝒮𝓉𝒶𝒷━\n+ Z__\n+ _Z_\n𝒵ₗ━━━\n+ __Z\n\njulia> project!(s, P\"IIX\")[1]\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ X__\n+ _X_\n+ __Z\n𝒮𝓉𝒶𝒷━\n+ Z__\n+ _Z_\n+ __X\n\nSee the \"Datastructure Choice\" section in the documentation for more details.\n\nSee also: projectX!, projectY!, projectZ!, projectrand!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.project!-Tuple{MixedStabilizer, PauliOperator}","page":"API","title":"QuantumInterface.project!","text":"project!(\n    state::MixedStabilizer,\n    pauli::PauliOperator;\n    phases\n) -> Tuple{MixedStabilizer, Int64, Any}\n\n\nWhen using project! on MixedStabilizer it automates some of the extra steps we encounter when implicitly using the Stabilizer datastructure to represent mixed states. Namely, it helps when the projector is not among the list of stabilizers:\n\njulia> s = S\"XZI\n             IZI\";\n\n\njulia> ms = MixedStabilizer(s)\n+ X__\n+ _Z_\n\njulia> project!(ms, P\"IIY\")[1]\n+ X__\n+ _Z_\n+ __Y\n\nSimilarly to project! on Stabilizer, this function has cubic complexity when the Pauli operator commutes with all rows of the tableau. Most of the time it is better to simply use MixedDestabilizer representation.\n\nUnlike other project! methods, this one does not allow for keep_result=false, as the correct rank or anticommutation index can not be calculated without the expensive (cubic) canonicalization operation required by keep_result=true.\n\nSee the \"Datastructure Choice\" section in the documentation for more details.\n\nSee also: projectX!, projectY!, projectZ!.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.projectX!-Tuple{MixedDestabilizer, Int64}","page":"API","title":"QuantumInterface.projectX!","text":"Measure a given qubit in the X basis. A faster special-case version of project!.\n\nSee also: project!, projectXrand!, projectY!, projectZ!.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.projectY!-Tuple{MixedDestabilizer, Int64}","page":"API","title":"QuantumInterface.projectY!","text":"Measure a given qubit in the Y basis. A faster special-case version of project!.\n\nSee also: project!, projectYrand!, projectX!, projectZ!.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.projectZ!-Tuple{MixedDestabilizer, Int64}","page":"API","title":"QuantumInterface.projectZ!","text":"Measure a given qubit in the Z basis. A faster special-case version of project!.\n\nSee also: project!, projectZrand!, projectY!, projectX!.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.reset_qubits!-Tuple{MixedDestabilizer, QuantumClifford.AbstractStabilizer, Any}","page":"API","title":"QuantumInterface.reset_qubits!","text":"reset_qubits!(\n    s::MixedDestabilizer,\n    newstate::QuantumClifford.AbstractStabilizer,\n    qubits;\n    phases\n) -> MixedDestabilizer\n\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.reset_qubits!-Tuple{MixedStabilizer, Any, Any}","page":"API","title":"QuantumInterface.reset_qubits!","text":"reset_qubits!(\n    s::MixedStabilizer,\n    newstate,\n    qubits;\n    phases\n) -> MixedStabilizer\n\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.reset_qubits!-Tuple{Stabilizer, Any, Any}","page":"API","title":"QuantumInterface.reset_qubits!","text":"reset_qubits!(\n    s::Stabilizer,\n    newstate,\n    qubits;\n    phases\n) -> Union{PauliOperator, Stabilizer}\n\n\nReset a given set of qubits to be in the state newstate. These qubits are traced out first, which could lead to \"nonlocal\" changes in the tableau.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.tensor","page":"API","title":"QuantumInterface.tensor","text":"Tensor product between operators or tableaux.\n\nTensor product between CiffordOperators:\n\njulia> tensor(CliffordOperator(sCNOT), CliffordOperator(sCNOT))\nX₁ ⟼ + XX__\nX₂ ⟼ + _X__\nX₃ ⟼ + __XX\nX₄ ⟼ + ___X\nZ₁ ⟼ + Z___\nZ₂ ⟼ + ZZ__\nZ₃ ⟼ + __Z_\nZ₄ ⟼ + __ZZ\n\nTensor product between PauliOperators:\n\njulia> tensor(P\"-IXYZ\", P\"iIXYZ\")\n-i_XYZ_XYZ\n\nTensor product between Tableaux:\n\njulia> s = S\"-XX\n             +ZZ\";\n\njulia> tensor(s, s, s)\n- XX____\n+ ZZ____\n- __XX__\n+ __ZZ__\n- ____XX\n+ ____ZZ\n\njulia> s = S\"+XZI\n             -IZI\";\n\njulia> tensor(s, s)\n+ XZ____\n- _Z____\n+ ___XZ_\n- ____Z_\n\nSee also tensor_pow.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumInterface.tensor-Tuple{Vararg{Union{PauliOperator, UnitaryPauliChannel}}}","page":"API","title":"QuantumInterface.tensor","text":"Tensor product between UnitaryPauliChannel and PauliOperator.\n\njulia> pcT ⊗ P\"X\"\nA unitary Pauli channel P = ∑ ϕᵢ Pᵢ with the following branches:\nwith ϕᵢ | Pᵢ\n 0.853553+0.353553im | + _X\n 0.146447-0.353553im | + ZX\n\njulia> pcT ⊗ pcT ⊗ P\"X\"\nA unitary Pauli channel P = ∑ ϕᵢ Pᵢ with the following branches:\nwith ϕᵢ | Pᵢ\n 0.603553+0.603553im | + __X\n 0.25-0.25im | + Z_X\n 0.25-0.25im | + _ZX\n -0.103553-0.103553im | + ZZX\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.tensor-Tuple{Vararg{Union{QuantumClifford.AbstractStabilizer, GeneralizedStabilizer}}}","page":"API","title":"QuantumInterface.tensor","text":"Tensor product between GeneralizedStabilizer and Stabilizer.\n\njulia> using LinearAlgebra; # hide\n\njulia> sm = GeneralizedStabilizer(ghz(2))\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z_\n+ _X\n𝒮𝓉𝒶𝒷\n+ XX\n+ ZZ\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 1.0+0.0im | + __ | + __\n\njulia> apply!(sm, embed(2, 2, pcT))\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z_\n+ _X\n𝒮𝓉𝒶𝒷\n+ XX\n+ ZZ\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 0.853553+0.0im | + __ | + __\n 0.0+0.353553im | + __ | + Z_\n 0.0-0.353553im | + Z_ | + __\n 0.146447+0.0im | + Z_ | + Z_\n\njulia> s = ghz(2)\n+ XX\n+ ZZ\n\njulia> newsm = sm ⊗ s\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z___\n+ _X__\n+ __Z_\n+ ___X\n𝒮𝓉𝒶𝒷━━\n+ XX__\n+ ZZ__\n+ __XX\n+ __ZZ\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 0.0+0.353553im | + ____ | + Z___\n 0.0-0.353553im | + Z___ | + ____\n 0.146447+0.0im | + Z___ | + Z___\n 0.853553+0.0im | + ____ | + ____\n\njulia> real(tr(newsm))\n1.0\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.tensor_pow-Tuple{Union{QuantumClifford.AbstractCliffordOperator, QuantumClifford.AbstractStabilizer}, Any}","page":"API","title":"QuantumInterface.tensor_pow","text":"Repeated tensor product of an operators or a tableau.\n\nFor CliffordOperator:\n\njulia> tensor_pow(CliffordOperator(sHadamard), 3)\nX₁ ⟼ + Z__\nX₂ ⟼ + _Z_\nX₃ ⟼ + __Z\nZ₁ ⟼ + X__\nZ₂ ⟼ + _X_\nZ₃ ⟼ + __X\n\nFor PauliOperator:\n\njulia> tensor_pow(P\"IXYZ\", 2)\n+ _XYZ_XYZ\n\nFor Tableaux:\n\njulia> tensor_pow(S\"Z\", 4)\n+ Z___\n+ _Z__\n+ __Z_\n+ ___Z\n\njulia> s = S\"+XZI\n             +IZI\";\n\njulia> tensor_pow(s, 3)\n+ XZ_______\n+ _Z_______\n+ ___XZ____\n+ ____Z____\n+ ______XZ_\n+ _______Z_\n\nSee also tensor.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.traceout!-Tuple{Stabilizer, Any}","page":"API","title":"QuantumInterface.traceout!","text":"traceout!(\n    s::Stabilizer,\n    qubits;\n    phases,\n    rank\n) -> Union{Tuple{Stabilizer, Int64}, Stabilizer}\n\n\nTrace out a qubit.\n\nSee also: delete_columns\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.traceout!-Tuple{Union{MixedDestabilizer, MixedStabilizer}, Any}","page":"API","title":"QuantumInterface.traceout!","text":"traceout!(\n    s::Union{MixedDestabilizer, MixedStabilizer},\n    qubits;\n    phases,\n    rank\n) -> Union{Tuple{Union{MixedDestabilizer, MixedStabilizer}, Int64}, MixedDestabilizer, MixedStabilizer}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#Private-API","page":"API","title":"Private API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"danger: Private Implementation Details\nThese functions are used internally by the library and might be drastically modified or deleted without warning or deprecation.","category":"page"},{"location":"API/#QuantumClifford.IP_SQRTX_DECOMPOSITION_TABLE","page":"API","title":"QuantumClifford.IP_SQRTX_DECOMPOSITION_TABLE","text":"A table mapping group members to the minimal representation in terms of the generators provided.\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumClifford.ISOLATED_CPHASE_TABLE","page":"API","title":"QuantumClifford.ISOLATED_CPHASE_TABLE","text":"A mapping\n\n(k, U₁, U₂) -> (m, U₁', U₂')\n\nwhere k, m ∈{0,1} such that\n\nCPHASE₁₂ U₁ ⊗ U₂ (CPHASE₁₂)ᵏ |++⟩ = U₁' ⊗ U₂' (CPHASE₁₂)ᵐ |++⟩\n\nand we guarantee if U1 ∈ ZCOMMUTATIONSUBGROUP then U1' ∈ ZCOMMUTATIONSUBGROUP. Same for U2, U2'.\n\nSee also apply_cphase_isolated and gen_isolated_cphase_table\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumClifford.PAULI_STABILIZERS","page":"API","title":"QuantumClifford.PAULI_STABILIZERS","text":"Stabilizers needed to convert between equivalent states to satisfy the commutation constraint (see apply_cphase_isolated)\n\ninfo: Large subgroup\nLuckily, to satisfy the commutation constraint we don't need the whole stabilizer subgroup which is quite big, but only a selected few.\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumClifford.SINGLE_QUBIT_MULTIPLICATION_TABLE","page":"API","title":"QuantumClifford.SINGLE_QUBIT_MULTIPLICATION_TABLE","text":"Single qubit operator multiplication table to speed up the _apply_vop!\n\nThe table consists of entries of the form (sX(1), sY(1)) -> sZ(1)\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumClifford.Z_COMMUTATION_SUBGROUP","page":"API","title":"QuantumClifford.Z_COMMUTATION_SUBGROUP","text":"The subgroup of single qubit Clifford group that commutes with CPHASE.\n\nSpecifically, this means Uᵢ * CPHASE₁₂ = CPHASE₁₂ * Uᵢ for all U ∈ ZCOMMUTATIONSUBGROUP and i ∈ {1,2}\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumClifford.AbstractMeasurement","page":"API","title":"QuantumClifford.AbstractMeasurement","text":"Supertype of all symbolic single-qubit measurements.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.AbstractResetMeasurement","page":"API","title":"QuantumClifford.AbstractResetMeasurement","text":"Supertype of all symbolic single-qubit reset measurements\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.SymbolicDataType","page":"API","title":"QuantumClifford.SymbolicDataType","text":"An intermediary when we want to create a new concrete type in a macro.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.Tableau","page":"API","title":"QuantumClifford.Tableau","text":"Internal Tableau type for storing a list of Pauli operators in a compact form. No special semantic meaning is attached to this type, it is just a convenient way to store a list of Pauli operators. E.g. it is not used to represent a stabilizer state, or a stabilizer group, or a Clifford circuit.\n\n\n\n\n\n","category":"type"},{"location":"API/#Base.:*-Tuple{UnitaryPauliChannel, GeneralizedStabilizer}","page":"API","title":"Base.:*","text":"Apply a UnitaryPauliChannel to a GeneralizedStabilizer state.\n\njulia> sm = GeneralizedStabilizer(S\"-X\")\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n- X\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 1.0+0.0im | + _ | + _\n\njulia> pcT*sm\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n- X\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 0.0+0.353553im | + _ | + Z\n 0.0-0.353553im | + Z | + _\n 0.853553+0.0im | + _ | + _\n 0.146447+0.0im | + Z | + Z\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.hcat-Tuple{Vararg{QuantumClifford.Tableau}}","page":"API","title":"Base.hcat","text":"Horizontally concatenates tableaux.\n\njulia> hcat(ghz(2), ghz(2))\n+ XXXX\n+ ZZZZ\n\nSee also: vcat\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.inv-Tuple{CliffordOperator}","page":"API","title":"Base.inv","text":"inv(\n    c::CliffordOperator;\n    phases\n) -> CliffordOperator{QuantumClifford.Tableau{P, XZ}, PauliOperator{P1, XZ1}} where {P<:(Vector{P} where P<:Unsigned), XZ<:(Matrix{T} where T<:Unsigned), P1<:(AbstractArray{<:Unsigned, 0}), XZ1<:(Vector{P} where P<:Unsigned)}\n\n\nInverse of a CliffordOperator\n\njulia> inv(CliffordOperator(sCNOT))\nX₁ ⟼ + XX\nX₂ ⟼ + _X\nZ₁ ⟼ + Z_\nZ₂ ⟼ + ZZ\n\njulia> inv(CliffordOperator(sCNOT(2, 1), 2))\nX₁ ⟼ + X_\nX₂ ⟼ + XX\nZ₁ ⟼ + ZZ\nZ₂ ⟼ + _Z\n\njulia> inv(CliffordOperator(tHadamard))\nX₁ ⟼ + Z\nZ₁ ⟼ + X\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.vcat-Tuple{Vararg{QuantumClifford.Tableau}}","page":"API","title":"Base.vcat","text":"Vertically concatenates tableaux.\n\njulia> vcat(ghz(2), ghz(2))\n+ XX\n+ ZZ\n+ XX\n+ ZZ\n\nSee also: hcat\n\n\n\n\n\n","category":"method"},{"location":"API/#LinearAlgebra.dot-Tuple{QuantumClifford.AbstractStabilizer, QuantumClifford.AbstractStabilizer}","page":"API","title":"LinearAlgebra.dot","text":"The inner product of two Stabilizers.\n\nBased on (Garcia et al., 2012).\n\njulia> using LinearAlgebra\n\njulia> dot(S\"Z\", S\"Z\")\n1.0\n\njulia> dot(S\"Z\", S\"Y\")\n0.7071067811865476\n\nSee also: logdot\n\n\n\n\n\n","category":"method"},{"location":"API/#LinearAlgebra.tr-Tuple{GeneralizedStabilizer}","page":"API","title":"LinearAlgebra.tr","text":"Compute the trace of a GeneralizedStabilizer state.\n\njulia> using QuantumClifford; using LinearAlgebra;\n\njulia> sm = GeneralizedStabilizer(S\"-X\");\n\njulia> apply!(sm, pcT)\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n- X\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 0.0+0.353553im | + _ | + Z\n 0.0-0.353553im | + Z | + _\n 0.853553+0.0im | + _ | + _\n 0.146447+0.0im | + Z | + Z\n\njulia> tr(sm)\n1.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford._allthreesumtozero-Tuple{Any, Any, Any}","page":"API","title":"QuantumClifford._allthreesumtozero","text":"Same as all(==(0), (a.+b.+c) .% 2)\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford._apply_nonthread!-Tuple{QuantumClifford.AbstractStabilizer, CliffordOperator, AbstractVector{Int64}}","page":"API","title":"QuantumClifford._apply_nonthread!","text":"Nonvectorized version of apply! used for unit tests.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford._apply_nonthread!-Tuple{QuantumClifford.AbstractStabilizer, CliffordOperator}","page":"API","title":"QuantumClifford._apply_nonthread!","text":"Nonvectorized version of apply! used for unit tests.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford._mul_left_nonvec!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:Unsigned","page":"API","title":"QuantumClifford._mul_left_nonvec!","text":"Nonvectorized version of mul_left! used for unit tests.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford._projectrand_notnorm-Tuple{GeneralizedStabilizer, PauliOperator, Int64}","page":"API","title":"QuantumClifford._projectrand_notnorm","text":"Returns the updated GeneralizedStabilizer state sm′ = (χ′, B(S′, D′)), where (S′, D′) is derived from (S, D) through the traditional stabilizer update, and χ′ is the updated density matrix after measurement. Note: Λ(χ′) ≤ Λ(χ).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford._remove_rowcol!-Tuple{MixedDestabilizer, Any, Any}","page":"API","title":"QuantumClifford._remove_rowcol!","text":"Unexported low-level function that removes a row (by shifting all rows up as necessary)\n\nBecause MixedDestabilizer is not mutable we return a new MixedDestabilizer with the same (modified) xzs array.\n\nUsed on its own, this function will break invariants. Meant to be used with projectremove!.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford._rowmove!-Union{Tuple{B}, Tuple{QuantumClifford.Tableau, Any, Any}} where B","page":"API","title":"QuantumClifford._rowmove!","text":"Unexported low-level function that moves row i to row j.\n\nUsed on its own, this function will break invariants. Meant to be used in _remove_rowcol!.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford._stim_prodphase-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:Unsigned","page":"API","title":"QuantumClifford._stim_prodphase","text":"The quantumlib/Stim implementation, which performs the prodphase and mul_left! together. Used for unit tests.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.apply_cphase_isolated-Tuple{Bool, SingleQubitOperator, SingleQubitOperator}","page":"API","title":"QuantumClifford.apply_cphase_isolated","text":"Given a 2-qubit graph state (characterized by VOPs U₁, U₂ and k∈{0,1}), find VOPs U₁', U₂', m∈{0,1} such that\n\nCPHASE₁₂ U₁ ⊗ U₂ (CPHASE₁₂)ᵏ |++⟩ = U₁' ⊗ U₂' (CPHASE₁₂)ᵐ |++⟩\n\nThe the following constraint is satisfied:\n\nif U1 ∈ ZCOMMUTATIONSUBGROUP then U1' ∈ ZCOMMUTATIONSUBGROUP. Same for U2, U2'.\n\nThis is done by applying stabilizer on the resulting state to change VOPs without changing the underlying quantum state. See also PAULI_STABILIZERS\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.apply_isolated_cphase_lookup_table!-Tuple{QuantumClifford.GraphState, Int64, Int64}","page":"API","title":"QuantumClifford.apply_isolated_cphase_lookup_table!","text":"A helper function that applies ISOLATED_CPHASE_TABLE.\n\nYou should make sure it's suitable to directly copy the result from lookup table. This is the case if either\n\nvertices are completely isolated\nVOPs of vertices which have non-operand neighbors are all in ZCOMMUTATIONSUBGROUP\n\nAn example of the second case is\n\nU₁ = sHadamard, U₂ = sInvPhase\n\nand q2 is connected to some other vertex while q1 has no neighbors except potentially q2.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.apply_right_row_kernel!-NTuple{5, Any}","page":"API","title":"QuantumClifford.apply_right_row_kernel!","text":"helper for computing the right multiplication of a row of a Clifford operator with another Clifford operator.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.apply_single_x!-Tuple{QuantumClifford.AbstractStabilizer, Any}","page":"API","title":"QuantumClifford.apply_single_x!","text":"Apply a Pauli X to the i-th qubit of state s. You should use apply!(stab,sX(i)) instead of this.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.apply_single_y!-Tuple{QuantumClifford.AbstractStabilizer, Any}","page":"API","title":"QuantumClifford.apply_single_y!","text":"Apply a Pauli Y to the i-th qubit of state s. You should use apply!(stab,sY(i)) instead of this.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.apply_single_z!-Tuple{QuantumClifford.AbstractStabilizer, Any}","page":"API","title":"QuantumClifford.apply_single_z!","text":"Apply a Pauli Z to the i-th qubit of state s. You should use apply!(stab,sZ(i)) instead of this.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.applynoise_branches","page":"API","title":"QuantumClifford.applynoise_branches","text":"Compute all possible new states after the application of the given noise model. Reports the probability of each one of them. Deterministic (as it reports all branches of potentially random processes), part of the Noise interface.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.colswap!-Tuple{QuantumClifford.Tableau, Any, Any}","page":"API","title":"QuantumClifford.colswap!","text":"Swap two columns of a stabilizer in place.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.decompose_into_generators-Tuple{AbstractSingleQubitOperator, Vector{<:AbstractSingleQubitOperator}}","page":"API","title":"QuantumClifford.decompose_into_generators","text":"Generate a table mapping group members to the minimal representation in terms of the generators provided.\n\nThe first argument is the identity element of the group. The second argument is a list of generators.\n\nFor example, decompose_into_generators(sId1(1), [sInvPhase(1), sSQRTX(1)]) generates a table in which the sY entry is sY(1) -> [sSQRTX(1), sSQRTX(1), sInvPhase(1), sInvPhase(1)] which means Y = sInvPhase * sInvPhase * sSQRTX * sSQRTX\n\nThe function uses a brute-force, dynamic programming based approach on finding minimal representation (decomposition) of any group elements in terms of the generators provided.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.destab_looks_good-Tuple{Any}","page":"API","title":"QuantumClifford.destab_looks_good","text":"Check basic consistency requirements of a destabilizer. Used in tests.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.enumerate_cliffords_slow-Tuple{Any, Any}","page":"API","title":"QuantumClifford.enumerate_cliffords_slow","text":"The O(n^4) implementation from (Koenig and Smolin, 2014) – their algorithm seems wrong as ⟨w'₁|wₗ⟩=bₗ which is not always zero.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.fill_tril-Tuple{Random.AbstractRNG, Any, Any}","page":"API","title":"QuantumClifford.fill_tril","text":"Assign (symmetric) random ints to off diagonals of matrix.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.gen_graph_state-Tuple{Bool, SingleQubitOperator, SingleQubitOperator}","page":"API","title":"QuantumClifford.gen_graph_state","text":"Generate a 2-qubit graph state from the graph (represented by whether vertices are connected) and two VOPs\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.gen_isolated_cphase_table-Tuple{}","page":"API","title":"QuantumClifford.gen_isolated_cphase_table","text":"Generate a lookup table for isolated two qubits CPHASE gate operation\n\nSpecifically, this creates a mapping\n\n(k, U₁, U₂) -> (m, U₁', U₂')\n\nwhere k, m ∈{0,1} such that\n\nCPHASE₁₂ U₁ ⊗ U₂ (CPHASE₁₂)ᵏ |++⟩ = U₁' ⊗ U₂' (CPHASE₁₂)ᵐ |++⟩\n\nand we guarantee if U1 ∈ ZCOMMUTATIONSUBGROUP then U1' ∈ ZCOMMUTATIONSUBGROUP. Same for U2, U2'.\n\nSee also ISOLATED_CPHASE_TABLE and gen_isolated_cphase_table\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.gen_single_qubit_multiplication_table-Tuple{}","page":"API","title":"QuantumClifford.gen_single_qubit_multiplication_table","text":"Generate a single qubit operator multiplication table\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.get_all_subtypes-Tuple{Any}","page":"API","title":"QuantumClifford.get_all_subtypes","text":"Returns a tuple of all concrete subtypes and all UnionAll non-abstract subtypes of a given type.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.get_bitmask_idxs-Tuple{AbstractArray{<:Unsigned}, Int64}","page":"API","title":"QuantumClifford.get_bitmask_idxs","text":"get_bitmask_idxs(\n    xzs::AbstractArray{<:Unsigned},\n    i::Int64\n) -> Tuple{Any, Int64, Int64, Any}\n\n\nComputes bitmask indices for an unsigned integer at index i within the binary structure of a Tableau or PauliOperator.\n\nFor Tableau, the method operates on the .xzs field, while for PauliOperator, it uses the .xz field. It calculates the following values based on the index i:\n\nlowbit, the lowest bit.\nibig, the index of the word containing the bit.\nismall, the position of the bit within the word.\nismallm, a bitmask isolating the specified bit.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.gf2_H_standard_form_indices-Tuple{Any}","page":"API","title":"QuantumClifford.gf2_H_standard_form_indices","text":"The permutation of columns which turns a binary matrix into standard form. It is assumed the matrix has already undergone Gaussian elimination.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.gf2_nullspace-Tuple{AbstractMatrix{Int64}}","page":"API","title":"QuantumClifford.gf2_nullspace","text":"The nullspace of a binary matrix.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.gf2_row_echelon_with_pivots!-Tuple{AbstractMatrix{Int64}}","page":"API","title":"QuantumClifford.gf2_row_echelon_with_pivots!","text":"Performs in-place Gaussian elimination on a binary matrix and returns its row echelon form,rank, the transformation matrix, and the pivot columns. The transformation matrix that converts the original matrix into the row echelon form. The full parameter controls the extent of elimination: if true, only rows below the pivot are affected; if false, both above and below the pivot are eliminated.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.gf2_rowspace_basis-Tuple{AbstractMatrix{Int64}}","page":"API","title":"QuantumClifford.gf2_rowspace_basis","text":"The basis for the row space of the binary matrix.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.graph-Tuple{QuantumClifford.GraphState}","page":"API","title":"QuantumClifford.graph","text":"Return the underlying graph of the graph state\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.initZ!-Tuple{PauliFrame}","page":"API","title":"QuantumClifford.initZ!","text":"initZ!(frame::PauliFrame) -> PauliFrame\n\n\nInject random Z errors over all frames and qubits for the supplied PauliFrame with probability 0.5.\n\nCalling this after initialization is essential for simulating any non-deterministic circuit. It is done automatically by most PauliFrame constructors.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.invsparsity","page":"API","title":"QuantumClifford.invsparsity","text":"Calculates the number of non-zero elements in the density matrix χ of a GeneralizedStabilizer, representing the inverse sparsity of χ. It provides a measure of the state's complexity, with bounds Λ(χ) ≤ 4ⁿ.\n\njulia> using QuantumClifford: invsparsity; # hide\n\njulia> sm = GeneralizedStabilizer(S\"X\")\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n+ X\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 1.0+0.0im | + _ | + _\n\njulia> apply!(sm, pcT) |> invsparsity\n4\n\nSimilarly, it calculates the number of non-zero elements in the density matrix ϕᵢⱼ​ of a PauliChannel, providing a measure of the channel complexity.\n\njulia> invsparsity(pcT)\n4\n\nSee also: GeneralizedStabilizer\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.local_comp!-Tuple{Any, Int64}","page":"API","title":"QuantumClifford.local_comp!","text":"Perform local complementation on pure graph\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.local_comp!-Tuple{QuantumClifford.GraphState{G, SingleQubitOperator} where G, Int64}","page":"API","title":"QuantumClifford.local_comp!","text":"Perform local complementation about index id while maintaining the represented quantum state unchanged.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.make_sumtype-Tuple{Any}","page":"API","title":"QuantumClifford.make_sumtype","text":"julia> make_sumtype([sCNOT])\nquote\n    @sum_type CompactifiedGate :hidden begin\n        sCNOT(::Int64, ::Int64)\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.make_sumtype_method","page":"API","title":"QuantumClifford.make_sumtype_method","text":"``` julia> makesumtypemethod([sCNOT], :apply!, (:s,)) quote     function QuantumClifford.apply!(s, g::CompactifiedGate)         @cases g begin             sCNOT(q1, q2) => apply!(s, sCNOT(q1, q2))         end     end end\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.make_sumtype_variant_constructor-Tuple{Any}","page":"API","title":"QuantumClifford.make_sumtype_variant_constructor","text":"julia> make_sumtype_variant_constructor(sCNOT)\n:(CompactifiedGate(g::sCNOT) = begin\n    (CompactifiedGate').sCNOT(g.q1, g.q2)\nend)\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.make_variant-Tuple{Union{DataType, QuantumClifford.SymbolicDataType}}","page":"API","title":"QuantumClifford.make_variant","text":"julia> make_variant(sCNOT)\n:(sCNOT(::Int64, ::Int64))\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.make_variant_deconstruct","page":"API","title":"QuantumClifford.make_variant_deconstruct","text":"julia> make_variant_deconstruct(sCNOT, :apply!, (:s,))\n:(sCNOT(q1, q2) => apply!(s, sCNOT(q1, q2)))\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.mixed_destab_looks_good-Tuple{Any}","page":"API","title":"QuantumClifford.mixed_destab_looks_good","text":"Check basic consistency requirements of a mixed destabilizer. Used in tests.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.mixed_stab_looks_good-Tuple{Any}","page":"API","title":"QuantumClifford.mixed_stab_looks_good","text":"Check basic consistency requirements of a mixed stabilizer. Used in tests.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.mul_right_ignore_anticomm!-Union{Tuple{B}, Tuple{QuantumClifford.Tableau, Any, QuantumClifford.Tableau, Any}} where B","page":"API","title":"QuantumClifford.mul_right_ignore_anticomm!","text":"Multiply Pauli operators l * r, ignoring anticommutation phases (keeping only ±1, not ±i)\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.pfmeasurement","page":"API","title":"QuantumClifford.pfmeasurement","text":"For a given simulated state, e.g. a PauliFrame instance, returns the measurement results.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.precise_inv-Tuple{Any}","page":"API","title":"QuantumClifford.precise_inv","text":"Inverting a binary matrix: uses floating point for small matrices and Nemo for large matrices.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.project_cond!-Union{Tuple{PHASES}, Tuple{RESET}, Tuple{IS}, Tuple{MixedDestabilizer, Int64, Val{IS}, Val{RESET}}} where {IS, RESET, PHASES}","page":"API","title":"QuantumClifford.project_cond!","text":"Internal method used to implement projectX!, projectZ!, and projectY!.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.projectremoverand!-Union{Tuple{F}, Tuple{MixedDestabilizer, F, Any}} where F<:Union{typeof(projectX!), typeof(projectY!), typeof(projectZ!)}","page":"API","title":"QuantumClifford.projectremoverand!","text":"Unexported low-level function that projects a qubit and returns the result while making the tableau smaller by a qubit.\n\nBecause MixedDestabilizer is not mutable we return a new MixedDestabilizer with the same (modified) xzs array.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.quantum_mallows-Tuple{Random.AbstractRNG, Int64}","page":"API","title":"QuantumClifford.quantum_mallows","text":"Sample (h, S) from the distribution P_n(h, S) from Bravyi and Maslov Algorithm 1.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.random_tableau","page":"API","title":"QuantumClifford.random_tableau","text":"A random tableau with r rows on n qubits, suitable for bulk sampling.\n\nEach row is equivalent to an instance of random_pauli without any additional commutativity constraints. For proper states, consider utilising random_stabilizer or random_destabilizer as necessary.\n\nUse nophase=false to randomize the phase. Use realphase=false to get operators with phases including ±i.\n\nOptionally, a \"flip\" probability p can be provided specified, in which case each bit is set to I with probability 1-p and to X or Y or Z with probability p. Useful for simulating unbiased Pauli noise.\n\nSee also random_tableau!\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.random_tableau!","page":"API","title":"QuantumClifford.random_tableau!","text":"An in-place version of random_tableau\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.remove_column!-Union{Tuple{M}, Tuple{T}, Tuple{V}, Tuple{QuantumClifford.Tableau{V, M}, Int64}} where {V, T<:Unsigned, M<:AbstractMatrix{T}}","page":"API","title":"QuantumClifford.remove_column!","text":"Unexported low-level function that removes a column (by shifting all columns to the right of the target by one step to the left)\n\nBecause Tableau is not mutable we return a new Tableau with the same (modified) xzs array.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.remove_vop!-Tuple{QuantumClifford.GraphState, Int64, Int64}","page":"API","title":"QuantumClifford.remove_vop!","text":"Perform Local Complementation repeatedly to transfer the VOP of src to the target.\n\nSee also local_comp!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.rowdecompose-Tuple{Any, Union{Destabilizer, MixedDestabilizer}}","page":"API","title":"QuantumClifford.rowdecompose","text":"Decompose a Pauli P in terms of stabilizer and destabilizer rows from a given tableaux.\n\nFor given tableaux of rows destabilizer rows d_i and stabilizer rows s_i, there are boolean vectors b and c such that P = i^p prod_i d_i^b_i prod_i s_i^c_i.\n\nThis function returns p, b, c.\n\njulia> s = MixedDestabilizer(ghz(2))\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z_\n+ _X\n𝒮𝓉𝒶𝒷\n+ XX\n+ ZZ\n\njulia> phase, destab_rows, stab_rows = QuantumClifford.rowdecompose(P\"XY\", s)\n(3, Bool[1, 0], Bool[1, 1])\n\njulia> im^3 * P\"Z_\" * P\"XX\" * P\"ZZ\"\n+ XY\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.sample_geometric_2-Tuple{Random.AbstractRNG, Integer}","page":"API","title":"QuantumClifford.sample_geometric_2","text":"This function samples a number from 1 to n where n >= 1 probability of outputting i is proportional to 2^i\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.stab_looks_good-Tuple{Any}","page":"API","title":"QuantumClifford.stab_looks_good","text":"Check basic consistency requirements of a stabilizer. Used in tests.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.to_cpu","page":"API","title":"QuantumClifford.to_cpu","text":"copies the memory content of the object to CPU\n\nYou can only use this function if CUDA.jl is imported\n\nFor more advanced users to_cpu(data, element_type) will reinterpret elements of data and converts them to element_type. For example based on your CPU architecture, if working with matrices of UInt32 is faster than UInt64, you can use to_cpu(data, UInt32)\n\njulia> using QuantumClifford: to_cpu, to_gpu\n\njulia> using CUDA # without this import, to_cpu, to_gpu are just function\n\njulia> stab = S\"- X_Z\\n+ _ZZ\\n+ __Z\"\n- X_Z\n+ _ZZ\n+ __Z\n\njulia> stab_gpu = to_gpu(stab);\n\njulia> apply!(stab_gpu, sHadamard(1));\n\njulia> stab_result_cpu = to_cpu(stab_gpu)\n- Z_Z\n+ _ZZ\n+ __Z\n\njulia> using QuantumClifford: to_cpu, to_gpu\n\njulia> using CUDA # without this import, to_cpu, to_gpu are just function\n\njulia> pf_gpu = to_gpu(PauliFrame(1000, 2, 2));\njulia> circuit = [sMZ(1, 1), sHadamard(2), sMZ(2, 2)];\njulia> pftrajectories(pf_gpu, circuit);\njulia> measurements = to_cpu(pf_gpu.measurements);\n\nSee also: to_gpu\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.to_gpu","page":"API","title":"QuantumClifford.to_gpu","text":"copies the memory content of the object to GPU\n\nYou can only use this function if CUDA.jl is imported\n\nFor more advanced users to_gpu(data, element_type) will reinterpret elements of data and converts them to element_type. For example based on your GPU architecture, if working with matrices of UInt64 is faster than UInt32, you can use to_gpu(data, UInt64)\n\njulia> using QuantumClifford: to_cpu, to_gpu\n\njulia> using CUDA # without this import, to_cpu, to_gpu are just function\n\njulia> stab = S\"- X_Z\\n+ _ZZ\\n+ __Z\"\n- X_Z\n+ _ZZ\n+ __Z\n\njulia> stab_gpu = to_gpu(stab);\n\njulia> apply!(stab_gpu, sHadamard(1));\n\njulia> stab_result_cpu = to_cpu(stab_gpu)\n- Z_Z\n+ _ZZ\n+ __Z\n\njulia> using QuantumClifford: to_cpu, to_gpu\n\njulia> using CUDA # without this import, to_cpu, to_gpu are just function\n\njulia> pf_gpu = to_gpu(PauliFrame(1000, 2, 2));\njulia> circuit = [sMZ(1, 1), sHadamard(2), sMZ(2, 2)];\njulia> pftrajectories(pf_gpu, circuit);\njulia> measurements = to_cpu(pf_gpu.measurements);\n\nSee also: to_cpu\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.toggle_edge!-Tuple{Any, Int64, Int64}","page":"API","title":"QuantumClifford.toggle_edge!","text":"Toggle the edge of a graph between vertices v1 and v2.\n\nUses rem_edge! and add_edge!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.trusted_rank","page":"API","title":"QuantumClifford.trusted_rank","text":"A \"trusted\" rank which returns rank(state) for Mixed[De]Stabilizer and length(state) for [De]Stabilizer.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.vops-Tuple{QuantumClifford.GraphState}","page":"API","title":"QuantumClifford.vops","text":"Return the VOPs (Vertex Operators) of the graph state\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.zero!-Union{Tuple{PauliOperator{P, XZ}}, Tuple{XZ}, Tuple{P}} where {P, XZ}","page":"API","title":"QuantumClifford.zero!","text":"Zero-out the phases and single-qubit operators in a PauliOperator\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.zero!-Union{Tuple{XZ}, Tuple{P}, Tuple{QuantumClifford.Tableau{P, XZ}, Any}} where {P, XZ}","page":"API","title":"QuantumClifford.zero!","text":"Zero-out a given row of a Tableau\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.@qubitop1-Tuple{Any, Any, Any}","page":"API","title":"QuantumClifford.@qubitop1","text":"Macro used to define single qubit symbolic gates and their qubit_kernel methods.\n\n\n\n\n\n","category":"macro"},{"location":"API/#QuantumClifford.@qubitop2-Tuple{Any, Any, Any}","page":"API","title":"QuantumClifford.@qubitop2","text":"Macro used to define 2-qubit symbolic gates and their qubit_kernel methods.\n\n\n\n\n\n","category":"macro"},{"location":"API/#QuantumClifford.@valbooldispatch-Tuple{Any, Vararg{Any}}","page":"API","title":"QuantumClifford.@valbooldispatch","text":"Turns f(Val(x)) into x ? f(Val(true)) : f(Val(false)) in order to avoid dynamic dispatch\n\nSee discourse discussion\n\n\n\n\n\n","category":"macro"},{"location":"mixed/#Mixed-Stabilizer-States","page":"Mixed States","title":"Mixed Stabilizer States","text":"","category":"section"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"The Stabilizer and Destabilizer have some support for mixed states (by being initialized with an incomplete list of stabilizer generators), but for most purposes one would use the Mixed* data structures.","category":"page"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"Mixed stabilizer states are implemented with MixedStabilizer and MixedDestabilizer, the latter of which is the preferred data structure for most tasks as it is much faster by virtue of tracking the destabilizer generators.","category":"page"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"julia> s = S\"XXX\n             IZZ\";\n\njulia> Destabilizer(s)\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z__\n+ _X_\n𝒮𝓉𝒶𝒷━\n+ XXX\n+ _ZZ","category":"page"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"Unlike Destabilizer, MixedDestabilizer also tracks the logical operation generators.","category":"page"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"julia> m = MixedDestabilizer(s)\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z__\n+ _X_\n𝒳ₗ━━━\n+ _XX\n𝒮𝓉𝒶𝒷━\n+ XXX\n+ _ZZ\n𝒵ₗ━━━\n+ Z_Z\n\njulia> stabilizerview(m)\n+ XXX\n+ _ZZ\n\njulia> destabilizerview(m)\n+ Z__\n+ _X_\n\njulia> logicalxview(m)\n+ _XX\n\njulia> logicalzview(m)\n+ Z_Z","category":"page"},{"location":"mixed/#Gottesman-Canonicalization","page":"Mixed States","title":"Gottesman Canonicalization","text":"","category":"section"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"To obtain the logical operators we perform a different type of canonicalization, described in Gottesman's thesis and implemented in canonicalize_gott!. Unlike canonicalize! which uses only row operations, canonicalize_gott! performs column swaps as well. MixedDestabilizer undoes those swaps by default when instantiated, but that behavior can be turned off, if you prefer to work with the canonicalized tableau.","category":"page"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"julia> s = S\"XXX\n             ZIZ\";\n\njulia> MixedDestabilizer(s)\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z__\n+ __X\n𝒳ₗ━━━\n+ _X_\n𝒮𝓉𝒶𝒷━\n+ XXX\n+ Z_Z\n𝒵ₗ━━━\n+ ZZ_\n\njulia> MixedDestabilizer(s; undoperm=false)\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z__\n+ _X_\n𝒳ₗ━━━\n+ __X\n𝒮𝓉𝒶𝒷━\n+ XXX\n+ ZZ_\n𝒵ₗ━━━\n+ Z_Z","category":"page"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"Destabilizer and MixedStabilizer do not use any column swaps on instantiation as they do not track the logical operators.","category":"page"},{"location":"datastructures/#Data-Structures-Options","page":"Datastructure Choice","title":"Data Structures Options","text":"","category":"section"},{"location":"datastructures/#Choosing-Appropriate-Data-Structure","page":"Datastructure Choice","title":"Choosing Appropriate Tableau Data Structure","text":"","category":"section"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"There are four different data structures used to represent stabilizer states. If you will never need projective measurements you probably would want to use Stabilizer. If you require projective measurements, but only on pure states, Destabilizer should be the appropriate data structure. If mixed stabilizer states are involved, MixedStabilizer would be necessary.","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"Stabilizer is simply a list of Pauli operators in a tableau form. As a data structure it does not enforce the requirements for a pure stabilizer state (the rows of the tableau do not necessarily commute, nor are they forced to be Hermitian; the tableau might be underdetermined, redundant, or contradictory). It is up to the user to ensure that the initial values in the tableau are meaningful and consistent.","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"canonicalize!, project!, and generate! can accept an under determined (mixed state) Stabilizer instance and operate correctly. canonicalize! can also accept a redundant Stabilizer (i.e. not all rows are independent), leaving as many identity rows at the bottom of the canonicalized tableau as the number of redundant stabilizers in the initial tableau.","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"canonicalize! takes mathcalO(n^3) steps. generate! expects a canonicalized input and then takes mathcalO(n^2) steps. project! takes mathcalO(n^3) for projecting on commuting operators due to the need to call canonicalize! and generate!. If the projections is on an anticommuting operator (or if keep_result=false) then it takes mathcalO(n^2) steps.","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"MixedStabilizer provides explicit tracking of the rank of the mixed state and works properly when the projection is on a commuting operator not in the stabilizer (see table below for details). Otherwise it has the same performance as Stabilizer.","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"The canonicalization can be made unnecessary if we track the destabilizer generators. There are two data structures capable of that.","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"Destabilizer stores both the destabilizer and stabilizer states. project! called on it never requires a stabilizer canonicalization, hence it runs in mathcalO(n^2). However, project! will raise an exception if you try to project on a commuting state that is not in the stabilizer as that would be an expensive mathcalO(n^3) operation.","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"MixedDestabilizer tracks both the destabilizer operators and the logical operators in addition to the stabilizer generators. It does not require canonicalization for measurements and its project! operations always takes mathcalO(n^2).","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"For the operation _, anticom_index, result = project!(...) we have the following behavior:","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"projection Stabilizer MixedStabilizer Destabilizer MixedDestabilizer\non anticommuting operator anticom_index>0 result===nothing correct result in mathcalO(n^2) steps same as Stabilizer same as Stabilizer same as Stabilizer\non commuting operator in the stabilizer anticom_index==0 result!==nothing mathcalO(n^3); or mathcalO(n^2) if keep_result=false mathcalO(n^3) mathcalO(n^2) if the state is pure, throws exception otherwise mathcalO(n^2)\non commuting operator out of the stabilizer[1]  anticom_index==rank result===nothing mathcalO(n^3), but the user needs to manually include the new operator to the stabilizer; or mathcalO(n^2) if keep_result=false but then result indistinguishable from cell above and anticom_index==0 mathcalO(n^3) and rank goes up by one not applicable if the state is pure, throws exception otherwise mathcalO(n^2) and rank goes up by one","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"Notice the results when the projection operator commutes with the state but is not generated by the stabilizers of the state (the last row of the table). In that case we have _, anticom_index, result = project!(...) where both anticom_index==rank and result===nothing, with rank being the new rank after projection, one more than the number of rows in the tableau before the measurement. ","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"[1]: This can occur only if the state being projected is mixed. Both Stabilizer and Destabilizer can be used for mixed states by simply providing fewer stabilizer generators than qubits at initialization. This can be useful for low-level code that tries to avoid the extra memory cost of using MixedStabilizer and MixedDestabilizer but should be avoided otherwise. project! works correctly or raises an explicit warning on all 4 data structures.","category":"page"},{"location":"datastructures/#Bit-Packing-in-Integers-and-Array-Order","page":"Datastructure Choice","title":"Bit Packing in Integers and Array Order","text":"","category":"section"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"We do not use boolean arrays to store information about the qubits as this would be wasteful (7 out of 8 bits in the boolean would be unused). Instead, we use all 8 qubits in a byte and perform bitwise logical operations as necessary. Implementation details of the object in RAM can matter for performance. The library permits any of the standard UInt types to be used for packing the bits, and larger UInt types (like UInt64) are usually faster as they permit working on 64 qubits at a time (instead of 1 if we used a boolean, or 8 if we used a byte).","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"Moreover, how a tableau is stored in memory can affect performance, as a row-major storage usually permits more efficient use of the CPU cache (for the particular algorithms we use).","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"Both of these parameters are benchmarked (testing the application of a Pauli operator, which is an mathcalO(n^2) operation; and testing the canonicalization of a Stabilizer, which is an mathcalO(n^3) operation). Row-major UInt64 is the best performing and it is  used by default in this library.","category":"page"},{"location":"noisycircuits_ops/#noisycircuits_ops","page":"Circuit Operations","title":"Operators in Circuit Simulations","text":"","category":"section"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"warning: Unstable\nThis is experimental functionality with an unstable API.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"Import with using QuantumClifford.Experimental.NoisyCircuits.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"Too see a condensed list of all operations check out the API docs.","category":"page"},{"location":"noisycircuits_ops/#Unitary-Gates","page":"Circuit Operations","title":"Unitary Gates","text":"","category":"section"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"We distinguish between symbolic gates like sCNOT that have specialized (fast) apply! methods (usually just for single and two qubit gates) and general tableau representation of gates like CliffordOperator that can represent any multi-qubit gate.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"Predefined unitary gates are available, like sCNOT, sHadamard, etc.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"using QuantumClifford # hide\nusing QuantumClifford.Experimental.NoisyCircuits # hide\nusing Quantikz # hide\n[sCNOT(2,4),sHadamard(2),sCPHASE(1,3),sSWAP(2,4)]","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"Any arbitrary tableaux can be used as a gate too. ","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"They can be specified by giving a Clifford operator tableaux and the indices on which it acts (particularly useful for gates acting on a small part of a circuit):","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"using QuantumClifford # hide\nusing QuantumClifford.Experimental.NoisyCircuits # hide\nusing Quantikz # hide\nSparseGate(tCNOT, [2,4])","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"The Clifford operator tableaux can be completely arbitrary.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"SparseGate(random_clifford(3), [2,4,5])","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"If the Clifford operator acts on all qubits, we do not need to specify indices, just use the operator.","category":"page"},{"location":"noisycircuits_ops/#Noisy-Gates","page":"Circuit Operations","title":"Noisy Gates","text":"","category":"section"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"Each gate can be followed by noise applied to the qubits on which it has acted. This is done by wrapping the given gate into a NoisyGate","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"ε = 0.03 # X/Y/Z error probability\nnoise = UnbiasedUncorrelatedNoise(ε)\nnoisy_gate = NoisyGate(SparseGate(tCNOT, [2,4]), noise)","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"In circuit diagrams the noise is not depicted, but after each application of the gate defined in noisy_gate, a noise operator will also be applied. The example above is of Pauli Depolarization implemented by UnbiasedUncorrelatedNoise.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"One can also apply only the noise operator by using NoiseOp which acts only on specified qubits. Or alternatively, one can use NoiseOpAll in order to apply noise to all qubits.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"[NoiseOp(noise, [4,5]), NoiseOpAll(noise)]","category":"page"},{"location":"noisycircuits_ops/#Coincidence-Measurements","page":"Circuit Operations","title":"Coincidence Measurements","text":"","category":"section"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"Global parity measurements involving single-qubit projections and classical communication are implemented with BellMeasurement. One needs to specify the axes of measurement and the qubits being measured. If the parity is trivial, the circuit continues, if the parity is non-trivial, the circuit ends and reports a detected failure. This operator is frequently used in the simulation of entanglement purification.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"BellMeasurement([sMX(1), sMY(3), sMZ(4)])","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"There is also NoisyBellMeasurement that takes the bit-flip probability of a single-qubit measurement as a third argument.","category":"page"},{"location":"noisycircuits_ops/#Stabilizer-Measurements","page":"Circuit Operations","title":"Stabilizer Measurements","text":"","category":"section"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"A measurement over one or more qubits can also be performed, e.g., a direct stabilizer measurement on multiple qubits without the use of ancillary qubits. When applied to multiple qubits, this differs from BellMeasurement as it performs a single projection, unlike BellMeasurement which performs a separate projection for every single qubit involved. This measurement is implemented in PauliMeasurement which requires a Pauli operator on which to project and the index of the classical bit in which to store the result. Alternatively, there are sMX, sMZ, sMY if you are measuring a single qubit.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"[PauliMeasurement(P\"XYZ\", 1), sMZ(2, 2)]","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"TODO: SparseMeasurement, NoisyMeasurement","category":"page"},{"location":"noisycircuits_ops/#Verification-Operations","page":"Circuit Operations","title":"Verification Operations","text":"","category":"section"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"At the end of many circuits one might want to check whether they performed correctly. The VerifyOp operation corresponds to an unphysical perfect tomographic operation, checking whether the state of the qubits at the given indices is indeed what is expected. If it is, the operation reports a success, otherwise it reports an undetected error.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"desired_state = random_stabilizer(5)\nqubit_indices = [1,2,3,4,7]\nVerifyOp(desired_state, qubit_indices)","category":"page"},{"location":"noisycircuits_ops/#Reset-Operations","page":"Circuit Operations","title":"Reset Operations","text":"","category":"section"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"The Reset operations lets you trace out the specified qubits and set their state to a specific tableau.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"new_state = random_stabilizer(3)\nqubit_indices = [1,2,3]\nReset(new_state, qubit_indices)","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"It can be done anywhere in a circuit, not just at the beginning.","category":"page"},{"location":"noisycircuits_ops/#Gates-Conditioned-on-Classical-Bits","page":"Circuit Operations","title":"Gates Conditioned on Classical Bits","text":"","category":"section"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"ConditionalGate is a conditional gate that performs one of two provided gates, depending on the value of a given classical bit.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"DecisionGate is a conditional gate that performs one of the supplied gates, depending on the output of decisionfunction applied to the entire classical bit register.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"gate1 = SparseGate(tCNOT,   [1,2])\ngate2 = sCPHASE(1,2)\ngate3 = SparseGate(tSWAP,   [1,3])\ncg = ConditionalGate(gate1, gate2, 2)\ndg = DecisionGate([gate1,gate2,gate3], bit_register->1) # it will always perform gate1\n[sMX(4,1), sMZ(5,2), cg, dg]","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"TODO: Split ConditionalGate into quantum conditional and classical conditional","category":"page"},{"location":"plotting/#Visualizations","page":"Visualizations","title":"Visualizations","text":"","category":"section"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"Stabilizers have a plot recipe that can be used with Plots.jl or Makie.jl. It simply displays the corresponding parity check matrix (extracted with stab_to_gf2) as a bitmap image. Circuits can be visualized with Quantikz.jl.","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"Importing the aforementioned packages together with QuantumClifford is necessary to enable the plotting functionality (implemented as package extensions).","category":"page"},{"location":"plotting/#Plots.jl","page":"Visualizations","title":"Plots.jl","text":"","category":"section"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"In Plots.jl we have a simple recipe plot(s::Stabilizer; xzcomponents=...) where xzcomponents=:split plots the tableau heatmap in a wide form, X bits on the left, Z bits on the right; or xzcomponents=:together plots them overlapping, with different colors for I, X, Z, and Y.","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"using QuantumClifford, Plots\nplot(random_stabilizer(20,30), xzcomponents=:split)","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"using QuantumClifford, Plots\nplot(canonicalize!(random_stabilizer(20,30)))","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"using QuantumClifford, Plots\nplot(canonicalize_gott!(random_stabilizer(30))[1], xzcomponents=:split)","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"using QuantumClifford, Plots\nplot(canonicalize_gott!(random_stabilizer(30))[1]; xzcomponents=:together)","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"using QuantumClifford, Plots\nplot(canonicalize_rref!(random_stabilizer(20,30),1:30)[1]; xzcomponents=:together)","category":"page"},{"location":"plotting/#Makie.jl","page":"Visualizations","title":"Makie.jl","text":"","category":"section"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"Makie's heatmap can be directly called on Stabilizer.","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"using QuantumClifford, CairoMakie\ns = S\"IIXZ\n      ZZIZ\n      YYIZ\n      IIIZ\n      ZZXZ\"\nf, ax, p = CairoMakie.heatmap(s)\nhidedecorations!(ax); hidespines!(ax); # remove ticks and spines\nax.aspect = DataAspect(); # set a one-to-one aspect ratio\nf","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"A full Makie recipe is available as well (supporting xzcomponents)","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"using QuantumClifford, CairoMakie\ns = S\"IIXZ\n      ZZIZ\n      YYIZ\n      IIIZ\n      ZZXZ\"\nf, ax, p = stabilizerplot(s, xzcomponents=:together)\nhidedecorations!(ax); hidespines!(ax)\nax.aspect = DataAspect()\nf","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"You can easily add colorbars (and change the colormap) as well:","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"using QuantumClifford, CairoMakie\nfig = Figure()\nax, p = stabilizerplot(fig[1, 1], s, colormap=cgrad(:heat, 4, categorical = true))\nhidedecorations!(ax)\nhidespines!(ax)\nxlims!(ax, 0.5, size(s,2)+0.5) # otherwise there is padding\nylims!(ax, 0.5, size(s,1)+0.5) # otherwise there is padding\n# set the aspect ratio of the plot\nax.aspect = DataAspect()\n# set the aspect ratio of the layout\ncolsize!(fig.layout, 1, Aspect(1, size(s,2)/size(s,1))) \nColorbar(fig[1, 2], p, ticks = (0:3, [\"I\", \"X\", \"Z\", \"Y\"]))\nfig","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"Or set a completely custom set of colors:","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"fig = Figure()\nax, p = stabilizerplot(fig[1, 1], s, colormap=cgrad([:lightgray,RGBf(1,0.4,0.4),RGBf(0.3,1,0.5),RGBf(0.4,0.4,1)], 4, categorical = true))\nhidedecorations!(ax)\nhidespines!(ax)\nxlims!(ax, 0.5, size(s,2)+0.5)\nylims!(ax, 0.5, size(s,1)+0.5)\nax.aspect = DataAspect()\ncolsize!(fig.layout, 1, Aspect(1, size(s,2)/size(s,1))) \nColorbar(fig[2, 1], p, ticks = (0:3, [\"I\", \"X\", \"Z\", \"Y\"]), vertical = false, flipaxis = false)\nfig","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"You might have noticed, Makie recipes do not let you edit the axes or figure, rather they only permit you to set the plot content. Which is why we use hidedecorations!, hidesplines!, and DataAspect to further modify the plot. However, these defaults are also available in stabilizerplot_axis.","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"using QuantumClifford, CairoMakie\nf=Figure()\nstabilizerplot_axis(f[1,1],random_stabilizer(100))\nf","category":"page"},{"location":"plotting/#Quantikz.jl","page":"Visualizations","title":"Quantikz.jl","text":"","category":"section"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"With the Quantikz library you can visualize gates or sequences of gates.","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"using QuantumClifford, Quantikz\ncircuit = [sCNOT(1,2), SparseGate(random_clifford(4), [1,4,5,6]), sMZ(4)]","category":"page"},{"location":"#QuantumClifford.jl","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"","category":"section"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"QuantumClifford.jl is a comprehensive library for the study, simulation, and manipulation of Clifford circuits and slightly non-Clifford circuits. For it, we run weekly online \"office hours\" for modeling problems in quantum information science.","category":"page"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"This library uses the tableaux formalism[1] with the destabilizer improvements[2]. Moreover, Pauli frames are supported for faster repeated simulation of noisy circuits. Various symbolic and algebraic tools for manipulating, converting, and visualizing states and circuits are also available. Finite-Clifford-rank tools for modeling circuits with few non-Clifford gates are provided. ","category":"page"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"[1]: (Gottesman, 1998)","category":"page"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"[2]: (Aaronson and Gottesman, 2004)","category":"page"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"The library consists of a few related components:","category":"page"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"Tools for working with the algebra of Stabilizer Tableaux, through data structures like Stabilizer, MixedDestabilizer, and PauliOperator; canonicalization routines like canonicalize! and others; algebraic operations like project!, partial trace, and more.\nGeneral unitary operation acting on states: PauliOperator, dense n×n CliffordOperator, sparse small named single-qubit and two-qubit operators.\nFast circuit simulators over stabilizer states and small-Clifford-rank non-stabilizer states: Monte Carlo with mctrajectories; and symbolic perturbative expansions with petrajectories.\nEven faster simulator over more restricted data structures like Pauli frames with pftrajectories.\nSupport for small-rank non-Clifford states and arbitrary (non-unitary) Pauli channels acting on them, as well as Clifford unitaries and Pauli measurements.\nGenerators of sophisticated error correcting codes, related circuits, and their evaluation.","category":"page"},{"location":"#Stabilizer-Tableau-Algebra","page":"QuantumClifford.jl","title":"Stabilizer Tableau Algebra","text":"","category":"section"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"The Stabilizer Tableau Algebra component of QuantumClifford.jl efficiently handles pure and mixed stabilizer states of thousands of qubits, along with support for sparse or dense Clifford operations acting upon them. It provides operations such as canonicalization, projection, generation , and partial traces. The code is vectorized and multithreaded, offering fast, in-place, and allocation-free implementations. Tools for conversion to graph states and for visualization of tableaux are available.","category":"page"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"See the Stabilizer Tableau Algebra manual or the curated list of useful functions.","category":"page"},{"location":"#Example-Usage","page":"QuantumClifford.jl","title":"Example Usage","text":"","category":"section"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"julia> using QuantumClifford\n\njulia> P\"X\" * P\"Z\"\n-iY\n\njulia> P\"X\" ⊗ P\"Z\"\n+ XZ\n\njulia> S\"-XX\n         +ZZ\"\n- XX\n+ ZZ\n\njulia> tCNOT * S\"-XX\n                 +ZZ\"\n- X_\n+ _Z","category":"page"},{"location":"#Circuit-Simulation","page":"QuantumClifford.jl","title":"Circuit Simulation","text":"","category":"section"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"The circuit simulation component of QuantumClifford.jl enables Monte Carlo (or symbolic) simulations of noisy Clifford circuits. It provides three main simulation methods: mctrajectories, pftrajectories, and petrajectories. These methods offer varying levels of efficiency, accuracy, and insight.","category":"page"},{"location":"#Monte-Carlo-Simulations-with-Stabilizer-Tableaux-(mctrajectories)","page":"QuantumClifford.jl","title":"Monte Carlo Simulations with Stabilizer Tableaux (mctrajectories)","text":"","category":"section"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"The mctrajectories method runs Monte Carlo simulations using a Stabilizer tableau representation (or more general representations) for the quantum states. This simulation methods supports many operations that are not supported by the Pauli frame simulator, but it is much slower.","category":"page"},{"location":"#Monte-Carlo-Simulations-with-Pauli-Frames-(pftrajectories)","page":"QuantumClifford.jl","title":"Monte Carlo Simulations with Pauli Frames (pftrajectories)","text":"","category":"section"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"The pftrajectories method runs Monte Carlo simulations of Pauli frames over a single reference Stabilizer tableau simulation. This approach is much more efficient but supports a smaller class of circuits.","category":"page"},{"location":"#Symbolic-Depth-First-Traversal-of-Quantum-Trajectories-(petrajectories)","page":"QuantumClifford.jl","title":"Symbolic Depth-First Traversal of Quantum Trajectories (petrajectories)","text":"","category":"section"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"The petrajectories method performs a depth-first traversal of the most probable quantum trajectories, providing a fixed-order approximation of the circuit's behavior. This approach gives symbolic expressions for various figures of merit instead of just a numeric value.","category":"page"},{"location":"#Non-Clifford-Capabilities","page":"QuantumClifford.jl","title":"Non-Clifford Capabilities","text":"","category":"section"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"The GeneralizedStabilizer type lets you run arbitrary Clifford circuits efficiently and also to run (non-unitary) Pauli Channels with a cost exponential in the number of channel applications.","category":"page"},{"location":"#Error-Correcting-Codes","page":"QuantumClifford.jl","title":"Error Correcting Codes","text":"","category":"section"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"The QuantumClifford.ECC submodule can be used to generate the parity checks of many sophisticated codes, as well as to generate different styles of syndrome extraction circuits and to benchmark their performance with many different decoders.","category":"page"},{"location":"#Office-Hours","page":"QuantumClifford.jl","title":"Office Hours","text":"","category":"section"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"Office hours are held every Friday from 12:30 – 1:30 PM Eastern Time via Zoom. Before joining, make sure to check the Julia community events calendar to confirm whether office hours are happening, rescheduled, or canceled for the week. Feel free to bring any questions or suggestions!","category":"page"},{"location":"#Support","page":"QuantumClifford.jl","title":"Support","text":"","category":"section"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"QuantumClifford.jl is developed by many volunteers, managed at Prof. Krastanov's lab at University of Massachusetts Amherst.","category":"page"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"The development effort is supported by The NSF Engineering and Research Center for Quantum Networks, and by NSF Grant 2346089 \"Research Infrastructure: CIRC: New: Full-stack Codesign Tools for Quantum Hardware\".","category":"page"},{"location":"#Bounties","page":"QuantumClifford.jl","title":"Bounties","text":"","category":"section"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"We run many bug bounties and encourage submissions from novices (we are happy to help onboard you in the field).","category":"page"}]
}

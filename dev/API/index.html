<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Â· QuantumClifford.jl</title><meta name="title" content="API Â· QuantumClifford.jl"/><meta property="og:title" content="API Â· QuantumClifford.jl"/><meta property="twitter:title" content="API Â· QuantumClifford.jl"/><meta name="description" content="Documentation for QuantumClifford.jl."/><meta property="og:description" content="Documentation for QuantumClifford.jl."/><meta property="twitter:description" content="Documentation for QuantumClifford.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumClifford.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">QuantumClifford.jl</a></li><li><span class="tocitem">Stabilizer Tableau Algebra</span><ul><li><a class="tocitem" href="../stab-algebra-manual/">Manual</a></li><li><a class="tocitem" href="../canonicalization/">Canonicalization</a></li><li><a class="tocitem" href="../mixed/">Mixed States</a></li><li><a class="tocitem" href="../graphs/">Graph States</a></li><li><a class="tocitem" href="../datastructures/">Datastructure Choice</a></li><li><a class="tocitem" href="../commonstates/">Useful States</a></li></ul></li><li><span class="tocitem">Circuit Simulation</span><ul><li><a class="tocitem" href="../noisycircuits/">Simulation of Noisy Circuits</a></li><li><a class="tocitem" href="../noisycircuits_mc/">Monte Carlo</a></li><li><a class="tocitem" href="../noisycircuits_perturb/">Perturbative Expansions</a></li><li><a class="tocitem" href="../ecc_example_sim/">ECC example</a></li><li><a class="tocitem" href="../noisycircuits_ops/">Circuit Operations</a></li></ul></li><li><span class="tocitem">ECC compendium</span><ul><li><a class="tocitem" href="../ECC_evaluating/">Evaluating codes and decoders</a></li><li><a class="tocitem" href="../ECC_API/">API</a></li></ul></li><li><a class="tocitem" href="../allops/">All Gates</a></li><li><a class="tocitem" href="../plotting/">Visualizations</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#States"><span>States</span></a></li><li><a class="tocitem" href="#Operations"><span>Operations</span></a></li><li><a class="tocitem" href="#Autogenerated-API-list"><span>Autogenerated API list</span></a></li><li><a class="tocitem" href="#Private-API"><span>Private API</span></a></li></ul></li><li><a class="tocitem" href="../tutandpub/">Tutorials and Publications</a></li><li><a class="tocitem" href="../references/">Suggested Readings &amp; References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumSavory/QuantumClifford.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ï‚›</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/master/docs/src/API.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ï„</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Full-API"><a class="docs-heading-anchor" href="#Full-API">Full API</a><a id="Full-API-1"></a><a class="docs-heading-anchor-permalink" href="#Full-API" title="Permalink"></a></h1><style>
    .content table td {
        padding-top: 0 !important;
        padding-bottom: 0 !important;
    }
</style><h2 id="States"><a class="docs-heading-anchor" href="#States">States</a><a id="States-1"></a><a class="docs-heading-anchor-permalink" href="#States" title="Permalink"></a></h2><p>Stabilizer states can be represented with the <a href="#QuantumClifford.Stabilizer"><code>Stabilizer</code></a>, <a href="#QuantumClifford.Destabilizer"><code>Destabilizer</code></a>, <a href="#QuantumClifford.MixedStabilizer"><code>MixedStabilizer</code></a>, and <a href="#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a> tableau data structures. You probably want to use <a href="#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a> which supports the widest set of operations.</p><p>Moreover, a <a href="#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a> can be stored inside a <a href="#QuantumClifford.Register"><code>Register</code></a> together with a set of classical bits in which measurement results can be written.</p><p>Lastly, for Pauli frame simulations there is the <a href="#QuantumClifford.PauliFrame"><code>PauliFrame</code></a> type, a tableau in which each row represents a different Pauli frame.</p><p>There are <a href="../commonstates/#Useful-States-and-Operators">convenience constructors for common types of states and operators</a>.</p><h2 id="Operations"><a class="docs-heading-anchor" href="#Operations">Operations</a><a id="Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Operations" title="Permalink"></a></h2><p>Acting on quantum states can be performed either:</p><ul><li>In a &quot;linear algebra&quot; language where unitaries, measurements, and other operations have separate interfaces. This is an explicitly deterministic lower-level interface, which provides a great deal of control over how tableaux are manipulated. See the <a href="../stab-algebra-manual/#Stabilizer-Tableau-Algebra-Manual">Stabilizer Tableau Algebra Manual</a> as a primer on these approaches.</li><li>Or in a &quot;circuit&quot; language, where the operators (and measurements and noise) are represented as circuit gates. This is a higher-level interface in which the outcome of an operation can be stochastic. The API for it is centered around the <code>apply!</code> function. Particularly useful for <a href="../noisycircuits_mc/#noisycircuits_mc">Monte Carlo simulations</a> and <a href="../noisycircuits_perturb/#noisycircuits_perturb">Perturbative Expansion Symbolic Results</a>.</li></ul><p>See the <a href="../allops/#all-operations">full list of operations</a> for a list of implemented operations.</p><h2 id="Autogenerated-API-list"><a class="docs-heading-anchor" href="#Autogenerated-API-list">Autogenerated API list</a><a id="Autogenerated-API-list-1"></a><a class="docs-heading-anchor-permalink" href="#Autogenerated-API-list" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="QuantumClifford.QuantumClifford"><a class="docstring-binding" href="#QuantumClifford.QuantumClifford"><code>QuantumClifford.QuantumClifford</code></a> â€” <span class="docstring-category">Module</span></summary><div><p>A module for using the Stabilizer formalism and simulating Clifford circuits.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L1-L3">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.continue_stat"><a class="docstring-binding" href="#QuantumClifford.continue_stat"><code>QuantumClifford.continue_stat</code></a> â€” <span class="docstring-category">Constant</span></summary><div><p>Returned by <a href="#QuantumClifford.applywstatus!-Tuple{Any, Any}"><code>applywstatus!</code></a> if the circuit simulation should continue.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/mctrajectory.jl#L6">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.failure_stat"><a class="docstring-binding" href="#QuantumClifford.failure_stat"><code>QuantumClifford.failure_stat</code></a> â€” <span class="docstring-category">Constant</span></summary><div><p>Returned by <a href="#QuantumClifford.applywstatus!-Tuple{Any, Any}"><code>applywstatus!</code></a> if the circuit reports a failure.</p><p>See also: <a href="#QuantumClifford.VerifyOp"><code>VerifyOp</code></a>, <a href="#QuantumClifford.BellMeasurement"><code>BellMeasurement</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/mctrajectory.jl#L19-L22">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.false_success_stat"><a class="docstring-binding" href="#QuantumClifford.false_success_stat"><code>QuantumClifford.false_success_stat</code></a> â€” <span class="docstring-category">Constant</span></summary><div><p>Returned by <a href="#QuantumClifford.applywstatus!-Tuple{Any, Any}"><code>applywstatus!</code></a> if the circuit reports a success, but it is a false positive (i.e., there was an undetected error).</p><p>See also: <a href="#QuantumClifford.VerifyOp"><code>VerifyOp</code></a>, <a href="#QuantumClifford.BellMeasurement"><code>BellMeasurement</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/mctrajectory.jl#L14-L17">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.true_success_stat"><a class="docstring-binding" href="#QuantumClifford.true_success_stat"><code>QuantumClifford.true_success_stat</code></a> â€” <span class="docstring-category">Constant</span></summary><div><p>Returned by <a href="#QuantumClifford.applywstatus!-Tuple{Any, Any}"><code>applywstatus!</code></a> if the circuit reports a success and there is no undetected error.</p><p>See also: <a href="#QuantumClifford.VerifyOp"><code>VerifyOp</code></a>, <a href="#QuantumClifford.BellMeasurement"><code>BellMeasurement</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/mctrajectory.jl#L9-L12">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.AbstractSingleQubitOperator"><a class="docstring-binding" href="#QuantumClifford.AbstractSingleQubitOperator"><code>QuantumClifford.AbstractSingleQubitOperator</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>Supertype of all single-qubit symbolic operators.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L6">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.AbstractSymbolicOperator"><a class="docstring-binding" href="#QuantumClifford.AbstractSymbolicOperator"><code>QuantumClifford.AbstractSymbolicOperator</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>Supertype of all symbolic operators. Subtype of <code>AbstractCliffordOperator</code></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L4">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.AbstractTwoQubitOperator"><a class="docstring-binding" href="#QuantumClifford.AbstractTwoQubitOperator"><code>QuantumClifford.AbstractTwoQubitOperator</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>Supertype of all two-qubit symbolic operators.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L8">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.BellMeasurement"><a class="docstring-binding" href="#QuantumClifford.BellMeasurement"><code>QuantumClifford.BellMeasurement</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A Bell measurement performing the correlation measurement corresponding to the given <code>pauli</code> projections on the qubits at the selected indices.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/misc_ops.jl#L72">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.CircuitStatus"><a class="docstring-binding" href="#QuantumClifford.CircuitStatus"><code>QuantumClifford.CircuitStatus</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A convenience struct to represent the status of a circuit simulated by <a href="#QuantumClifford.mctrajectories-Tuple{Any, Any}"><code>mctrajectories</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/mctrajectory.jl#L1">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.ClassicalXOR"><a class="docstring-binding" href="#QuantumClifford.ClassicalXOR"><code>QuantumClifford.ClassicalXOR</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>Applies an XOR gate to classical bits. Currently only implemented for functionality with pauli frames.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/misc_ops.jl#L197">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.CliffordOperator"><a class="docstring-binding" href="#QuantumClifford.CliffordOperator"><code>QuantumClifford.CliffordOperator</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>Clifford Operator specified by the mapping of the basis generators.</p><pre><code class="language-julia-repl hljs">julia&gt; tCNOT
Xâ‚ âŸ¼ + XX
Xâ‚‚ âŸ¼ + _X
Zâ‚ âŸ¼ + Z_
Zâ‚‚ âŸ¼ + ZZ

julia&gt; phase_gate = C&quot;Y
                      Z&quot;
Xâ‚ âŸ¼ + Y
Zâ‚ âŸ¼ + Z

julia&gt; stab = S&quot;XI
                IZ&quot;;


julia&gt; entangled = tCNOT*stab
+ XX
+ ZZ

julia&gt; CliffordOperator(T&quot;YY&quot;)
ERROR: DimensionMismatch: Input tableau should be of size 2nÃ—n (top half is the X mappings and the bottom half are the Z mappings).
[...]</code></pre><p><a href="#QuantumClifford.Destabilizer"><code>Destabilizer</code></a> can also be converted.</p><pre><code class="language-julia-repl hljs">julia&gt; d = Destabilizer(S&quot;Y&quot;)
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ X
ğ’®ğ“‰ğ’¶ğ’·
+ Y

julia&gt; CliffordOperator(d)
Xâ‚ âŸ¼ + X
Zâ‚ âŸ¼ + Y</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/dense_cliffords.jl#L1-L41">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.ConditionalGate"><a class="docstring-binding" href="#QuantumClifford.ConditionalGate"><code>QuantumClifford.ConditionalGate</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A conditional gate that either performs <code>truegate</code> or <code>falsegate</code>, depending on the value of <code>controlbit</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/misc_gates.jl#L1">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.Destabilizer"><a class="docstring-binding" href="#QuantumClifford.Destabilizer"><code>QuantumClifford.Destabilizer</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A tableau representation of a pure stabilizer state. The tableau tracks the destabilizers as well, for efficient projections.</p><p>For full-rank tableaux, the stabilizer part of the tableau is guaranteed to be kept the same as the input stabilizer tableau given to the constructor (a guarantee not kept by <a href="#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a>).</p><p>On initialization there are no checks that the provided state is indeed pure. This enables the use of this data structure for mixed stabilizer state, but usually a better choice would be <a href="#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a>.</p><pre><code class="language-julia hljs">julia&gt; Destabilizer(S&quot;ZZI XXX&quot;)
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z__
+ _X_
ğ’®ğ“‰ğ’¶ğ’·â”
+ XXX
+ ZZ_

julia&gt; Destabilizer(S&quot;ZZI XXX IZZ&quot;)
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ X__
+ _Z_
+ __X
ğ’®ğ“‰ğ’¶ğ’·â”
+ ZZ_
+ XXX
+ _ZZ</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L465-L495">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.GeneralizedStabilizer"><a class="docstring-binding" href="#QuantumClifford.GeneralizedStabilizer"><code>QuantumClifford.GeneralizedStabilizer</code></a> â€” <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">mutable struct GeneralizedStabilizer{T, F} &lt;: QuantumClifford.AbstractQCState</code></pre><p>Represents mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is a pure stabilizer state.</p><pre><code class="language-julia-repl hljs">julia&gt; GeneralizedStabilizer(S&quot;-X&quot;)
A mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z
ğ’®ğ“‰ğ’¶ğ’·
- X
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 1.0+0.0im | + _ | + _

julia&gt; pcT
A unitary Pauli channel P = âˆ‘ Ï•áµ¢ Páµ¢ with the following branches:
with Ï•áµ¢ | Páµ¢
 0.853553+0.353553im | + _
 0.146447-0.353553im | + Z

julia&gt; apply!(GeneralizedStabilizer(S&quot;-X&quot;), pcT)
A mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z
ğ’®ğ“‰ğ’¶ğ’·
- X
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 0.0+0.353553im | + _ | + Z
 0.0-0.353553im | + Z | + _
 0.853553+0.0im | + _ | + _
 0.146447+0.0im | + Z | + Z</code></pre><p>See also: <a href="#QuantumClifford.PauliChannel"><code>PauliChannel</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/nonclifford.jl#L1">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.IndexedDecisionGate"><a class="docstring-binding" href="#QuantumClifford.IndexedDecisionGate"><code>QuantumClifford.IndexedDecisionGate</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A conditional gate that performs one of the <code>gates</code>, depending on the output of <code>decisionfunction</code> applied to the entire classical bit register.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/misc_gates.jl#L8">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.MixedDestabilizer"><a class="docstring-binding" href="#QuantumClifford.MixedDestabilizer"><code>QuantumClifford.MixedDestabilizer</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A tableau representation for mixed stabilizer states that keeps track of the destabilizers in order to provide efficient projection operations.</p><p>The rank <code>r</code> of the <code>n</code>-qubit tableau is tracked, either so that it can be used to represent a mixed stabilizer state, or so that it can be used to represent an <code>n-r</code> logical-qubit code over <code>n</code> physical qubits. The &quot;logical&quot; operators are tracked as well.</p><p>When the constructor is called on an incomplete <a href="#QuantumClifford.Stabilizer"><code>Stabilizer</code></a> it automatically calculates the destabilizers and logical operators, following chapter 4 of (<a href="../references/#gottesman1997stabilizer">Gottesman, 1997</a>). Under the hood the conversion uses the <a href="#QuantumClifford.canonicalize_gott!-Tuple{Stabilizer}"><code>canonicalize_gott!</code></a> canonicalization. That canonicalization permutes the columns of the tableau, but we automatically undo the column permutation in the preparation of a <code>MixedDestabilizer</code> so that qubits are not reindexed. The boolean keyword arguments <code>undoperm</code> and <code>reportperm</code> can be used to control this behavior and to report the permutations explicitly.</p><p>See also: <a href="#QuantumClifford.stabilizerview-Tuple{Stabilizer}"><code>stabilizerview</code></a>, <a href="#QuantumClifford.destabilizerview-Tuple{Destabilizer}"><code>destabilizerview</code></a>, <a href="#QuantumClifford.logicalxview-Tuple{MixedDestabilizer}"><code>logicalxview</code></a>, <a href="#QuantumClifford.logicalzview-Tuple{MixedDestabilizer}"><code>logicalzview</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L555-L574">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.MixedStabilizer"><a class="docstring-binding" href="#QuantumClifford.MixedStabilizer"><code>QuantumClifford.MixedStabilizer</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A slight improvement of the <a href="#QuantumClifford.Stabilizer"><code>Stabilizer</code></a> data structure that enables more naturally and completely the treatment of mixed states, in particular when the <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a> function is used.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L527-L531">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.NoiseOp"><a class="docstring-binding" href="#QuantumClifford.NoiseOp"><code>QuantumClifford.NoiseOp</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>An operator that applies the given <code>noise</code> model to the qubits at the selected <code>indices</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/noise.jl#L75">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.NoiseOpAll"><a class="docstring-binding" href="#QuantumClifford.NoiseOpAll"><code>QuantumClifford.NoiseOpAll</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>An operator that applies the given <code>noise</code> model to all qubits.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/noise.jl#L114">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.NoisyBellMeasurement"><a class="docstring-binding" href="#QuantumClifford.NoisyBellMeasurement"><code>QuantumClifford.NoisyBellMeasurement</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A Bell measurement in which each of the measured qubits has a chance to have flipped.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/misc_ops.jl#L93">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.NoisyGate"><a class="docstring-binding" href="#QuantumClifford.NoisyGate"><code>QuantumClifford.NoisyGate</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A gate consisting of the given <code>noise</code> applied after the given perfect Clifford <code>gate</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/noise.jl#L119">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.PauliChannel"><a class="docstring-binding" href="#QuantumClifford.PauliChannel"><code>QuantumClifford.PauliChannel</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A Pauli channel datastructure, mainly for use with <a href="#QuantumClifford.GeneralizedStabilizer"><code>GeneralizedStabilizer</code></a></p><p>See also: <a href="#QuantumClifford.UnitaryPauliChannel"><code>UnitaryPauliChannel</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/nonclifford.jl#L357-L360">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.PauliFrame"><a class="docstring-binding" href="#QuantumClifford.PauliFrame"><code>QuantumClifford.PauliFrame</code></a> â€” <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">struct PauliFrame{T, S} &lt;: QuantumClifford.AbstractQCState</code></pre><p>This is a wrapper around a tableau. This &quot;frame&quot; tableau is not to be viewed as a normal stabilizer tableau, although it does conjugate the same under Clifford operations. Each row in the tableau refers to a single frame. The row represents the Pauli operation by which the frame and the reference differ.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/pauli_frames.jl#L1">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.PauliFrame-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#QuantumClifford.PauliFrame-Tuple{Any, Any, Any}"><code>QuantumClifford.PauliFrame</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">PauliFrame(
    frames,
    qubits,
    measurements
) -&gt; PauliFrame{T} where T&lt;:(Stabilizer{T} where T&lt;:(QuantumClifford.Tableau{P, LinearAlgebra.Adjoint{UInt64, Matrix{UInt64}}} where P&lt;:(AbstractVector{&lt;:Unsigned})))
</code></pre><p>Prepare an empty set of Pauli frames with the given number of <code>frames</code> and <code>qubits</code>. Preallocates spaces for <code>measurement</code> number of measurements.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/pauli_frames.jl#L25">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.PauliMeasurement"><a class="docstring-binding" href="#QuantumClifford.PauliMeasurement"><code>QuantumClifford.PauliMeasurement</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A Stabilizer measurement on the entirety of the quantum register.</p><p><code>projectrand!(state, pauli)</code> and <code>apply!(state, PauliMeasurement(pauli))</code> give the same (possibly non-deterministic) result. Particularly useful when acting on <a href="#QuantumClifford.Register"><code>Register</code></a>.</p><p>See also: <a href="#QuantumInterface.apply!"><code>apply!</code></a>, <a href="#QuantumClifford.projectrand!-Tuple{Any, Any}"><code>projectrand!</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/misc_ops.jl#L3-L9">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.PauliNoise"><a class="docstring-binding" href="#QuantumClifford.PauliNoise"><code>QuantumClifford.PauliNoise</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>Pauli noise model with probabilities <code>px</code>, <code>py</code>, and <code>pz</code> respectively for the three types of Pauli errors.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/noise.jl#L31">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.PauliNoise-Tuple{Any}"><a class="docstring-binding" href="#QuantumClifford.PauliNoise-Tuple{Any}"><code>QuantumClifford.PauliNoise</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Constructs an unbiased Pauli noise model with total probability of error <code>p</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/noise.jl#L45">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.PauliOperator"><a class="docstring-binding" href="#QuantumClifford.PauliOperator"><code>QuantumClifford.PauliOperator</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A multi-qubit Pauli operator (<span>$Â±\{1,i\}\{I,Z,X,Y\}^{\otimes n}$</span>).</p><p>A Pauli can be constructed with the <code>P</code> custom string macro or by building up one through products and tensor products of smaller operators.</p><pre><code class="language-julia-repl hljs">julia&gt; pauli3 = P&quot;-iXYZ&quot;
-iXYZ

julia&gt; pauli4 = 1im * pauli3 âŠ— X
+ XYZX

julia&gt; Z*X
+iY</code></pre><p>We use a typical F(2,2) encoding internally. The X and Z bits are stored in a single concatenated padded array of UInt chunks of a bit array.</p><pre><code class="language-julia-repl hljs">julia&gt; p = P&quot;-IZXY&quot;;


julia&gt; p.xz
2-element Vector{UInt64}:
 0x000000000000000c
 0x000000000000000a</code></pre><p>You can access the X and Z bits through getters and setters or through the <code>xview</code>, <code>zview</code>, <code>xbit</code>, and <code>zbit</code> functions.</p><pre><code class="language-julia-repl hljs">julia&gt; p = P&quot;XYZ&quot;; p[1]
(true, false)

julia&gt; p[1] = (true, true); p
+ YYZ</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/pauli_operator.jl#L1-L41">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.Register"><a class="docstring-binding" href="#QuantumClifford.Register"><code>QuantumClifford.Register</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A register, representing the state of a computer including both a tableaux and an array of classical bits (e.g. for storing measurement results)</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/classical_register.jl#L1">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.Reset"><a class="docstring-binding" href="#QuantumClifford.Reset"><code>QuantumClifford.Reset</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>Reset the specified qubits to the given state.</p><p>Be careful, this operation implies first tracing out the qubits, which can lead to mixed states if these qubits were entangled with the rest of the system.</p><p>See also: <a href="#QuantumClifford.sMRZ"><code>sMRZ</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/misc_ops.jl#L56-L62">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.SingleQubitOperator"><a class="docstring-binding" href="#QuantumClifford.SingleQubitOperator"><code>QuantumClifford.SingleQubitOperator</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; general single-qubit operator which permits faster multiplication than an operator expressed as an explicit tableau.</p><pre><code class="language-julia-repl hljs">julia&gt; op = SingleQubitOperator(2, true, true, true, false, true, true) # Tableau components and phases
SingleQubitOperator on qubit 2
Xâ‚ âŸ¼ - Y
Zâ‚ âŸ¼ - X

julia&gt; typeof(op)
SingleQubitOperator

julia&gt; t_op = CliffordOperator(op, 3) # Transforming it back into an explicit tableau representation (specifying the size)
Xâ‚ âŸ¼ + X__
Xâ‚‚ âŸ¼ - _Y_
Xâ‚ƒ âŸ¼ + __X
Zâ‚ âŸ¼ + Z__
Zâ‚‚ âŸ¼ - _X_
Zâ‚ƒ âŸ¼ + __Z

julia&gt; typeof(t_op)
CliffordOperator{QuantumClifford.Tableau{Vector{UInt8}, Matrix{UInt64}}, PauliOperator{Array{UInt8, 0}, Vector{UInt64}}}

julia&gt; CliffordOperator(op, 1, compact=true) # You can also extract just the non-trivial part of the tableau
Xâ‚ âŸ¼ - Y
Zâ‚ âŸ¼ - X</code></pre><p>See also: <a href="#QuantumClifford.sHadamard"><code>sHadamard</code></a>, <a href="#QuantumClifford.sPhase"><code>sPhase</code></a>, <a href="#QuantumClifford.sId1"><code>sId1</code></a>, <a href="#QuantumClifford.sX"><code>sX</code></a>, <a href="#QuantumClifford.sY"><code>sY</code></a>, <a href="#QuantumClifford.sZ"><code>sZ</code></a>, <a href="#QuantumClifford.CliffordOperator"><code>CliffordOperator</code></a></p><p>Or simply consult <code>subtypes(QuantumClifford.AbstractSingleQubitOperator)</code> and <code>subtypes(QuantumClifford.AbstractTwoQubitOperator)</code> for a full list. You can think of the <code>s</code> prefix as &quot;symbolic&quot; or &quot;sparse&quot;.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L135-L168">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.SparseGate"><a class="docstring-binding" href="#QuantumClifford.SparseGate"><code>QuantumClifford.SparseGate</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A Clifford gate, applying the given <code>cliff</code> operator to the qubits at the selected <code>indices</code>.</p><p><code>apply!(state, cliff, indices)</code> and <code>apply!(state, SparseGate(cliff, indices))</code> give the same result.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/misc_ops.jl#L28-L31">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.Stabilizer"><a class="docstring-binding" href="#QuantumClifford.Stabilizer"><code>QuantumClifford.Stabilizer</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>Stabilizer, i.e. a list of commuting multi-qubit Hermitian Pauli operators.</p><p>Instances can be created with the <code>S</code> custom string macro or as direct sum of other stabilizers.</p><div class="admonition is-success" id="Stabilizers-and-Destabilizers-9222b20d5954fed3"><header class="admonition-header">Stabilizers and Destabilizers<a class="admonition-anchor" href="#Stabilizers-and-Destabilizers-9222b20d5954fed3" title="Permalink"></a></header><div class="admonition-body"><p>In many cases you probably would prefer to use the <a href="#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a> data structure, as it caries a lot of useful additional information, like tracking rank and destabilizer operators. <code>Stabilizer</code> has mostly a pedagogical value, and it is also used for slightly faster simulation of a particular subset of Clifford operations.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; s = S&quot;XXX
             ZZI
             IZZ&quot;
+ XXX
+ ZZ_
+ _ZZ

julia&gt; sâŠ—s
+ XXX___
+ ZZ____
+ _ZZ___
+ ___XXX
+ ___ZZ_
+ ____ZZ</code></pre><p>It has an indexing API, looking like a list of <code>PauliOperator</code>s.</p><pre><code class="language-julia-repl hljs">julia&gt; s[2]
+ ZZ_</code></pre><p>Pauli operators can act directly on the a stabilizer.</p><pre><code class="language-julia-repl hljs">julia&gt; P&quot;YYY&quot; * s
- XXX
+ ZZ_
+ _ZZ</code></pre><p>There are a number of ways to create a Stabilizer, including:</p><ul><li>generate Stabilizers from a list of Pauli operators</li></ul><pre><code class="language-julia-repl hljs">julia&gt; Stabilizer([P&quot;XX&quot;, P&quot;ZZ&quot;])
+ XX
+ ZZ</code></pre><ul><li>generate Stabilizers from boolean matrices</li></ul><pre><code class="language-julia-repl hljs">julia&gt; a = [true true; false false]; b = [false true; true true];

julia&gt; Stabilizer(a, b)
+ XY
+ ZZ

julia&gt; Stabilizer([0x0, 0x2], a, b)
+ XY
- ZZ</code></pre><ul><li>initialize an empty Stabilizer and fill it through indexing</li></ul><pre><code class="language-julia-repl hljs">julia&gt; s = zero(Stabilizer, 2)
+ __
+ __

julia&gt; s[1,1] = (true, false); s
+ X_
+ __</code></pre><p>There are no automatic checks for correctness (i.e. independence of all rows, commutativity of all rows, hermiticity of all rows). The rank (number of rows) is permitted to be less than the number of qubits (number of columns): canonilization, projection, etc. continue working in that case. To great extent this library uses the <code>Stabilizer</code> data structure simply as a tableau. This might be properly abstracted away in future versions.</p><p>See also: <a href="#QuantumClifford.PauliOperator"><code>PauliOperator</code></a>, <a href="#QuantumClifford.canonicalize!-Tuple{QuantumClifford.AbstractStabilizer}"><code>canonicalize!</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L284-L374">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.Stabilizer-Tuple{Graphs.SimpleGraphs.SimpleGraph}"><a class="docstring-binding" href="#QuantumClifford.Stabilizer-Tuple{Graphs.SimpleGraphs.SimpleGraph}"><code>QuantumClifford.Stabilizer</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Convert a graph representing a stabilizer state to an explicit Stabilizer.</p><p>See also: <a href="#QuantumClifford.graphstate-Tuple{QuantumClifford.AbstractStabilizer}"><code>graphstate</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/graphs.jl#L179-L182">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.SubsystemCodeTableau"><a class="docstring-binding" href="#QuantumClifford.SubsystemCodeTableau"><code>QuantumClifford.SubsystemCodeTableau</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A tableau representation of the non-commutative canonical form of a set of Paulis, which is used in <a href="#QuantumClifford.commutify-Tuple{Any}"><code>commutify</code></a>.</p><p>They are organized in the same form as <a href="#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a> with a stabilizer, destabilizer, logical X, and logical Z components.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/grouptableaux.jl#L1-L7">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.UnbiasedUncorrelatedNoise"><a class="docstring-binding" href="#QuantumClifford.UnbiasedUncorrelatedNoise"><code>QuantumClifford.UnbiasedUncorrelatedNoise</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>Depolarization noise model with total probability of error <code>p</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/noise.jl#L25">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.UnitaryPauliChannel"><a class="docstring-binding" href="#QuantumClifford.UnitaryPauliChannel"><code>QuantumClifford.UnitaryPauliChannel</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A Pauli channel datastructure, mainly for use with <a href="#QuantumClifford.GeneralizedStabilizer"><code>GeneralizedStabilizer</code></a>.</p><p>More convenient to use than <a href="#QuantumClifford.PauliChannel"><code>PauliChannel</code></a> when you know your Pauli channel is unitary.</p><pre><code class="language-julia-repl hljs">julia&gt; Tgate = UnitaryPauliChannel(
           (I, Z),
           ((1+exp(im*Ï€/4))/2, (1-exp(im*Ï€/4))/2)
       )
A unitary Pauli channel P = âˆ‘ Ï•áµ¢ Páµ¢ with the following branches:
with Ï•áµ¢ | Páµ¢
 0.853553+0.353553im | + _
 0.146447-0.353553im | + Z

julia&gt; PauliChannel(Tgate)
Pauli channel Ï â†¦ âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  with the following branches:
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 0.853553+0.0im | + _ | + _
 0.0+0.353553im | + _ | + Z
 0.0-0.353553im | + Z | + _
 0.146447+0.0im | + Z | + Z</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/nonclifford.jl#L648-L671">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.VerifyOp"><a class="docstring-binding" href="#QuantumClifford.VerifyOp"><code>QuantumClifford.VerifyOp</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;probe&quot; to verify that the state of the qubits corresponds to a desired <code>good_state</code>, e.g. at the end of the execution of a circuit.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/misc_ops.jl#L163">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sCNOT"><a class="docstring-binding" href="#QuantumClifford.sCNOT"><code>QuantumClifford.sCNOT</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; CNOT. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sCPHASE"><a class="docstring-binding" href="#QuantumClifford.sCPHASE"><code>QuantumClifford.sCPHASE</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; CPHASE. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sCXSWAP"><a class="docstring-binding" href="#QuantumClifford.sCXSWAP"><code>QuantumClifford.sCXSWAP</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; CXSWAP. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sCXYZ"><a class="docstring-binding" href="#QuantumClifford.sCXYZ"><code>QuantumClifford.sCXYZ</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; single-qubit CXYZ. See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L99">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sCZSWAP"><a class="docstring-binding" href="#QuantumClifford.sCZSWAP"><code>QuantumClifford.sCZSWAP</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; CZSWAP. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sCZYX"><a class="docstring-binding" href="#QuantumClifford.sCZYX"><code>QuantumClifford.sCZYX</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; single-qubit CZYX. See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L99">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sHadamard"><a class="docstring-binding" href="#QuantumClifford.sHadamard"><code>QuantumClifford.sHadamard</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; single-qubit Hadamard. See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L99">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sHadamardXY"><a class="docstring-binding" href="#QuantumClifford.sHadamardXY"><code>QuantumClifford.sHadamardXY</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; single-qubit HadamardXY. See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L99">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sHadamardYZ"><a class="docstring-binding" href="#QuantumClifford.sHadamardYZ"><code>QuantumClifford.sHadamardYZ</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; single-qubit HadamardYZ. See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L99">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sISWAP"><a class="docstring-binding" href="#QuantumClifford.sISWAP"><code>QuantumClifford.sISWAP</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; ISWAP. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sId1"><a class="docstring-binding" href="#QuantumClifford.sId1"><code>QuantumClifford.sId1</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; single-qubit Identity operation.</p><p>See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L120-L124">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sInvISWAP"><a class="docstring-binding" href="#QuantumClifford.sInvISWAP"><code>QuantumClifford.sInvISWAP</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; InvISWAP. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sInvPhase"><a class="docstring-binding" href="#QuantumClifford.sInvPhase"><code>QuantumClifford.sInvPhase</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; single-qubit InvPhase. See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L99">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sInvSQRTX"><a class="docstring-binding" href="#QuantumClifford.sInvSQRTX"><code>QuantumClifford.sInvSQRTX</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; single-qubit InvSQRTX. See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L99">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sInvSQRTXX"><a class="docstring-binding" href="#QuantumClifford.sInvSQRTXX"><code>QuantumClifford.sInvSQRTXX</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; InvSQRTXX. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sInvSQRTY"><a class="docstring-binding" href="#QuantumClifford.sInvSQRTY"><code>QuantumClifford.sInvSQRTY</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; single-qubit InvSQRTY. See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L99">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sInvSQRTYY"><a class="docstring-binding" href="#QuantumClifford.sInvSQRTYY"><code>QuantumClifford.sInvSQRTYY</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; InvSQRTYY. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sInvSQRTZZ"><a class="docstring-binding" href="#QuantumClifford.sInvSQRTZZ"><code>QuantumClifford.sInvSQRTZZ</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; InvSQRTZZ. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sInvSWAPCX"><a class="docstring-binding" href="#QuantumClifford.sInvSWAPCX"><code>QuantumClifford.sInvSWAPCX</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; InvSWAPCX. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sInvZCrY"><a class="docstring-binding" href="#QuantumClifford.sInvZCrY"><code>QuantumClifford.sInvZCrY</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; InvZCrY. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sMRX"><a class="docstring-binding" href="#QuantumClifford.sMRX"><code>QuantumClifford.sMRX</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>Measure a qubit in the X basis and reset to the |+âŸ© state.</p><p>See also: <a href="#QuantumClifford.sMRZ"><code>sMRZ</code></a>, <a href="#QuantumClifford.Reset"><code>Reset</code></a>, <a href="#QuantumClifford.sMZ"><code>sMZ</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L632-L635">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sMRY"><a class="docstring-binding" href="#QuantumClifford.sMRY"><code>QuantumClifford.sMRY</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>Measure a qubit in the Y basis and reset to the |iâ‚ŠâŸ© state.</p><p>See also: <a href="#QuantumClifford.sMRZ"><code>sMRZ</code></a>, <a href="#QuantumClifford.Reset"><code>Reset</code></a>, <a href="#QuantumClifford.sMZ"><code>sMZ</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L641-L644">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sMRZ"><a class="docstring-binding" href="#QuantumClifford.sMRZ"><code>QuantumClifford.sMRZ</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>Measure a qubit in the Z basis and reset to the |0âŸ© state.</p><div class="admonition is-warning" id="It-does-not-trace-out-the-qubit!-daf29f85259ba117"><header class="admonition-header">It does not trace out the qubit!<a class="admonition-anchor" href="#It-does-not-trace-out-the-qubit!-daf29f85259ba117" title="Permalink"></a></header><div class="admonition-body"><p>As described below there is a difference between measuring the qubit (followed by setting it to a given known state) and &quot;tracing out&quot; the qubit. By reset here we mean &quot;measuring and setting to a known state&quot;, not &quot;tracing out&quot;.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; s = MixedDestabilizer(S&quot;XXX ZZI IZZ&quot;) # |000âŸ©+|111âŸ©
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z__
+ _X_
+ __X
ğ’®ğ“‰ğ’¶ğ’·â”
+ XXX
+ ZZ_
+ Z_Z

julia&gt; traceout!(copy(s), 1) # = IâŠ—(|00âŸ©âŸ¨00| + |11âŸ©âŸ¨11|)
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ _X_
ğ’³â‚—â”â”â”
+ _XX
+ Z__
ğ’®ğ“‰ğ’¶ğ’·â”
+ _ZZ
ğ’µâ‚—â”â”â”
+ Z_Z
+ XXX

julia&gt; projectZ!(traceout!(copy(s), 1), 1)[1] # = |000âŸ©âŸ¨000|+|011âŸ©âŸ¨011| or |100âŸ©âŸ¨100|+|111âŸ©âŸ¨111| (use projectZrand! to actually get a random result)
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ _X_
+ XXX
ğ’³â‚—â”â”â”
+ _XX
ğ’®ğ“‰ğ’¶ğ’·â”
+ _ZZ
+ Z__
ğ’µâ‚—â”â”â”
+ Z_Z

julia&gt; projectZ!(copy(s), 1)[1] # = |000âŸ© or |111âŸ© (use projectZrand! to actually get a random result)
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ XXX
+ _X_
+ __X
ğ’®ğ“‰ğ’¶ğ’·â”
+ Z__
+ ZZ_
+ Z_Z</code></pre><pre><code class="language-julia-repl hljs">julia&gt; apply!(Register(copy(s)), sMRZ(1)) |&gt; quantumstate # |000âŸ© or |011âŸ©, depending on randomization
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ XXX
+ _X_
+ __X
ğ’®ğ“‰ğ’¶ğ’·â”
+ Z__
- ZZ_
- Z_Z</code></pre><p>See also: <a href="#QuantumClifford.Reset"><code>Reset</code></a>, <a href="#QuantumClifford.sMZ"><code>sMZ</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L561-L626">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sMX"><a class="docstring-binding" href="#QuantumClifford.sMX"><code>QuantumClifford.sMX</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>Symbolic single qubit X measurement. See also <a href="#QuantumClifford.Register"><code>Register</code></a>, <a href="#QuantumClifford.projectXrand!-Tuple{Any, Any}"><code>projectXrand!</code></a>, <a href="#QuantumClifford.sMY"><code>sMY</code></a>, <a href="#QuantumClifford.sMZ"><code>sMZ</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L514">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sMY"><a class="docstring-binding" href="#QuantumClifford.sMY"><code>QuantumClifford.sMY</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>Symbolic single qubit Y measurement. See also <a href="#QuantumClifford.Register"><code>Register</code></a>, <a href="#QuantumClifford.projectYrand!-Tuple{Any, Any}"><code>projectYrand!</code></a>, <a href="#QuantumClifford.sMX"><code>sMX</code></a>, <a href="#QuantumClifford.sMZ"><code>sMZ</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L521">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sMZ"><a class="docstring-binding" href="#QuantumClifford.sMZ"><code>QuantumClifford.sMZ</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>Symbolic single qubit Z measurement. See also <a href="#QuantumClifford.Register"><code>Register</code></a>, <a href="#QuantumClifford.projectZrand!-Tuple{Any, Any}"><code>projectZrand!</code></a>, <a href="#QuantumClifford.sMX"><code>sMX</code></a>, <a href="#QuantumClifford.sMY"><code>sMY</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L528">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sPhase"><a class="docstring-binding" href="#QuantumClifford.sPhase"><code>QuantumClifford.sPhase</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; single-qubit Phase. See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L99">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sSQRTX"><a class="docstring-binding" href="#QuantumClifford.sSQRTX"><code>QuantumClifford.sSQRTX</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; single-qubit SQRTX. See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L99">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sSQRTXX"><a class="docstring-binding" href="#QuantumClifford.sSQRTXX"><code>QuantumClifford.sSQRTXX</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; SQRTXX. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sSQRTY"><a class="docstring-binding" href="#QuantumClifford.sSQRTY"><code>QuantumClifford.sSQRTY</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; single-qubit SQRTY. See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L99">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sSQRTYY"><a class="docstring-binding" href="#QuantumClifford.sSQRTYY"><code>QuantumClifford.sSQRTYY</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; SQRTYY. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sSQRTZZ"><a class="docstring-binding" href="#QuantumClifford.sSQRTZZ"><code>QuantumClifford.sSQRTZZ</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; SQRTZZ. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sSWAP"><a class="docstring-binding" href="#QuantumClifford.sSWAP"><code>QuantumClifford.sSWAP</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; SWAP. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sSWAPCX"><a class="docstring-binding" href="#QuantumClifford.sSWAPCX"><code>QuantumClifford.sSWAPCX</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; SWAPCX. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sX"><a class="docstring-binding" href="#QuantumClifford.sX"><code>QuantumClifford.sX</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; single-qubit X. See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L99">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sXCX"><a class="docstring-binding" href="#QuantumClifford.sXCX"><code>QuantumClifford.sXCX</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; XCX. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sXCY"><a class="docstring-binding" href="#QuantumClifford.sXCY"><code>QuantumClifford.sXCY</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; XCY. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sXCZ"><a class="docstring-binding" href="#QuantumClifford.sXCZ"><code>QuantumClifford.sXCZ</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; XCZ. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sY"><a class="docstring-binding" href="#QuantumClifford.sY"><code>QuantumClifford.sY</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; single-qubit Y. See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L99">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sYCX"><a class="docstring-binding" href="#QuantumClifford.sYCX"><code>QuantumClifford.sYCX</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; YCX. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sYCY"><a class="docstring-binding" href="#QuantumClifford.sYCY"><code>QuantumClifford.sYCY</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; YCY. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sYCZ"><a class="docstring-binding" href="#QuantumClifford.sYCZ"><code>QuantumClifford.sYCZ</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; YCZ. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sZ"><a class="docstring-binding" href="#QuantumClifford.sZ"><code>QuantumClifford.sZ</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; single-qubit Z. See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L99">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sZCX"><a class="docstring-binding" href="#QuantumClifford.sZCX"><code>QuantumClifford.sZCX</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; ZCX. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sZCY"><a class="docstring-binding" href="#QuantumClifford.sZCY"><code>QuantumClifford.sZCY</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; ZCY. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sZCZ"><a class="docstring-binding" href="#QuantumClifford.sZCZ"><code>QuantumClifford.sZCZ</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; ZCZ. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sZCrY"><a class="docstring-binding" href="#QuantumClifford.sZCrY"><code>QuantumClifford.sZCrY</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>A &quot;symbolic&quot; ZCrY. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.PauliError"><a class="docstring-binding" href="#QuantumClifford.PauliError"><code>QuantumClifford.PauliError</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>A convenient constructor for various types of Pauli errors, that can be used as circuit gates in simulations. Returns more specific types when necessary.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/noise.jl#L83-L86">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.PauliError-NTuple{4, Any}"><a class="docstring-binding" href="#QuantumClifford.PauliError-NTuple{4, Any}"><code>QuantumClifford.PauliError</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>&quot;Construct a gate operation that applies a biased Pauli error on all <code>qubits</code> independently, each with  probabilities <code>px</code>, <code>py</code>, <code>pz</code>. Note that the probability of any error occurring is <code>px+py+pz</code>. Because of this, <code>PauliError(1, p)</code> is equivalent to <code>PauliError(1,p/3,p/3,p/3)</code>. Similarly, if one wanted to exclude Z errors from <code>PauliError(1,p/3,p/3,p/3)</code> while mainting the same rate of X errors, one could write <code>PauliError(1, p*2/3, 0, 0)</code> (in the sense that Y errors can be interpreted as an X and a Z happening at the same time).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/noise.jl#L106-L110">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.PauliError-Tuple{Any, Any}"><a class="docstring-binding" href="#QuantumClifford.PauliError-Tuple{Any, Any}"><code>QuantumClifford.PauliError</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>&quot;Construct a gate operation that applies an unbiased Pauli error on all <code>qubits</code>, each with independent probability <code>p</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/noise.jl#L93">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.PauliError-Tuple{Int64, Any, Any, Any}"><a class="docstring-binding" href="#QuantumClifford.PauliError-Tuple{Int64, Any, Any, Any}"><code>QuantumClifford.PauliError</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>&quot;Construct a gate operation that applies a biased Pauli error on  qubit <code>q</code> with independent probabilities <code>px</code>, <code>py</code>, <code>pz</code>. Note that the probability of any error occurring is <code>px+py+pz</code>. Because of this, <code>PauliError(1, p)</code> is equivalent to <code>PauliError(1,p/3,p/3,p/3)</code>. Similarly, if one wanted to exclude Z errors from <code>PauliError(1,p/3,p/3,p/3)</code> while mainting the same rate of X errors, one could write <code>PauliError(1, p*2/3, 0, 0)</code> (in the sense that Y errors can be interpreted as an X and a Z happening at the same time).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/noise.jl#L98-L102">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.PauliError-Tuple{Int64, Any}"><a class="docstring-binding" href="#QuantumClifford.PauliError-Tuple{Int64, Any}"><code>QuantumClifford.PauliError</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>&quot;Construct a gate operation that applies an unbiased Pauli error on qubit <code>q</code> with probability <code>p</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/noise.jl#L88">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.affectedqubits"><a class="docstring-binding" href="#QuantumClifford.affectedqubits"><code>QuantumClifford.affectedqubits</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>A method giving the qubits acted upon by a given operation. Part of the Noise interface.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/affectedqubits.jl#L1">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.apply_inv!"><a class="docstring-binding" href="#QuantumClifford.apply_inv!"><code>QuantumClifford.apply_inv!</code></a> â€” <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">apply_inv!</code></pre><p>Apply the inverse of any quantum operation to a stabilizer state.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L1090-L1094">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.apply_right!"><a class="docstring-binding" href="#QuantumClifford.apply_right!"><code>QuantumClifford.apply_right!</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>the <code>apply_right!</code> function is used to right multiply any quantum operation to unitary  Clifford operation or Pauli product</p><pre><code class="language-julia-repl hljs">julia&gt; apply_right!(C&quot;X Z&quot;, sHadamard(1))
Xâ‚ âŸ¼ + Z
Zâ‚ âŸ¼ + X
julia&gt; apply_right!(C&quot;Y Z&quot;, C&quot;Z Y&quot;)
Xâ‚ âŸ¼ + Z
Zâ‚ âŸ¼ - X
julia&gt; apply_right!(C&quot;Y Z&quot;, P&quot;X&quot;)
Xâ‚ âŸ¼ + Y
Zâ‚ âŸ¼ - Z</code></pre><p>Example: Build a bell state decoder</p><pre><code class="language-julia-repl hljs">julia&gt; cliff = one(CliffordOperator, 2)
Xâ‚ âŸ¼ + X_
Xâ‚‚ âŸ¼ + _X
Zâ‚ âŸ¼ + Z_
Zâ‚‚ âŸ¼ + _Z
julia&gt; apply_right!(cliff, sHadamard(1))
Xâ‚ âŸ¼ + Z_
Xâ‚‚ âŸ¼ + _X
Zâ‚ âŸ¼ + X_
Zâ‚‚ âŸ¼ + _Z
julia&gt; apply_right!(cliff, sCNOT(1, 2))
Xâ‚ âŸ¼ + ZX
Xâ‚‚ âŸ¼ + _X
Zâ‚ âŸ¼ + X_
Zâ‚‚ âŸ¼ + XZ
julia&gt; apply!(bell(), cliff)
+ Z_
+ _Z</code></pre><p>See also: <a href="#QuantumInterface.apply!"><code>apply!</code></a>, <a href="#QuantumClifford.apply_inv!"><code>apply_inv!</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/apply_right.jl#L1-L40">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.applybranches"><a class="docstring-binding" href="#QuantumClifford.applybranches"><code>QuantumClifford.applybranches</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>Compute all possible new states after the application of the given operator. Reports the probability of each one of them. Deterministic (as it reports all branches of potentially random processes), part of the Perturbative Expansion interface.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/petrajectory.jl#L1">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.applynoise!"><a class="docstring-binding" href="#QuantumClifford.applynoise!"><code>QuantumClifford.applynoise!</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>A method modifying a given state by applying the corresponding noise model. It is non-deterministic, part of the Noise interface.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/noise.jl#L5">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.applywstatus!-Tuple{Any, Any}"><a class="docstring-binding" href="#QuantumClifford.applywstatus!-Tuple{Any, Any}"><code>QuantumClifford.applywstatus!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Used for <a href="#QuantumClifford.mctrajectories-Tuple{Any, Any}"><code>mctrajectories</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/mctrajectory.jl#L35">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.bell"><a class="docstring-binding" href="#QuantumClifford.bell"><code>QuantumClifford.bell</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>Prepare one or more Bell pairs (with optional phases).</p><pre><code class="language-julia-repl hljs">julia&gt; bell()
+ XX
+ ZZ

julia&gt; bell(2)
+ XX__
+ ZZ__
+ __XX
+ __ZZ

julia&gt; bell((true, false))
- XX
+ ZZ

julia&gt; bell([true, false, true, true])
- XX__
+ ZZ__
- __XX
- __ZZ</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/useful_states.jl#L53-L77">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.bigram-Tuple{QuantumClifford.AbstractStabilizer}"><a class="docstring-binding" href="#QuantumClifford.bigram-Tuple{QuantumClifford.AbstractStabilizer}"><code>QuantumClifford.bigram</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">bigram(
    state::QuantumClifford.AbstractStabilizer;
    clip
) -&gt; Matrix{Int64}
</code></pre><p>Get the bigram of a tableau.</p><p>It is the list of endpoints of a tableau in the clipped gauge.</p><p>If <code>clip=true</code> (the default) the tableau is converted to the clipped gauge in-place before calculating the bigram. Otherwise, the clip gauge conversion is skipped (for cases where the input is already known to be in the correct gauge).</p><p>Introduced in (<a href="../references/#nahum2017quantum">Nahum <em>et al.</em>, 2017</a>), with a more detailed explanation of the algorithm in (<a href="../references/#li2019measurement">Li <em>et al.</em>, 2019</a>) and (<a href="../references/#gullans2021quantum">Gullans <em>et al.</em>, 2021</a>).</p><p>See also: <a href="#QuantumClifford.canonicalize_clip!-Tuple{QuantumClifford.AbstractStabilizer}"><code>canonicalize_clip!</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/entanglement.jl#L133">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.bitview"><a class="docstring-binding" href="#QuantumClifford.bitview"><code>QuantumClifford.bitview</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>A view of the classical bits stored with the state</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/classical_register.jl#L23">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.canonicalize!-Tuple{QuantumClifford.AbstractStabilizer}"><a class="docstring-binding" href="#QuantumClifford.canonicalize!-Tuple{QuantumClifford.AbstractStabilizer}"><code>QuantumClifford.canonicalize!</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">canonicalize!(
    state::QuantumClifford.AbstractStabilizer;
    phases,
    ranks
) -&gt; Union{Tuple{QuantumClifford.AbstractStabilizer, Int64, Int64}, QuantumClifford.AbstractStabilizer}
</code></pre><p>Canonicalize a stabilizer (in place).</p><p>Assumes the input is a valid stabilizer (all operators commute and have real phases). It permits redundant generators and identity generators.</p><pre><code class="language-julia-repl hljs">julia&gt; ghz = S&quot;XXXX
               ZZII
               IZZI
               IIZZ&quot;;


julia&gt; canonicalize!(ghz)
+ XXXX
+ Z__Z
+ _Z_Z
+ __ZZ

julia&gt; canonicalize!(S&quot;XXXX
                       IZZI
                       IIZZ&quot;)
+ XXXX
+ _Z_Z
+ __ZZ</code></pre><p>Not all rows in the tableau in the next example are independent:</p><pre><code class="language-julia-repl hljs">julia&gt; canonicalize!(S&quot;XXXX
                       ZZII
                       IZZI
                       IZIZ
                       IIZZ&quot;)
+ XXXX
+ Z__Z
+ _Z_Z
+ __ZZ
+ ____</code></pre><p>In cases of lower rank, more advanced tableau structures might be better. For instance the <a href="#QuantumClifford.MixedStabilizer"><code>MixedStabilizer</code></a> or <a href="#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a> structures (you can read more about them in the <a href="../datastructures/#Choosing-Appropriate-Data-Structure">Data Structures section</a> of the documentation).</p><p>If <code>phases=false</code> is set, the canonicalization does not track the phases in the tableau, leading to significant (constant factor) speedup.</p><pre><code class="language-julia-repl hljs">julia&gt; s = S&quot;-ZX
              XZ&quot;
- ZX
+ XZ

julia&gt; canonicalize!(copy(s), phases=false)
- XZ
+ ZX

julia&gt; canonicalize!(copy(s))
+ XZ
- ZX</code></pre><p>If <code>ranks=true</code> is set, the last pivot indices for the X and Z stage of the canonicalization are returned as well.</p><pre><code class="language-julia-repl hljs">julia&gt; s = S&quot;XXXX
             ZZII
             IZIZ
             ZIIZ&quot;;


julia&gt; _, ix, iz = canonicalize!(s, ranks=true); ix, iz
(1, 3)

julia&gt; s
+ XXXX
+ Z__Z
+ _Z_Z
+ ____</code></pre><p>Based on (<a href="../references/#garcia2012efficient">Garcia <em>et al.</em>, 2012</a>).</p><p>See also: <a href="#QuantumClifford.canonicalize_rref!-Tuple{QuantumClifford.AbstractStabilizer, Any}"><code>canonicalize_rref!</code></a>, <a href="#QuantumClifford.canonicalize_gott!-Tuple{Stabilizer}"><code>canonicalize_gott!</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/canonicalization.jl#L1">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.canonicalize_clip!-Tuple{QuantumClifford.AbstractStabilizer}"><a class="docstring-binding" href="#QuantumClifford.canonicalize_clip!-Tuple{QuantumClifford.AbstractStabilizer}"><code>QuantumClifford.canonicalize_clip!</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">canonicalize_clip!(
    state::QuantumClifford.AbstractStabilizer;
    phases
) -&gt; QuantumClifford.AbstractStabilizer
</code></pre><p>Fix the clipped gauge of a stabilizer (in place).</p><p>Assumes the input is a valid full-rank stabilizer (all operators commute and have real phases).</p><pre><code class="language-julia-repl hljs">julia&gt; s = S&quot;- X_ZX_X
             + XXYZ__
             - YZ_Z_X
             - XZX__Y
             + _Z_Y_Y
             - ____Z_&quot;;


julia&gt; canonicalize_clip!(s)
- X_XY__
+ YZY___
+ _XZX__
- _ZYX_Z
- __YZ_X
- ____Z_</code></pre><p>If <code>phases=false</code> is set, the canonicalization does not track the phases in the tableau, leading to a significant speedup.</p><p>Introduced in (<a href="../references/#nahum2017quantum">Nahum <em>et al.</em>, 2017</a>), with a more detailed explanation of the algorithm in Appendix A of (<a href="../references/#li2019measurement">Li <em>et al.</em>, 2019</a>)</p><p>See also: <a href="#QuantumClifford.canonicalize!-Tuple{QuantumClifford.AbstractStabilizer}"><code>canonicalize!</code></a>, <a href="#QuantumClifford.canonicalize_rref!-Tuple{QuantumClifford.AbstractStabilizer, Any}"><code>canonicalize_rref!</code></a>, <a href="#QuantumClifford.canonicalize_gott!-Tuple{Stabilizer}"><code>canonicalize_gott!</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/entanglement.jl#L1">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.canonicalize_gott!-Tuple{Stabilizer}"><a class="docstring-binding" href="#QuantumClifford.canonicalize_gott!-Tuple{Stabilizer}"><code>QuantumClifford.canonicalize_gott!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Inplace Gottesman canonicalization of a tableau.</p><p>This uses different canonical form from <a href="#QuantumClifford.canonicalize!-Tuple{QuantumClifford.AbstractStabilizer}"><code>canonicalize!</code></a>. It is used in the computation of the logical X and Z operators of a <a href="#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a>.</p><p>It returns the (in place) modified state, the indices of the last pivot of both Gaussian elimination steps, and the permutations that have been used to put the X and Z tableaux in standard form.</p><p>Based on (<a href="../references/#gottesman1997stabilizer">Gottesman, 1997</a>).</p><p>See also: <a href="#QuantumClifford.canonicalize!-Tuple{QuantumClifford.AbstractStabilizer}"><code>canonicalize!</code></a>, <a href="#QuantumClifford.canonicalize_rref!-Tuple{QuantumClifford.AbstractStabilizer, Any}"><code>canonicalize_rref!</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/canonicalization.jl#L206-L220">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.canonicalize_noncomm-Tuple{QuantumClifford.Tableau}"><a class="docstring-binding" href="#QuantumClifford.canonicalize_noncomm-Tuple{QuantumClifford.Tableau}"><code>QuantumClifford.canonicalize_noncomm</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>For a not-necessarily commutative set of Paulis, return a generating set of the form âŸ¨Aâ‚, Aâ‚‚, ... Aâ‚–, Aâ‚–â‚Šâ‚, ... Aâ‚˜, Bâ‚, Bâ‚‚, ... Bâ‚–âŸ© where pairs Aâ‚–, Bâ‚– anticommute and all other pairings commute. Based on (<a href="../references/#RevModPhys_87_307">Terhal, 2015</a>)</p><p>Returns the generating set as a data structure of type <a href="#QuantumClifford.SubsystemCodeTableau"><code>SubsystemCodeTableau</code></a>. The <code>logicalxview</code> function returns the âŸ¨Aâ‚, Aâ‚‚,... Aâ‚–âŸ©, and the <code>logicalzview</code> function returns âŸ¨Bâ‚, Bâ‚‚, ... Bâ‚–âŸ©. <code>stabilizerview</code> returns âŸ¨Aâ‚–â‚Šâ‚, ... Aâ‚˜âŸ© as a Stabilizer, and <code>destabilizerview</code> returns the Destabilizer of that Stabilizer.</p><p>Phases are zeroed-out in this canonicalization.</p><pre><code class="language-julia-repl hljs">julia&gt; canonicalize_noncomm(T&quot;XX XZ XY&quot;)
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z_
ğ’³â”â”
+ XX
ğ’®ğ“‰ğ’¶ğ’·
+ X_
ğ’µâ”â”
+ XZ</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/grouptableaux.jl#L170-L192">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.canonicalize_rref!-Tuple{QuantumClifford.AbstractStabilizer, Any}"><a class="docstring-binding" href="#QuantumClifford.canonicalize_rref!-Tuple{QuantumClifford.AbstractStabilizer, Any}"><code>QuantumClifford.canonicalize_rref!</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">canonicalize_rref!(
    state::QuantumClifford.AbstractStabilizer,
    colindices;
    phases
) -&gt; Tuple{QuantumClifford.AbstractStabilizer, Any}
</code></pre><p>Canonicalize a stabilizer (in place) along only some columns.</p><p>This uses different canonical form from <a href="#QuantumClifford.canonicalize!-Tuple{QuantumClifford.AbstractStabilizer}"><code>canonicalize!</code></a>. It also indexes in reverse in order to make its use in <a href="#QuantumInterface.traceout!-Tuple{Stabilizer, Any}"><code>traceout!</code></a> more efficient. Its use in <code>traceout!</code> is its main application.</p><p>It returns the (in place) modified state and the index of the last pivot.</p><p>Based on (<a href="../references/#audenaert2005entanglement">Audenaert and Plenio, 2005</a>).</p><p>See also: <a href="#QuantumClifford.canonicalize!-Tuple{QuantumClifford.AbstractStabilizer}"><code>canonicalize!</code></a>, <a href="#QuantumClifford.canonicalize_gott!-Tuple{Stabilizer}"><code>canonicalize_gott!</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/canonicalization.jl#L135">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.canonicalize_rref!-Tuple{QuantumClifford.AbstractStabilizer}"><a class="docstring-binding" href="#QuantumClifford.canonicalize_rref!-Tuple{QuantumClifford.AbstractStabilizer}"><code>QuantumClifford.canonicalize_rref!</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">canonicalize_rref!(
    state::QuantumClifford.AbstractStabilizer;
    phases
) -&gt; Tuple{QuantumClifford.AbstractStabilizer, Any}
</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/canonicalization.jl#L182">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.centralizer-Tuple{QuantumClifford.Tableau}"><a class="docstring-binding" href="#QuantumClifford.centralizer-Tuple{QuantumClifford.Tableau}"><code>QuantumClifford.centralizer</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>For a given set of Paulis (in the form of a <code>Tableau</code>), return the subset of Paulis that commute with all Paulis in set.</p><pre><code class="language-julia-repl hljs">julia&gt; centralizer(T&quot;XX ZZ _Z&quot;)
+ ZZ</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/grouptableaux.jl#L423-L430">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.clifford_cardinality-Tuple{Int64}"><a class="docstring-binding" href="#QuantumClifford.clifford_cardinality-Tuple{Int64}"><code>QuantumClifford.clifford_cardinality</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>The size of the Clifford group <code>ğ’</code> over a given number of qubits, possibly modulo the phases.</p><p>For n qubits, not accounting for phases is <code>2â¿â¿Î â±¼â‚Œâ‚â¿(4Ê²-1)</code>. There are <code>4â¿</code> different phase configurations.</p><pre><code class="language-julia-repl hljs">julia&gt; clifford_cardinality(7)
457620995529680351512370381586432000</code></pre><p>When not accounting for phases (<code>phases = false</code>) the result is the same as the size of the Symplectic group <code>Sp(2n) â‰¡ ğ’â‚™/ğ’«â‚™</code>, where <code>ğ’«â‚™</code> is the Pauli group over <code>n</code> qubits.</p><pre><code class="language-julia-repl hljs">julia&gt; clifford_cardinality(7, phases=false)
27930968965434591767112450048000</code></pre><p>See also: <a href="#QuantumClifford.enumerate_cliffords-Tuple{Any, Any}"><code>enumerate_cliffords</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/enumeration.jl#L52-L70">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.comm"><a class="docstring-binding" href="#QuantumClifford.comm"><code>QuantumClifford.comm</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>Check whether two operators commute.</p><p><code>0x0</code> if they commute, <code>0x1</code> if they anticommute.</p><pre><code class="language-julia-repl hljs">julia&gt; P&quot;XX&quot;*P&quot;ZZ&quot;, P&quot;ZZ&quot;*P&quot;XX&quot;
(- YY, - YY)

julia&gt; comm(P&quot;ZZ&quot;, P&quot;XX&quot;)
0x00

julia&gt; comm(P&quot;IZ&quot;, P&quot;XX&quot;)
0x01</code></pre><p>See also: <a href="#QuantumClifford.comm!"><code>comm!</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L749-L766">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.comm!"><a class="docstring-binding" href="#QuantumClifford.comm!"><code>QuantumClifford.comm!</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>An in-place version of <a href="#QuantumClifford.comm"><code>comm</code></a>, storing its output in the given buffer.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L806">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.commutify-Tuple{Any}"><a class="docstring-binding" href="#QuantumClifford.commutify-Tuple{Any}"><code>QuantumClifford.commutify</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>For a not-necessarily commutative set of Paulis S, computed S&#39;, the <a href="#QuantumClifford.canonicalize_noncomm-Tuple{QuantumClifford.Tableau}">non-commutative canonical form</a> of of S. For each pair Aâ‚–, Bâ‚– of anticommutative Paulis in S&#39;, add a qubit to each Pauli in the set: X to Aâ‚–, Z to Bâ‚–, and I to each other operator to produce S&#39;&#39;, a fully commutative set. Return S&#39;&#39; as well as a list of the indices of the added qubits.</p><p>The returned object is a Stabilizer that is also useful for the <a href="#QuantumClifford.matroid_parent-Tuple{QuantumClifford.Tableau}"><code>matroid_parent</code></a> function.</p><pre><code class="language-julia-repl hljs">julia&gt; commutify(T&quot;XX XZ XY&quot;)[1]
+ XXX
+ X__
+ XZZ

julia&gt; commutify(T&quot;XX XZ XY&quot;)[2]
3:3</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/grouptableaux.jl#L254-L272">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.compactify_circuit-Tuple{Any}"><a class="docstring-binding" href="#QuantumClifford.compactify_circuit-Tuple{Any}"><code>QuantumClifford.compactify_circuit</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Convert a list of gates to a more optimized &quot;sum type&quot; format which permits faster dispatch.</p><p>Generally, this should be called on a circuit before it is used in a simulation.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/sumtypes.jl#L201-L205">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.contractor-Tuple{Stabilizer, Any}"><a class="docstring-binding" href="#QuantumClifford.contractor-Tuple{Stabilizer, Any}"><code>QuantumClifford.contractor</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Return the subset of Paulis in a Stabilizer that have identity operators on all qubits corresponding to the given subset, without the entries corresponding to subset. Based on (<a href="../references/#goodenough2024bipartiteentanglementnoisystabilizer">Goodenough <em>et al.</em>, 2024</a>)</p><pre><code class="language-julia-repl hljs">julia&gt; contractor(S&quot;_X X_&quot;, [1])
+ X</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/grouptableaux.jl#L452-L460">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.delete_columns-Tuple{Stabilizer, Any}"><a class="docstring-binding" href="#QuantumClifford.delete_columns-Tuple{Stabilizer, Any}"><code>QuantumClifford.delete_columns</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Return the given stabilizer without all the qubits in the given iterable.</p><p>The resulting tableaux is not guaranteed to be valid (to retain its commutation relationships).</p><pre><code class="language-julia-repl hljs">julia&gt; delete_columns(S&quot;XYZ YZX ZXY&quot;, [1,3])
+ Y
+ Z
+ X</code></pre><p>See also: <a href="#QuantumInterface.traceout!-Tuple{Stabilizer, Any}"><code>traceout!</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L882-L895">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.destabilizerview-Tuple{Destabilizer}"><a class="docstring-binding" href="#QuantumClifford.destabilizerview-Tuple{Destabilizer}"><code>QuantumClifford.destabilizerview</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>A view of the subtableau corresponding to the destabilizer. See also <a href="#QuantumClifford.tab-Tuple{QuantumClifford.AbstractStabilizer}"><code>tab</code></a>, <a href="#QuantumClifford.stabilizerview-Tuple{Stabilizer}"><code>stabilizerview</code></a>, <a href="#QuantumClifford.logicalxview-Tuple{MixedDestabilizer}"><code>logicalxview</code></a>, <a href="#QuantumClifford.logicalzview-Tuple{MixedDestabilizer}"><code>logicalzview</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L662">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.enumerate_cliffords-Tuple{Any, Any}"><a class="docstring-binding" href="#QuantumClifford.enumerate_cliffords-Tuple{Any, Any}"><code>QuantumClifford.enumerate_cliffords</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Give the i-th n-qubit Clifford operation, where iâˆˆ{1..2â¿â¿Î â±¼â‚Œâ‚â¿(4Ê²-1)}</p><p>The algorithm is detailed in (<a href="../references/#koenig2014efficiently">Koenig and Smolin, 2014</a>).</p><p>See also: <a href="#QuantumClifford.symplecticGS-Tuple{PauliOperator}"><code>symplecticGS</code></a>, <a href="#QuantumClifford.clifford_cardinality-Tuple{Int64}"><code>clifford_cardinality</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/enumeration.jl#L156-L161">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.enumerate_cliffords-Tuple{Any}"><a class="docstring-binding" href="#QuantumClifford.enumerate_cliffords-Tuple{Any}"><code>QuantumClifford.enumerate_cliffords</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Give all n-qubit Clifford operations.</p><p>The algorithm is detailed in (<a href="../references/#koenig2014efficiently">Koenig and Smolin, 2014</a>).</p><p>See also: <a href="#QuantumClifford.symplecticGS-Tuple{PauliOperator}"><code>symplecticGS</code></a>, <a href="#QuantumClifford.clifford_cardinality-Tuple{Int64}"><code>clifford_cardinality</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/enumeration.jl#L195-L200">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.enumerate_phases-Tuple{CliffordOperator}"><a class="docstring-binding" href="#QuantumClifford.enumerate_phases-Tuple{CliffordOperator}"><code>QuantumClifford.enumerate_phases</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Given an operator, return all operators that have the same tableau but different phases.</p><pre><code class="language-julia-repl hljs">julia&gt; length(collect(enumerate_phases(tCNOT)))
16</code></pre><p>See also: <a href="#QuantumClifford.enumerate_cliffords-Tuple{Any, Any}"><code>enumerate_cliffords</code></a>, <a href="#QuantumClifford.clifford_cardinality-Tuple{Int64}"><code>clifford_cardinality</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/enumeration.jl#L214-L222">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.enumerate_phases-Tuple{Union{Base.Generator, AbstractVector}}"><a class="docstring-binding" href="#QuantumClifford.enumerate_phases-Tuple{Union{Base.Generator, AbstractVector}}"><code>QuantumClifford.enumerate_phases</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Given a set of operators, return all operators that have the same tableaux but different phases.</p><pre><code class="language-julia-repl hljs">julia&gt; length(collect(enumerate_phases(enumerate_cliffords(2))))
11520</code></pre><p>See also: <a href="#QuantumClifford.enumerate_cliffords-Tuple{Any, Any}"><code>enumerate_cliffords</code></a>, <a href="#QuantumClifford.clifford_cardinality-Tuple{Int64}"><code>clifford_cardinality</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/enumeration.jl#L227-L235">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.enumerate_single_qubit_gates-Tuple{Any}"><a class="docstring-binding" href="#QuantumClifford.enumerate_single_qubit_gates-Tuple{Any}"><code>QuantumClifford.enumerate_single_qubit_gates</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Generate a symbolic single-qubit gate given its index. Optionally, set non-trivial phases.</p><pre><code class="language-julia-repl hljs">julia&gt; enumerate_single_qubit_gates(6)
sPhase on qubit 1
Xâ‚ âŸ¼ + Y
Zâ‚ âŸ¼ + Z

julia&gt; enumerate_single_qubit_gates(6, qubit=2, phases=(true, true))
SingleQubitOperator on qubit 2
Xâ‚ âŸ¼ - Y
Zâ‚ âŸ¼ - Z</code></pre><p>See also: <a href="#QuantumClifford.enumerate_cliffords-Tuple{Any, Any}"><code>enumerate_cliffords</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/enumeration.jl#L10-L25">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.fastcolumn"><a class="docstring-binding" href="#QuantumClifford.fastcolumn"><code>QuantumClifford.fastcolumn</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>Convert a tableau to a memory layout that is fast for column operations.</p><p>In this layout a column of the tableau is stored (mostly) contiguously in memory. Due to bitpacking, e.g., packing 64 bits into a single <code>UInt64</code>, the memory layout is not perfectly contiguous, but it is still optimal given that some bitwrangling is required to extract a given bit.</p><p>See also: <a href="#QuantumClifford.fastrow"><code>fastrow</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/fastmemlayout.jl#L8-L16">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.fastrow"><a class="docstring-binding" href="#QuantumClifford.fastrow"><code>QuantumClifford.fastrow</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>Convert a tableau to a memory layout that is fast for row operations.</p><p>In this layout a Pauli string (a row of the tableau) is stored contiguously in memory.</p><p>See also: <a href="#QuantumClifford.fastrow"><code>fastrow</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/fastmemlayout.jl#L1-L6">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.generate!-Tuple{PauliOperator, Stabilizer}"><a class="docstring-binding" href="#QuantumClifford.generate!-Tuple{PauliOperator, Stabilizer}"><code>QuantumClifford.generate!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Generate a Pauli operator by using operators from a given the Stabilizer.</p><p><strong>It assumes the stabilizer is already canonicalized.</strong> It modifies the Pauli operator in place, generating it in reverse, up to a phase. That phase is left in the modified operator, which should be the identity up to a phase. Returns the new operator and the list of indices denoting the elements of <code>stabilizer</code> that were used for the generation.</p><pre><code class="language-julia-repl hljs">julia&gt; ghz = S&quot;XXXX
               ZZII
               IZZI
               IIZZ&quot;;


julia&gt; canonicalize!(ghz)
+ XXXX
+ Z__Z
+ _Z_Z
+ __ZZ

julia&gt; generate!(P&quot;-ZIZI&quot;, ghz)
(- ____, [2, 4])</code></pre><p>When the Pauli operator can not be generated by the given tableau, <code>nothing</code> is returned.</p><pre><code class="language-julia-repl hljs">julia&gt; generate!(P&quot;XII&quot;,canonicalize!(S&quot;ZII&quot;)) === nothing
true

julia&gt; generate!(P&quot;XII&quot;,canonicalize!(S&quot;XII&quot;)) === nothing
false</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L1-L36">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.gf2_H_to_G-Tuple{Any}"><a class="docstring-binding" href="#QuantumClifford.gf2_H_to_G-Tuple{Any}"><code>QuantumClifford.gf2_H_to_G</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>For a given F(2,2) parity check matrix, return the generator matrix.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L1201">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.gf2_gausselim!-Tuple{Any}"><a class="docstring-binding" href="#QuantumClifford.gf2_gausselim!-Tuple{Any}"><code>QuantumClifford.gf2_gausselim!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Gaussian elimination over the binary field.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L1146">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.gf2_invert-Tuple{Any}"><a class="docstring-binding" href="#QuantumClifford.gf2_invert-Tuple{Any}"><code>QuantumClifford.gf2_invert</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Invert a binary matrix.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L1176">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.gf2_isinvertible-Tuple{Any}"><a class="docstring-binding" href="#QuantumClifford.gf2_isinvertible-Tuple{Any}"><code>QuantumClifford.gf2_isinvertible</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Check whether a binary matrix is invertible.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L1170">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.ghz"><a class="docstring-binding" href="#QuantumClifford.ghz"><code>QuantumClifford.ghz</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>Prepare a GHZ state of n qubits.</p><pre><code class="language-julia-repl hljs">julia&gt; ghz()
+ XXX
+ ZZ_
+ _ZZ

julia&gt; ghz(2)
+ XX
+ ZZ

julia&gt; ghz(4)
+ XXXX
+ ZZ__
+ _ZZ_
+ __ZZ</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/useful_states.jl#L120-L139">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.graph_gate-NTuple{4, Any}"><a class="docstring-binding" href="#QuantumClifford.graph_gate-NTuple{4, Any}"><code>QuantumClifford.graph_gate</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>A helper function converting the gate indices from <a href="#QuantumClifford.graphstate-Tuple{QuantumClifford.AbstractStabilizer}"><code>graphstate</code></a> into a Clifford operator.</p><pre><code class="language-julia-repl hljs">julia&gt; s = S&quot; XXX
              YZ_
             -_ZZ&quot;;


julia&gt; graph, h_idx, ip_idx, z_idx = graphstate(s);


julia&gt; gate = graph_gate(h_idx, ip_idx, z_idx, nqubits(s));


julia&gt; apply!(s, gate) # This is now a graph state (notice you need to multiply row 1 by row 2)
+ YYZ
+ XZ_
+ _ZX

julia&gt; canonicalize!(s) == canonicalize!(Stabilizer(graph))
true</code></pre><p>See also: <a href="#QuantumClifford.graph_gatesequence-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}"><code>graph_gatesequence</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/graphs.jl#L225-L250">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.graph_gatesequence-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}"><a class="docstring-binding" href="#QuantumClifford.graph_gatesequence-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}"><code>QuantumClifford.graph_gatesequence</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>A helper function converting the gate indices from <a href="#QuantumClifford.graphstate-Tuple{QuantumClifford.AbstractStabilizer}"><code>graphstate</code></a> into a sequence of gates.</p><pre><code class="language-julia-repl hljs">julia&gt; s = S&quot; XXX
              YZ_
             -_ZZ&quot;;


julia&gt; graph, h_idx, ip_idx, z_idx = graphstate(s);


julia&gt; gates = graph_gatesequence(h_idx, ip_idx, z_idx);


julia&gt; for gate in vcat(gates...) apply!(s, gate) end


julia&gt; s # This is now a graph state (notice you need to multiply row 1 by row 2)
+ YYZ
+ XZ_
+ _ZX

julia&gt; canonicalize!(s) == canonicalize!(Stabilizer(graph))
true</code></pre><p>See also: <a href="#QuantumClifford.graph_gatesequence-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}"><code>graph_gatesequence</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/graphs.jl#L193-L221">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.graphstate!-Tuple{Stabilizer}"><a class="docstring-binding" href="#QuantumClifford.graphstate!-Tuple{Stabilizer}"><code>QuantumClifford.graphstate!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>An in-place version of <a href="#QuantumClifford.graphstate-Tuple{QuantumClifford.AbstractStabilizer}"><code>graphstate</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/graphs.jl#L77">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.graphstate-Tuple{QuantumClifford.AbstractStabilizer}"><a class="docstring-binding" href="#QuantumClifford.graphstate-Tuple{QuantumClifford.AbstractStabilizer}"><code>QuantumClifford.graphstate</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Convert any stabilizer state to a graph state</p><p><a href="https://en.wikipedia.org/wiki/Graph_state">Graph states</a> are a special type of entangled stabilizer states that can be represented by a graph. For a graph <span>$G=(V,E)$</span> the corresponding stabilizers are <span>$S_v = X_v \prod_{u âˆˆ N(v)} Z_u$</span>. Notice that such tableau rows contain only a single X operator. There is a set of single qubit gates that converts any stabilizer state to a graph state.</p><p>This function returns the graph state corresponding to a stabilizer and the gates that might be necessary to convert the stabilizer into a state representable as a graph.</p><p>For a tableau <code>stab</code> you can convert it with:</p><pre><code class="language-julia hljs">graph, hadamard_idx, iphase_idx, flips_idx = graphstate()</code></pre><p>where <code>graph</code> is the graph representation of <code>stab</code>, and the rest specifies the single-qubit gates converting <code>stab</code> to <code>graph</code>: <code>hadamard_idx</code> are the qubits that require a Hadamard gate (mapping X â†” Z), <code>iphase_idx</code> are (different) qubits that require an inverse Phase gate (Y â†’ X), and <code>flips_idx</code> are the qubits that require a phase flip (Pauli Z gate), after the previous two sets of gates.</p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs

julia&gt; s = S&quot; XXX
              ZZ_
             -_ZZ&quot;;


julia&gt; g, h_idx, ip_idx, z_idx = graphstate(s);


julia&gt; collect(edges(g))
2-element Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}:
 Edge 1 =&gt; 2
 Edge 1 =&gt; 3

julia&gt; h_idx
2-element Vector{Int64}:
 2
 3

julia&gt; ip_idx
Int64[]

julia&gt; z_idx
1-element Vector{Int64}:
 3</code></pre><p>The <code>Graphs.jl</code> library provides many graph-theory tools and the <code>MakieGraphs.jl</code> library provides plotting utilities for graphs.</p><p>You can directly call the graph constructor on a stabilizer, if you just want the graph and do not care about the Clifford operation necessary to convert an arbitrary state to a state representable as a graph:</p><pre><code class="language-julia-repl hljs">julia&gt; collect(edges( Graph(bell()) ))
1-element Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}:
 Edge 1 =&gt; 2</code></pre><p>For a version that does not copy the stabilizer, but rather performs transformations in-place, use <code>graphstate!</code>. It would perform <code>canonicalize_gott!</code> on its argument as it finds a way to convert it to a graph state.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/graphs.jl#L105-L175">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.groupify-Tuple{Stabilizer}"><a class="docstring-binding" href="#QuantumClifford.groupify-Tuple{Stabilizer}"><code>QuantumClifford.groupify</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Return the full stabilizer group represented by the input generating set (a <a href="#QuantumClifford.Stabilizer"><code>Stabilizer</code></a>).</p><p>The returned object is exponentially long.</p><pre><code class="language-julia-repl hljs">julia&gt; groupify(S&quot;XZ ZX&quot;)
+ __
+ XZ
+ ZX
+ YY</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/grouptableaux.jl#L108-L120">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.logdot-Tuple{QuantumClifford.AbstractStabilizer, QuantumClifford.AbstractStabilizer}"><a class="docstring-binding" href="#QuantumClifford.logdot-Tuple{QuantumClifford.AbstractStabilizer, QuantumClifford.AbstractStabilizer}"><code>QuantumClifford.logdot</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Logarithm of the inner product between to Stabilizer states.</p><p>If the result is <code>nothing</code>, the dot inner product is zero. Otherwise the inner product is <code>2^(-logdot/2)</code>.</p><p>The actual inner product can be computed with <code>LinearAlgebra.dot</code>.</p><p>Based on (<a href="../references/#garcia2012efficient">Garcia <em>et al.</em>, 2012</a>).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/linalg.jl#L90-L98">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.logicalxview-Tuple{MixedDestabilizer}"><a class="docstring-binding" href="#QuantumClifford.logicalxview-Tuple{MixedDestabilizer}"><code>QuantumClifford.logicalxview</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>A view of the subtableau corresponding to the logical X operators. See also <a href="#QuantumClifford.tab-Tuple{QuantumClifford.AbstractStabilizer}"><code>tab</code></a>, <a href="#QuantumClifford.stabilizerview-Tuple{Stabilizer}"><code>stabilizerview</code></a>, <a href="#QuantumClifford.destabilizerview-Tuple{Destabilizer}"><code>destabilizerview</code></a>, <a href="#QuantumClifford.logicalzview-Tuple{MixedDestabilizer}"><code>logicalzview</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L666">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.logicalzview-Tuple{MixedDestabilizer}"><a class="docstring-binding" href="#QuantumClifford.logicalzview-Tuple{MixedDestabilizer}"><code>QuantumClifford.logicalzview</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>A view of the subtableau corresponding to the logical Z operators. See also <a href="#QuantumClifford.tab-Tuple{QuantumClifford.AbstractStabilizer}"><code>tab</code></a>, <a href="#QuantumClifford.stabilizerview-Tuple{Stabilizer}"><code>stabilizerview</code></a>, <a href="#QuantumClifford.destabilizerview-Tuple{Destabilizer}"><code>destabilizerview</code></a>, <a href="#QuantumClifford.logicalxview-Tuple{MixedDestabilizer}"><code>logicalxview</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L668">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.matroid_parent-Tuple{QuantumClifford.Tableau}"><a class="docstring-binding" href="#QuantumClifford.matroid_parent-Tuple{QuantumClifford.Tableau}"><code>QuantumClifford.matroid_parent</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>For a given set S of Paulis that does not necessarily represent a state, return a set of Paulis S&#39; that represents a state. S&#39; is a superset of <a href="#QuantumClifford.commutify-Tuple{Any}">commutified</a> S. Additionally returns two arrays representing deletions needed to produce S. Based on (<a href="../references/#goodenough2024bipartiteentanglementnoisystabilizer">Goodenough <em>et al.</em>, 2024</a>)</p><p>By deleting the qubits in the first output array from S&#39;, taking the <a href="#QuantumClifford.normalizer-Tuple{QuantumClifford.Tableau}"><code>normalizer</code></a> of S&#39;, then deleting the qubits in the second returned array from the <a href="#QuantumClifford.normalizer-Tuple{QuantumClifford.Tableau}"><code>normalizer</code></a> of S&#39;, S is reproduced.</p><pre><code class="language-julia-repl hljs">julia&gt; matroid_parent(T&quot;XX&quot;)[1]
+ X_X
+ XX_
+ ZZZ

julia&gt; matroid_parent(T&quot;XX&quot;)[2]
3:3

julia&gt; matroid_parent(T&quot;XX&quot;)[3]
3:2</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/grouptableaux.jl#L289-L311">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.maximally_mixed-Tuple{Any}"><a class="docstring-binding" href="#QuantumClifford.maximally_mixed-Tuple{Any}"><code>QuantumClifford.maximally_mixed</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Prepare a maximally mixed state of n qubits.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/useful_states.jl#L160-L162">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.mctrajectories-Tuple{Any, Any}"><a class="docstring-binding" href="#QuantumClifford.mctrajectories-Tuple{Any, Any}"><code>QuantumClifford.mctrajectories</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Run multiple Monte Carlo trajectories and report the aggregate final statuses of each.</p><p>See also: <a href="#QuantumClifford.pftrajectories"><code>pftrajectories</code></a>, <a href="#QuantumClifford.petrajectories-Tuple{Any, Any}"><code>petrajectories</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/mctrajectory.jl#L59-L62">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.mctrajectory!-Tuple{Any, Any}"><a class="docstring-binding" href="#QuantumClifford.mctrajectory!-Tuple{Any, Any}"><code>QuantumClifford.mctrajectory!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Run a single Monte Carlo sample, starting with (and modifying) <code>state</code> by applying the given <code>circuit</code>. Uses <code>apply!</code> under the hood.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/mctrajectory.jl#L40">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.minimal_generating_set-Tuple{Stabilizer}"><a class="docstring-binding" href="#QuantumClifford.minimal_generating_set-Tuple{Stabilizer}"><code>QuantumClifford.minimal_generating_set</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>For a not-necessarily-minimal generating set, return the minimal generating set.</p><p>The input has to have only real phases.</p><pre><code class="language-julia-repl hljs">julia&gt; minimal_generating_set(S&quot;__ XZ ZX YY&quot;)
+ XZ
+ ZX</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/grouptableaux.jl#L142-L153">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.normalizer-Tuple{QuantumClifford.Tableau}"><a class="docstring-binding" href="#QuantumClifford.normalizer-Tuple{QuantumClifford.Tableau}"><code>QuantumClifford.normalizer</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Return all Pauli operators with the same number of qubits as the given <code>Tableau</code> <code>t</code> that commute with all operators in <code>t</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; normalizer(T&quot;X&quot;)
+ _
+ X</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/grouptableaux.jl#L380-L389">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.pauligroup-Tuple{Int64}"><a class="docstring-binding" href="#QuantumClifford.pauligroup-Tuple{Int64}"><code>QuantumClifford.pauligroup</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Return the full Pauli group of a given length. Phases are ignored by default, but can be included by setting <code>phases=true</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; pauligroup(1)
+ _
+ X
+ Z
+ Y

julia&gt; pauligroup(1, phases=true)
+ _
+ X
+ Z
+ Y
- _
- X
- Z
- Y
+i_
+iX
+iZ
+iY
-i_
-iX
-iZ
-iY</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/grouptableaux.jl#L319-L348">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.petrajectories-Tuple{Any, Any}"><a class="docstring-binding" href="#QuantumClifford.petrajectories-Tuple{Any, Any}"><code>QuantumClifford.petrajectories</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Run a perturbative expansion to a given order. This is the main public function for the perturbative expansion approach.</p><p>See also: <a href="#QuantumClifford.pftrajectories"><code>pftrajectories</code></a>, <a href="#QuantumClifford.mctrajectories-Tuple{Any, Any}"><code>mctrajectories</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/petrajectory.jl#L69-L72">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.pfmeasurements-Tuple{PauliFrame}"><a class="docstring-binding" href="#QuantumClifford.pfmeasurements-Tuple{PauliFrame}"><code>QuantumClifford.pfmeasurements</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">pfmeasurements(frame::PauliFrame) -&gt; Any
</code></pre><p>Returns the measurement results for each frame in the <a href="#QuantumClifford.PauliFrame"><code>PauliFrame</code></a> instance.</p><div class="admonition is-warning" id="Relative-measurements-7376ddb5d173bbca"><header class="admonition-header">Relative measurements<a class="admonition-anchor" href="#Relative-measurements-7376ddb5d173bbca" title="Permalink"></a></header><div class="admonition-body"><p>The return measurements are relative to the reference measurements, i.e. they only say whether the reference measurements have been flipped in the given frame.</p></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/pauli_frames.jl#L271">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.pfmeasurements-Tuple{Register, PauliFrame}"><a class="docstring-binding" href="#QuantumClifford.pfmeasurements-Tuple{Register, PauliFrame}"><code>QuantumClifford.pfmeasurements</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">pfmeasurements(register::Register, frame::PauliFrame) -&gt; Any
</code></pre><p>Takes the references measurements from the given <a href="#QuantumClifford.Register"><code>Register</code></a> and applies the flips as prescribed by the <a href="#QuantumClifford.PauliFrame"><code>PauliFrame</code></a> relative measurements. The result is the actual (non-relative) measurement results for each frame.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/pauli_frames.jl#L282">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.pfmeasurements-Tuple{Register}"><a class="docstring-binding" href="#QuantumClifford.pfmeasurements-Tuple{Register}"><code>QuantumClifford.pfmeasurements</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">pfmeasurements(register::Register) -&gt; Vector{Bool}
</code></pre><p>Returns the measurements stored in the bits of the given <a href="#QuantumClifford.Register"><code>Register</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/pauli_frames.jl#L264">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.pftrajectories"><a class="docstring-binding" href="#QuantumClifford.pftrajectories"><code>QuantumClifford.pftrajectories</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>Perform a &quot;Pauli frame&quot; style simulation of a quantum circuit.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/pauli_frames.jl#L176-L178">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.pftrajectories-Tuple{Any}"><a class="docstring-binding" href="#QuantumClifford.pftrajectories-Tuple{Any}"><code>QuantumClifford.pftrajectories</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">pftrajectories(
    circuit;
    trajectories,
    threads
) -&gt; PauliFrame{Stabilizer{QuantumClifford.Tableau{Vector{UInt8}, LinearAlgebra.Adjoint{UInt64, Matrix{UInt64}}}}, Matrix{Bool}}
</code></pre><p>The main method for running Pauli frame simulations of circuits. See the other methods for lower level access.</p><p>Multithreading is enabled by default, but can be disabled by setting <code>threads=false</code>. Do not forget to launch Julia with multiple threads enabled, e.g. <code>julia -t4</code>, if you want to use multithreading.</p><p>See also: <a href="#QuantumClifford.mctrajectories-Tuple{Any, Any}"><code>mctrajectories</code></a>, <a href="#QuantumClifford.petrajectories-Tuple{Any, Any}"><code>petrajectories</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/pauli_frames.jl#L181">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.pftrajectories-Tuple{PauliFrame, Any}"><a class="docstring-binding" href="#QuantumClifford.pftrajectories-Tuple{PauliFrame, Any}"><code>QuantumClifford.pftrajectories</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">pftrajectories(state::PauliFrame, circuit) -&gt; PauliFrame
</code></pre><p>Evolve each frame stored in <a href="#QuantumClifford.PauliFrame"><code>PauliFrame</code></a> by the given circuit.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/pauli_frames.jl#L229">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.pftrajectories-Tuple{Register, Any}"><a class="docstring-binding" href="#QuantumClifford.pftrajectories-Tuple{Register, Any}"><code>QuantumClifford.pftrajectories</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">pftrajectories(
    register::Register,
    circuit;
    trajectories
) -&gt; Tuple{Register, PauliFrame{Stabilizer{QuantumClifford.Tableau{Vector{UInt8}, LinearAlgebra.Adjoint{UInt64, Matrix{UInt64}}}}, Matrix{Bool}}}
</code></pre><p>For a given <a href="#QuantumClifford.Register"><code>Register</code></a> and circuit, simulates the reference circuit acting on the register and then also simulate numerous <a href="#QuantumClifford.PauliFrame"><code>PauliFrame</code></a> trajectories. Returns the register and the <a href="#QuantumClifford.PauliFrame"><code>PauliFrame</code></a> instance.</p><p>Use <a href="#QuantumClifford.pfmeasurements-Tuple{PauliFrame}"><code>pfmeasurements</code></a> to get the measurement results.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/pauli_frames.jl#L241">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.phases-Tuple{QuantumClifford.Tableau}"><a class="docstring-binding" href="#QuantumClifford.phases-Tuple{QuantumClifford.Tableau}"><code>QuantumClifford.phases</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>The phases of a given tableau. It is a view, i.e. if you modify this array, the original tableau caries these changes.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L675">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.prodphase-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Unsigned"><a class="docstring-binding" href="#QuantumClifford.prodphase-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Unsigned"><code>QuantumClifford.prodphase</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Get the phase of the product of two Pauli operators.</p><p>Phase is encoded as F(4) in the low qubits of an UInt8.</p><pre><code class="language-julia-repl hljs">julia&gt; P&quot;ZZZ&quot;*P&quot;XXX&quot;
-iYYY

julia&gt; prodphase(P&quot;ZZZ&quot;, P&quot;XXX&quot;)
0x03

julia&gt; prodphase(P&quot;XXX&quot;, P&quot;ZZZ&quot;)
0x01</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L683-L698">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.projectXrand!-Tuple{Any, Any}"><a class="docstring-binding" href="#QuantumClifford.projectXrand!-Tuple{Any, Any}"><code>QuantumClifford.projectXrand!</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">projectXrand!(state, qubit) -&gt; Tuple{Register, UInt8}
</code></pre><p>Project <code>qubit</code> of <code>state</code> along the X axis and randomize the phase if necessary.</p><p>Lower boilerplate version of <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>.</p><p>See also: <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>, <a href="#QuantumInterface.projectX!-Tuple{MixedDestabilizer, Int64}"><code>projectX!</code></a>, <a href="#QuantumClifford.projectZrand!-Tuple{Any, Any}"><code>projectZrand!</code></a>, <a href="#QuantumClifford.projectYrand!-Tuple{Any, Any}"><code>projectYrand!</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L575">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.projectYrand!-Tuple{Any, Any}"><a class="docstring-binding" href="#QuantumClifford.projectYrand!-Tuple{Any, Any}"><code>QuantumClifford.projectYrand!</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">projectYrand!(state, qubit) -&gt; Tuple{Register, UInt8}
</code></pre><p>Project <code>qubit</code> of <code>state</code> along the Y axis and randomize the phase if necessary.</p><p>Lower boilerplate version of <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>.</p><p>See also: <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>, <a href="#QuantumInterface.projectY!-Tuple{MixedDestabilizer, Int64}"><code>projectY!</code></a>, <a href="#QuantumClifford.projectXrand!-Tuple{Any, Any}"><code>projectXrand!</code></a>, <a href="#QuantumClifford.projectZrand!-Tuple{Any, Any}"><code>projectZrand!</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L605">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.projectZrand!-Tuple{Any, Any}"><a class="docstring-binding" href="#QuantumClifford.projectZrand!-Tuple{Any, Any}"><code>QuantumClifford.projectZrand!</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">projectZrand!(state, qubit) -&gt; Tuple{Register, UInt8}
</code></pre><p>Project <code>qubit</code> of <code>state</code> along the Z axis and randomize the phase if necessary.</p><p>Lower boilerplate version of <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>.</p><p>See also: <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>, <a href="#QuantumInterface.projectZ!-Tuple{MixedDestabilizer, Int64}"><code>projectZ!</code></a>, <a href="#QuantumClifford.projectXrand!-Tuple{Any, Any}"><code>projectXrand!</code></a>, <a href="#QuantumClifford.projectYrand!-Tuple{Any, Any}"><code>projectYrand!</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L590">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.projectrand!-Tuple{Any, Any}"><a class="docstring-binding" href="#QuantumClifford.projectrand!-Tuple{Any, Any}"><code>QuantumClifford.projectrand!</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">projectrand!(
    state,
    pauli
) -&gt; Tuple{QuantumClifford.AbstractStabilizer, Any}
</code></pre><p>Measure <code>pauli</code> operator on <code>state</code> and randomize the phase if necessary.</p><p>Lower boilerplate version of <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>.</p><p>See also: <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>, <a href="#QuantumClifford.projectXrand!-Tuple{Any, Any}"><code>projectXrand!</code></a>, <a href="#QuantumClifford.projectZrand!-Tuple{Any, Any}"><code>projectZrand!</code></a>, <a href="#QuantumClifford.projectYrand!-Tuple{Any, Any}"><code>projectYrand!</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L620">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.projectrand!-Tuple{GeneralizedStabilizer, PauliOperator}"><a class="docstring-binding" href="#QuantumClifford.projectrand!-Tuple{GeneralizedStabilizer, PauliOperator}"><code>QuantumClifford.projectrand!</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">projectrand!(
    sm::GeneralizedStabilizer,
    p::PauliOperator
) -&gt; Tuple{GeneralizedStabilizer, UInt8}
</code></pre><p>Performs a randomized projection of the state represented by the <a href="#QuantumClifford.GeneralizedStabilizer"><code>GeneralizedStabilizer</code></a> <code>sm</code>, based on the measurement of a <a href="#QuantumClifford.PauliOperator">PauliOperator</a> <code>p</code>.</p><p>Unlike in the case of stabilizer states, the expectation value Ï‡â€² of a Pauli operator with respect to these more general states can be any real number between -1 and 1. The expectation value can be calculated with <code>expect(p, sm)</code>.</p><p class="math-container">\[\chi&#39; = \langle p \rangle = \text{expect}(p, sm)\]</p><p>To convert Ï‡â€² into a probability of projecting on the +1 eigenvalue branch:</p><p class="math-container">\[\text{probability}_{1} = \frac{\text{real}(\chi&#39;) + 1}{2}\]</p><div class="admonition is-info" id="Note-a9036ef3f1ceef4a"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a9036ef3f1ceef4a" title="Permalink"></a></header><div class="admonition-body"><p>Because the possible measurement results are themselves not stabilizer states anymore, we can not use the <code>project!</code> API, which assumes a stabilizer tableau and reports detailed information about whether the tableau and measurement commute or anticommute.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; sm = GeneralizedStabilizer(S&quot;-X&quot;);

julia&gt; apply!(sm, pcT)
A mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z
ğ’®ğ“‰ğ’¶ğ’·
- X
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 0.0+0.353553im | + _ | + Z
 0.0-0.353553im | + Z | + _
 0.853553+0.0im | + _ | + _
 0.146447+0.0im | + Z | + Z

julia&gt; Ï‡â€² = expect(P&quot;-X&quot;, sm)
0.7071067811865475 + 0.0im

julia&gt; probâ‚ = (real(Ï‡â€²)+1)/2
0.8535533905932737

julia&gt; QuantumClifford._projectrand_notnorm(copy(sm), P&quot;X&quot;, 0)[1]
A mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z
ğ’®ğ“‰ğ’¶ğ’·
- X
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 0.146447+0.0im | + Z | + Z

julia&gt; QuantumClifford._projectrand_notnorm(copy(sm), P&quot;X&quot;, 1)[1]
A mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z
ğ’®ğ“‰ğ’¶ğ’·
- X
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 0.853553+0.0im | + _ | + _</code></pre><p>See also: <a href="#QuantumInterface.expect-Tuple{PauliOperator, GeneralizedStabilizer}"><code>expect</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/nonclifford.jl#L266">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.puttableau!-Union{Tuple{M2}, Tuple{M1}, Tuple{T}, Tuple{V2}, Tuple{V1}, Tuple{B}, Tuple{QuantumClifford.Tableau{V1, M1}, QuantumClifford.Tableau{V2, M2}, Int64, Int64}} where {B, V1, V2, T&lt;:Unsigned, M1&lt;:AbstractMatrix{T}, M2&lt;:AbstractMatrix{T}}"><a class="docstring-binding" href="#QuantumClifford.puttableau!-Union{Tuple{M2}, Tuple{M1}, Tuple{T}, Tuple{V2}, Tuple{V1}, Tuple{B}, Tuple{QuantumClifford.Tableau{V1, M1}, QuantumClifford.Tableau{V2, M2}, Int64, Int64}} where {B, V1, V2, T&lt;:Unsigned, M1&lt;:AbstractMatrix{T}, M2&lt;:AbstractMatrix{T}}"><code>QuantumClifford.puttableau!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Put source tableau in target tableau at given row and column. Assumes target location is zeroed out.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L754">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.quantumstate"><a class="docstring-binding" href="#QuantumClifford.quantumstate"><code>QuantumClifford.quantumstate</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>Only the quantum part of the state (excluding classical bits)</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/classical_register.jl#L28">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.random_all_to_all_clifford_circuit-Tuple{Random.AbstractRNG, Int64, Int64}"><a class="docstring-binding" href="#QuantumClifford.random_all_to_all_clifford_circuit-Tuple{Random.AbstractRNG, Int64, Int64}"><code>QuantumClifford.random_all_to_all_clifford_circuit</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Random all-to-all Clifford circuit.</p><p>The circuit contains <code>nqubits</code> qubits and <code>ngates</code> gates. The connectivity is all to all. Each gate in the circuit is a random 2-qubit Clifford gate on randomly picked two qubits.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/randoms.jl#L573-L577">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.random_brickwork_clifford_circuit-Tuple{Random.AbstractRNG, NTuple{N, Int64} where N, Int64}"><a class="docstring-binding" href="#QuantumClifford.random_brickwork_clifford_circuit-Tuple{Random.AbstractRNG, NTuple{N, Int64} where N, Int64}"><code>QuantumClifford.random_brickwork_clifford_circuit</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Random brickwork Clifford circuit.</p><p>The connectivity of the random circuit is brickwork in some dimensions. Each gate in the circuit is a random 2-qubit Clifford gate.</p><p>The brickwork is defined as follows: The qubits are arranged as a lattice, and <code>lattice_size</code> contains side length in each dimension. For example, a chain of length five will have <code>lattice_size = (5,)</code>, and a 5Ã—5 lattice will have <code>lattice_size = (5, 5)</code>.</p><p>In multi-dimensional cases, gate layers act alternatively along each direction. The nearest two layers along the same direction are offset by one qubit, forming a so-called brickwork. The boundary condition is chosen as open.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/randoms.jl#L536-L547">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.random_clifford-Tuple{Random.AbstractRNG, Int64}"><a class="docstring-binding" href="#QuantumClifford.random_clifford-Tuple{Random.AbstractRNG, Int64}"><code>QuantumClifford.random_clifford</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>A random Clifford operator generated by the Bravyi-Maslov Algorithm 2 from (<a href="../references/#bravyi2020hadamard">Bravyi and Maslov, 2021</a>).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/randoms.jl#L434">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.random_clifford1-Tuple{Random.AbstractRNG, Any}"><a class="docstring-binding" href="#QuantumClifford.random_clifford1-Tuple{Random.AbstractRNG, Any}"><code>QuantumClifford.random_clifford1</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Random symbolic single-qubit Clifford applied to qubit at index <code>qubit</code>.</p><p>See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.random_clifford-Tuple{Random.AbstractRNG, Int64}"><code>random_clifford</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L260-L264">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.random_destabilizer-Tuple{Random.AbstractRNG, Int64}"><a class="docstring-binding" href="#QuantumClifford.random_destabilizer-Tuple{Random.AbstractRNG, Int64}"><code>QuantumClifford.random_destabilizer</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>A random Stabilizer/Destabilizer tableau generated by the Bravyi-Maslov Algorithm 2 from (<a href="../references/#bravyi2020hadamard">Bravyi and Maslov, 2021</a>).</p><p><code>random_destabilizer(n)</code> gives a n-qubit tableau of rank <code>n</code>. <code>random_destabilizer(r,n)</code> gives a n-qubit tableau of rank <code>r</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/randoms.jl#L151-L155">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.random_pauli"><a class="docstring-binding" href="#QuantumClifford.random_pauli"><code>QuantumClifford.random_pauli</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>A random Pauli operator on n qubits.</p><p>Use <code>nophase=false</code> to randomize the phase. Use <code>realphase=false</code> to get operators with phases including Â±i.</p><p>Optionally, a &quot;flip&quot; probability <code>p</code> can be provided specified, in which case each bit is set to I with probability <code>1-p</code> and to X or Y or Z with probability <code>p</code>. Useful for simulating unbiased Pauli noise.</p><p>See also <a href="#QuantumClifford.random_pauli!"><code>random_pauli!</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/randoms.jl#L32-L43">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.random_pauli!"><a class="docstring-binding" href="#QuantumClifford.random_pauli!"><code>QuantumClifford.random_pauli!</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>An in-place version of <a href="#QuantumClifford.random_pauli"><code>random_pauli</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/randoms.jl#L44">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.random_stabilizer-Tuple{Random.AbstractRNG, Int64}"><a class="docstring-binding" href="#QuantumClifford.random_stabilizer-Tuple{Random.AbstractRNG, Int64}"><code>QuantumClifford.random_stabilizer</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>A random Stabilizer tableau generated by the Bravyi-Maslov Algorithm 2 from (<a href="../references/#bravyi2020hadamard">Bravyi and Maslov, 2021</a>).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/randoms.jl#L439">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.single_x-Tuple{Any, Any}"><a class="docstring-binding" href="#QuantumClifford.single_x-Tuple{Any, Any}"><code>QuantumClifford.single_x</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>A multiqubit operator corresponding to all identities except for Pauli X at <code>i</code>. See also: <a href="#QuantumClifford.sX"><code>sX</code></a>, <a href="#QuantumClifford.sMX"><code>sMX</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/useful_states.jl#L8">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.single_y-Tuple{Any, Any}"><a class="docstring-binding" href="#QuantumClifford.single_y-Tuple{Any, Any}"><code>QuantumClifford.single_y</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>A multiqubit operator corresponding to all identities except for Pauli Y at <code>i</code>. See also: <a href="#QuantumClifford.sY"><code>sY</code></a>, <a href="#QuantumClifford.sMY"><code>sMY</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/useful_states.jl#L15">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.single_z-Tuple{Any, Any}"><a class="docstring-binding" href="#QuantumClifford.single_z-Tuple{Any, Any}"><code>QuantumClifford.single_z</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>A multiqubit operator corresponding to all identities except for Pauli Z at <code>i</code>. See also: <a href="#QuantumClifford.sY"><code>sY</code></a>, <a href="#QuantumClifford.sMY"><code>sMY</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/useful_states.jl#L1">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.stab_to_gf2-Tuple{QuantumClifford.Tableau}"><a class="docstring-binding" href="#QuantumClifford.stab_to_gf2-Tuple{QuantumClifford.Tableau}"><code>QuantumClifford.stab_to_gf2</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>The F(2,2) matrix of a given tableau, represented as the concatenation of two binary matrices, one for X and one for Z.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L1125">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.stabilizerplot"><a class="docstring-binding" href="#QuantumClifford.stabilizerplot"><code>QuantumClifford.stabilizerplot</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>A Makie.jl recipe for pictorial representation of a tableau.</p><p>Requires a Makie.jl backend to be loaded, e.g. <code>using CairoMakie</code>.</p><p>Alternatively, you can use the Plots.jl plotting ecosystem, e.g. <code>using Plots; plot(S&quot;XXX ZZZ&quot;)</code>.</p><p>Consult the documentation for more details on visualization options.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/plotting_extensions.jl#L11-L19">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.stabilizerplot_axis"><a class="docstring-binding" href="#QuantumClifford.stabilizerplot_axis"><code>QuantumClifford.stabilizerplot_axis</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>A Makie.jl recipe for pictorial representation of a tableau.</p><p>Requires a Makie.jl backend to be loaded, e.g. <code>using CairoMakie</code>.</p><p>Alternatively, you can use the Plots.jl plotting ecosystem, e.g. <code>using Plots; plot(S&quot;XXX ZZZ&quot;)</code>.</p><p>Consult the documentation for more details on visualization options.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/plotting_extensions.jl#L20-L28">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.stabilizerview-Tuple{Stabilizer}"><a class="docstring-binding" href="#QuantumClifford.stabilizerview-Tuple{Stabilizer}"><code>QuantumClifford.stabilizerview</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>A view of the subtableau corresponding to the stabilizer. See also <a href="#QuantumClifford.tab-Tuple{QuantumClifford.AbstractStabilizer}"><code>tab</code></a>, <a href="#QuantumClifford.destabilizerview-Tuple{Destabilizer}"><code>destabilizerview</code></a>, <a href="#QuantumClifford.logicalxview-Tuple{MixedDestabilizer}"><code>logicalxview</code></a>, <a href="#QuantumClifford.logicalzview-Tuple{MixedDestabilizer}"><code>logicalzview</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L656">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.symplecticGS-Tuple{PauliOperator}"><a class="docstring-binding" href="#QuantumClifford.symplecticGS-Tuple{PauliOperator}"><code>QuantumClifford.symplecticGS</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Perform the Symplectic Gram-Schmidt procedure that gives a Clifford operator canonically related to a given Pauli operator.</p><p>The algorithm is detailed in (<a href="../references/#koenig2014efficiently">Koenig and Smolin, 2014</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; symplecticGS(P&quot;X&quot;, padded_n=3)
Xâ‚ âŸ¼ + X__
Xâ‚‚ âŸ¼ + _X_
Xâ‚ƒ âŸ¼ + __X
Zâ‚ âŸ¼ + Z__
Zâ‚‚ âŸ¼ + _Z_
Zâ‚ƒ âŸ¼ + __Z

julia&gt; symplecticGS(P&quot;Z&quot;)
Xâ‚ âŸ¼ + Z
Zâ‚ âŸ¼ + X</code></pre><p>See also: <a href="#QuantumClifford.enumerate_cliffords-Tuple{Any, Any}"><code>enumerate_cliffords</code></a>, <a href="#QuantumClifford.clifford_cardinality-Tuple{Int64}"><code>clifford_cardinality</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/enumeration.jl#L106-L125">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.tab-Tuple{QuantumClifford.AbstractStabilizer}"><a class="docstring-binding" href="#QuantumClifford.tab-Tuple{QuantumClifford.AbstractStabilizer}"><code>QuantumClifford.tab</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Extract the underlying tableau structure.</p><pre><code class="language-julia-repl hljs">julia&gt; s = S&quot;X&quot;
+ X

julia&gt; tab(s)
+ X

julia&gt; tab(Destabilizer(s))
+ Z
+ X

julia&gt; tab(MixedDestabilizer(s))
+ Z
+ X

julia&gt; tab(tHadamard)
+ Z
+ X

julia&gt; typeof(tab(tHadamard))
QuantumClifford.Tableau{Vector{UInt8}, Matrix{UInt64}}</code></pre><p>See also: <a href="#QuantumClifford.stabilizerview-Tuple{Stabilizer}"><code>stabilizerview</code></a>, <a href="#QuantumClifford.destabilizerview-Tuple{Destabilizer}"><code>destabilizerview</code></a>, <a href="#QuantumClifford.logicalxview-Tuple{MixedDestabilizer}"><code>logicalxview</code></a>, <a href="#QuantumClifford.logicalzview-Tuple{MixedDestabilizer}"><code>logicalzview</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L431-L458">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.xbit-Tuple{PauliOperator}"><a class="docstring-binding" href="#QuantumClifford.xbit-Tuple{PauliOperator}"><code>QuantumClifford.xbit</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Extract as a new bit array the X part of the <code>UInt</code> array of packed qubits of a given Pauli operator.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/pauli_operator.jl#L84">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.xview-Tuple{PauliOperator}"><a class="docstring-binding" href="#QuantumClifford.xview-Tuple{PauliOperator}"><code>QuantumClifford.xview</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Get a view of the X part of the <code>UInt</code> array of packed qubits of a given Pauli operator.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/pauli_operator.jl#L76">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.zbit-Tuple{PauliOperator}"><a class="docstring-binding" href="#QuantumClifford.zbit-Tuple{PauliOperator}"><code>QuantumClifford.zbit</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Extract as a new bit array the Z part of the <code>UInt</code> array of packed qubits of a given Pauli operator.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/pauli_operator.jl#L90">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.zview-Tuple{PauliOperator}"><a class="docstring-binding" href="#QuantumClifford.zview-Tuple{PauliOperator}"><code>QuantumClifford.zview</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Get a view of the Y part of the <code>UInt</code> array of packed qubits of a given Pauli operator.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/pauli_operator.jl#L80">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.:âŠ—-Tuple{GeneralizedStabilizer, GeneralizedStabilizer}"><a class="docstring-binding" href="#QuantumInterface.:âŠ—-Tuple{GeneralizedStabilizer, GeneralizedStabilizer}"><code>QuantumInterface.:âŠ—</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">âŠ—(
    stateâ‚::GeneralizedStabilizer,
    stateâ‚‚::GeneralizedStabilizer
) -&gt; GeneralizedStabilizer
</code></pre><p>Tensor product of <a href="#QuantumClifford.GeneralizedStabilizer"><code>GeneralizedStabilizer</code></a> states.</p><p><strong>Stabilizer state</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sm = GeneralizedStabilizer(S&quot;-X&quot;)
A mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z
ğ’®ğ“‰ğ’¶ğ’·
- X
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 1.0+0.0im | + _ | + _

julia&gt; sm âŠ— sm
A mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z_
+ _Z
ğ’®ğ“‰ğ’¶ğ’·
- X_
- _X
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 1.0+0.0im | + __ | + __</code></pre><p><strong>Arbitrary state</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra; # hide

julia&gt; sm = GeneralizedStabilizer(ghz(2))
A mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z_
+ _X
ğ’®ğ“‰ğ’¶ğ’·
+ XX
+ ZZ
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 1.0+0.0im | + __ | + __

julia&gt; apply!(sm, embed(2, 2, pcT))
A mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z_
+ _X
ğ’®ğ“‰ğ’¶ğ’·
+ XX
+ ZZ
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 0.853553+0.0im | + __ | + __
 0.0+0.353553im | + __ | + Z_
 0.0-0.353553im | + Z_ | + __
 0.146447+0.0im | + Z_ | + Z_

julia&gt; newsm = sm âŠ— sm
A mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z___
+ _X__
+ __Z_
+ ___X
ğ’®ğ“‰ğ’¶ğ’·â”â”
+ XX__
+ ZZ__
+ __XX
+ __ZZ
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 0.0-0.301777im | + Z___ | + ____
 -0.125+0.0im | + Z_Z_ | + ____
 0.125+0.0im | + Z___ | + Z___
 0.728553+0.0im | + ____ | + ____
 0.0-0.0517767im | + Z_Z_ | + Z___
 0.0-0.301777im | + __Z_ | + ____
 0.0+0.301777im | + ____ | + Z___
 0.125+0.0im | + __Z_ | + Z___
 0.125+0.0im | + Z___ | + __Z_
 0.0-0.0517767im | + Z_Z_ | + __Z_
 0.0+0.0517767im | + Z___ | + Z_Z_
 0.0+0.301777im | + ____ | + __Z_
 0.0214466+0.0im | + Z_Z_ | + Z_Z_
 0.125+0.0im | + __Z_ | + __Z_
 -0.125+0.0im | + ____ | + Z_Z_
 0.0+0.0517767im | + __Z_ | + Z_Z_

julia&gt; real(tr(newsm))
1.0</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/nonclifford.jl#L428">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.apply!"><a class="docstring-binding" href="#QuantumInterface.apply!"><code>QuantumInterface.apply!</code></a> â€” <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">apply!</code></pre><p>Apply any quantum operation to a stabilizer state, including unitary Clifford operations, Pauli measurements, and noise. May result in a random/stochastic result (e.g. with measurements or noise).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L1045-L1050">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.apply!-Tuple{GeneralizedStabilizer, QuantumClifford.AbstractCliffordOperator}"><a class="docstring-binding" href="#QuantumInterface.apply!-Tuple{GeneralizedStabilizer, QuantumClifford.AbstractCliffordOperator}"><code>QuantumInterface.apply!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Apply a Clifford gate to a generalized stabilizer state, i.e. a weighted sum of stabilizer states.</p><pre><code class="language-julia-repl hljs">julia&gt; sm = GeneralizedStabilizer(S&quot;-X&quot;)
A mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z
ğ’®ğ“‰ğ’¶ğ’·
- X
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 1.0+0.0im | + _ | + _

julia&gt; apply!(sm, CliffordOperator(tHadamard))
A mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ X
ğ’®ğ“‰ğ’¶ğ’·
- Z
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 1.0+0.0im | + _ | + _</code></pre><p>See also: <a href="#QuantumClifford.GeneralizedStabilizer"><code>GeneralizedStabilizer</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/nonclifford.jl#L77-L101">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.apply!-Tuple{GeneralizedStabilizer, QuantumClifford.AbstractPauliChannel}"><a class="docstring-binding" href="#QuantumInterface.apply!-Tuple{GeneralizedStabilizer, QuantumClifford.AbstractPauliChannel}"><code>QuantumInterface.apply!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Applies a (potentially non-unitary) Pauli channel to a generalized stabilizer.</p><p>See also: <a href="#QuantumClifford.GeneralizedStabilizer"><code>GeneralizedStabilizer</code></a>, <a href="#QuantumClifford.PauliChannel"><code>PauliChannel</code></a>, <a href="#QuantumClifford.UnitaryPauliChannel"><code>UnitaryPauliChannel</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/nonclifford.jl#L399-L403">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.embed-Tuple{Int64, Int64, PauliOperator}"><a class="docstring-binding" href="#QuantumInterface.embed-Tuple{Int64, Int64, PauliOperator}"><code>QuantumInterface.embed</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Embed a Pauli operator in a larger Pauli operator.</p><pre><code class="language-julia-repl hljs">julia&gt; embed(5, 3, P&quot;-Y&quot;)
- __Y__

julia&gt; embed(5, (3,5), P&quot;-YX&quot;)
- __Y_X</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/pauli_operator.jl#L184-L194">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.entanglement_entropy"><a class="docstring-binding" href="#QuantumInterface.entanglement_entropy"><code>QuantumInterface.entanglement_entropy</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>Get bipartite entanglement entropy of a subsystem</p><p>Defined as entropy of the reduced density matrix.</p><p>It can be calculated with multiple different algorithms, the most performant one depending on the particular case.</p><p>Currently implemented are the <code>:clip</code> (clipped gauge), <code>:graph</code> (graph state), and <code>:rref</code> (Gaussian elimination) algorithms. Benchmark your particular case to choose the best one.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/entanglement.jl#L163">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.entanglement_entropy-Tuple{QuantumClifford.AbstractStabilizer, AbstractVector, Val{:graph}}"><a class="docstring-binding" href="#QuantumInterface.entanglement_entropy-Tuple{QuantumClifford.AbstractStabilizer, AbstractVector, Val{:graph}}"><code>QuantumInterface.entanglement_entropy</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Get bipartite entanglement entropy by first converting the state to a graph and computing the rank of the adjacency matrix.</p><p>Based on &quot;Entanglement in graph states and its applications&quot;.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/entanglement.jl#L196-L200">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.entanglement_entropy-Tuple{QuantumClifford.AbstractStabilizer, AbstractVector, Val{:rref}}"><a class="docstring-binding" href="#QuantumInterface.entanglement_entropy-Tuple{QuantumClifford.AbstractStabilizer, AbstractVector, Val{:rref}}"><code>QuantumInterface.entanglement_entropy</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Get bipartite entanglement entropy by converting to RREF form (i.e., partial trace form).</p><p>The state will be partially canonicalized in an RREF form.</p><p>See also: <a href="#QuantumClifford.canonicalize_rref!-Tuple{QuantumClifford.AbstractStabilizer, Any}"><code>canonicalize_rref!</code></a>, <a href="#QuantumInterface.traceout!-Tuple{Stabilizer, Any}"><code>traceout!</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/entanglement.jl#L210-L216">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.entanglement_entropy-Tuple{QuantumClifford.AbstractStabilizer, UnitRange, Val{:clip}}"><a class="docstring-binding" href="#QuantumInterface.entanglement_entropy-Tuple{QuantumClifford.AbstractStabilizer, UnitRange, Val{:clip}}"><code>QuantumInterface.entanglement_entropy</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Get bipartite entanglement entropy of a contiguous subsystem by passing through the clipped gauge.</p><p>If <code>clip=false</code> is set the canonicalization step is skipped, useful if the input state is already in the clipped gauge.</p><p>See also: <a href="#QuantumClifford.bigram-Tuple{QuantumClifford.AbstractStabilizer}"><code>bigram</code></a>, <a href="#QuantumClifford.canonicalize_clip!-Tuple{QuantumClifford.AbstractStabilizer}"><code>canonicalize_clip!</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/entanglement.jl#L179-L185">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.expect-Tuple{PauliOperator, GeneralizedStabilizer}"><a class="docstring-binding" href="#QuantumInterface.expect-Tuple{PauliOperator, GeneralizedStabilizer}"><code>QuantumInterface.expect</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">expect(p::PauliOperator, s::GeneralizedStabilizer) -&gt; Any
</code></pre><p>Expectation value for the <a href="#QuantumClifford.PauliOperator">PauliOperator</a> observable given the <a href="#QuantumClifford.GeneralizedStabilizer"><code>GeneralizedStabilizer</code></a> state <code>s</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; sm = GeneralizedStabilizer(S&quot;-X&quot;)
A mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z
ğ’®ğ“‰ğ’¶ğ’·
- X
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 1.0+0.0im | + _ | + _

julia&gt; apply!(sm, pcT)
A mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z
ğ’®ğ“‰ğ’¶ğ’·
- X
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 0.0+0.353553im | + _ | + Z
 0.0-0.353553im | + Z | + _
 0.853553+0.0im | + _ | + _
 0.146447+0.0im | + Z | + Z

julia&gt; Ï‡â€² = expect(P&quot;-X&quot;, sm)
0.7071067811865475 + 0.0im

julia&gt; prob = (real(Ï‡â€²)+1)/2
0.8535533905932737</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/nonclifford.jl#L107">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.expect-Tuple{PauliOperator, QuantumClifford.AbstractStabilizer}"><a class="docstring-binding" href="#QuantumInterface.expect-Tuple{PauliOperator, QuantumClifford.AbstractStabilizer}"><code>QuantumInterface.expect</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">expect(p::PauliOperator, st::AbstractStabilizer)</code></pre><p>Compute the expectation value of a Pauli operator <code>p</code> on a stabilizer state <code>st</code>. This function will allocate a temporary copy of the stabilizer state <code>st</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L738-L743">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.nqubits-Tuple{QuantumClifford.AbstractStabilizer}"><a class="docstring-binding" href="#QuantumInterface.nqubits-Tuple{QuantumClifford.AbstractStabilizer}"><code>QuantumInterface.nqubits</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>The number of qubits of a given state.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L671">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.project!-Tuple{Any, PauliOperator}"><a class="docstring-binding" href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>QuantumInterface.project!</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">project!(
    state,
    pauli::PauliOperator;
    keep_result,
    phases
) -&gt; Tuple{MixedStabilizer, Int64, Any}
</code></pre><p>Project the state of a Stabilizer on the two eigenspaces of a Pauli operator.</p><p>Assumes the input is a valid stabilizer. The projection is done inplace on that stabilizer and it does not modify the projection operator.</p><p>It returns</p><ul><li>a stabilizer that might not be in canonical form</li><li>the index of the row where the non-commuting operator was (that row is now equal to <code>pauli</code>; its phase is not updated and for a faithful measurement simulation it needs to be randomized by the user)</li><li>and the result of the projection if there was no non-commuting operator (<code>nothing</code> otherwise)</li></ul><p>If <code>keep_result==false</code> that result of the projection in case of anticommutation is not computed, sparing a canonicalization operation. This canonicalization operation is the only one potentially of cubic complexity. The rest of the calculations are of quadratic complexity.</p><p>If you need to measure a single qubit instead of a multiqubit Pauli operator, the faster <a href="#QuantumInterface.projectX!-Tuple{MixedDestabilizer, Int64}"><code>projectX!</code></a>, <a href="#QuantumInterface.projectY!-Tuple{MixedDestabilizer, Int64}"><code>projectY!</code></a>, and <a href="#QuantumInterface.projectZ!-Tuple{MixedDestabilizer, Int64}"><code>projectZ!</code></a> are available.</p><p>For less boilerplate and automatic randomization of the phase use <a href="#QuantumClifford.projectrand!-Tuple{Any, Any}"><code>projectrand!</code></a>.</p><p>Here is an example of a projection destroying entanglement:</p><pre><code class="language-julia-repl hljs">julia&gt; ghz = S&quot;XXXX
               ZZII
               IZZI
               IIZZ&quot;;


julia&gt; canonicalize!(ghz)
+ XXXX
+ Z__Z
+ _Z_Z
+ __ZZ

julia&gt; state, anticom_index, result = project!(ghz, P&quot;ZIII&quot;);


julia&gt; state
+ Z___
+ Z__Z
+ _Z_Z
+ __ZZ

julia&gt; canonicalize!(state)
+ Z___
+ _Z__
+ __Z_
+ ___Z

julia&gt; anticom_index, result
(1, nothing)</code></pre><p>And an example of projection consistent with the stabilizer state.</p><pre><code class="language-julia-repl hljs">julia&gt; s = S&quot;ZII
             IXI
             IIY&quot;;


julia&gt; canonicalize!(s)
+ _X_
+ __Y
+ Z__

julia&gt; state, anticom_index, result = project!(s, P&quot;-ZII&quot;);


julia&gt; state
+ _X_
+ __Y
+ Z__

julia&gt; anticom_index, result
(0, 0x02)</code></pre><p>While not the best choice, <code>Stabilizer</code> can be used for mixed states, simply by providing an incomplete tableau. In that case it is possible to attempt to project on an operator that can not be generated by the provided stabilizer operators. In that case we have <code>anticom_index==rank</code> and <code>result===nothing</code>, where <code>rank</code> is the the new rank of the tableau, one more than the number of rows in the initial tableau. However, if <code>keep_result</code> was set to <code>false</code>, then <code>anticom_index</code> would stay at zero.</p><pre><code class="language-julia-repl hljs">julia&gt; s = S&quot;XZI
             IZI&quot;;


julia&gt; project!(s, P&quot;IIX&quot;)[1]
+ X__
+ _Z_</code></pre><p>If we had used <a href="#QuantumClifford.MixedStabilizer"><code>MixedStabilizer</code></a> we would have added the projector to the list of stabilizers.</p><pre><code class="language-julia-repl hljs">julia&gt; s = one(MixedStabilizer, 2, 3)
+ Z__
+ _Z_

julia&gt; project!(s, P&quot;IIX&quot;)[1]
+ Z__
+ _Z_
+ __X</code></pre><p>However, <a href="#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a> would be an even better choice as it has <span>$\mathcal{O}(n^2)$</span> complexity instead of the <span>$\mathcal{O}(n^3)$</span> complexity of <code>*Stabilizer</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; s = one(MixedDestabilizer, 2, 3)
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ X__
+ _X_
ğ’³â‚—â”â”â”
+ __X
ğ’®ğ“‰ğ’¶ğ’·â”
+ Z__
+ _Z_
ğ’µâ‚—â”â”â”
+ __Z

julia&gt; project!(s, P&quot;IIX&quot;)[1]
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ X__
+ _X_
+ __Z
ğ’®ğ“‰ğ’¶ğ’·â”
+ Z__
+ _Z_
+ __X</code></pre><p>See the &quot;Datastructure Choice&quot; section in the documentation for more details.</p><p>See also: <a href="#QuantumInterface.projectX!-Tuple{MixedDestabilizer, Int64}"><code>projectX!</code></a>, <a href="#QuantumInterface.projectY!-Tuple{MixedDestabilizer, Int64}"><code>projectY!</code></a>, <a href="#QuantumInterface.projectZ!-Tuple{MixedDestabilizer, Int64}"><code>projectZ!</code></a>, <a href="#QuantumClifford.projectrand!-Tuple{Any, Any}"><code>projectrand!</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L83">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.project!-Tuple{MixedStabilizer, PauliOperator}"><a class="docstring-binding" href="#QuantumInterface.project!-Tuple{MixedStabilizer, PauliOperator}"><code>QuantumInterface.project!</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">project!(
    state::MixedStabilizer,
    pauli::PauliOperator;
    phases
) -&gt; Tuple{MixedStabilizer, Int64, Any}
</code></pre><p>When using <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a> on <a href="#QuantumClifford.MixedStabilizer"><code>MixedStabilizer</code></a> it automates some of the extra steps we encounter when implicitly using the <code>Stabilizer</code> datastructure to represent mixed states. Namely, it helps when the projector is not among the list of stabilizers:</p><pre><code class="language-julia-repl hljs">julia&gt; s = S&quot;XZI
             IZI&quot;;


julia&gt; ms = MixedStabilizer(s)
+ X__
+ _Z_

julia&gt; project!(ms, P&quot;IIY&quot;)[1]
+ X__
+ _Z_
+ __Y</code></pre><p>Similarly to <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a> on <a href="#QuantumClifford.Stabilizer"><code>Stabilizer</code></a>, this function has cubic complexity when the Pauli operator commutes with all rows of the tableau. Most of the time it is better to simply use <a href="#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a> representation.</p><p>Unlike other <code>project!</code> methods, this one does not allow for <code>keep_result=false</code>, as the correct rank or anticommutation index can not be calculated without the expensive (cubic) canonicalization operation required by <code>keep_result=true</code>.</p><p>See the &quot;Datastructure Choice&quot; section in the documentation for more details.</p><p>See also: <a href="#QuantumInterface.projectX!-Tuple{MixedDestabilizer, Int64}"><code>projectX!</code></a>, <a href="#QuantumInterface.projectY!-Tuple{MixedDestabilizer, Int64}"><code>projectY!</code></a>, <a href="#QuantumInterface.projectZ!-Tuple{MixedDestabilizer, Int64}"><code>projectZ!</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L236">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.projectX!-Tuple{MixedDestabilizer, Int64}"><a class="docstring-binding" href="#QuantumInterface.projectX!-Tuple{MixedDestabilizer, Int64}"><code>QuantumInterface.projectX!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Measure a given qubit in the X basis. A faster special-case version of <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>.</p><p>See also: <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>, <a href="#QuantumClifford.projectXrand!-Tuple{Any, Any}"><code>projectXrand!</code></a>, <a href="#QuantumInterface.projectY!-Tuple{MixedDestabilizer, Int64}"><code>projectY!</code></a>, <a href="#QuantumInterface.projectZ!-Tuple{MixedDestabilizer, Int64}"><code>projectZ!</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L441-L446">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.projectY!-Tuple{MixedDestabilizer, Int64}"><a class="docstring-binding" href="#QuantumInterface.projectY!-Tuple{MixedDestabilizer, Int64}"><code>QuantumInterface.projectY!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Measure a given qubit in the Y basis. A faster special-case version of <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>.</p><p>See also: <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>, <a href="#QuantumClifford.projectYrand!-Tuple{Any, Any}"><code>projectYrand!</code></a>, <a href="#QuantumInterface.projectX!-Tuple{MixedDestabilizer, Int64}"><code>projectX!</code></a>, <a href="#QuantumInterface.projectZ!-Tuple{MixedDestabilizer, Int64}"><code>projectZ!</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L469-L474">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.projectZ!-Tuple{MixedDestabilizer, Int64}"><a class="docstring-binding" href="#QuantumInterface.projectZ!-Tuple{MixedDestabilizer, Int64}"><code>QuantumInterface.projectZ!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Measure a given qubit in the Z basis. A faster special-case version of <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>.</p><p>See also: <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>, <a href="#QuantumClifford.projectZrand!-Tuple{Any, Any}"><code>projectZrand!</code></a>, <a href="#QuantumInterface.projectY!-Tuple{MixedDestabilizer, Int64}"><code>projectY!</code></a>, <a href="#QuantumInterface.projectX!-Tuple{MixedDestabilizer, Int64}"><code>projectX!</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L455-L460">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.reset_qubits!-Tuple{MixedDestabilizer, QuantumClifford.AbstractStabilizer, Any}"><a class="docstring-binding" href="#QuantumInterface.reset_qubits!-Tuple{MixedDestabilizer, QuantumClifford.AbstractStabilizer, Any}"><code>QuantumInterface.reset_qubits!</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">reset_qubits!(
    s::MixedDestabilizer,
    newstate::QuantumClifford.AbstractStabilizer,
    qubits;
    phases
) -&gt; MixedDestabilizer
</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L706">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.reset_qubits!-Tuple{MixedStabilizer, Any, Any}"><a class="docstring-binding" href="#QuantumInterface.reset_qubits!-Tuple{MixedStabilizer, Any, Any}"><code>QuantumInterface.reset_qubits!</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">reset_qubits!(
    s::MixedStabilizer,
    newstate,
    qubits;
    phases
) -&gt; MixedStabilizer
</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L690">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.reset_qubits!-Tuple{Stabilizer, Any, Any}"><a class="docstring-binding" href="#QuantumInterface.reset_qubits!-Tuple{Stabilizer, Any, Any}"><code>QuantumInterface.reset_qubits!</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">reset_qubits!(
    s::Stabilizer,
    newstate,
    qubits;
    phases
) -&gt; Union{PauliOperator, Stabilizer}
</code></pre><p>Reset a given set of qubits to be in the state <code>newstate</code>. These qubits are traced out first, which could lead to &quot;nonlocal&quot; changes in the tableau.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L668">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.tensor"><a class="docstring-binding" href="#QuantumInterface.tensor"><code>QuantumInterface.tensor</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>Tensor product between operators or tableaux.</p><p>Tensor product between CiffordOperators:</p><pre><code class="language-julia-repl hljs">julia&gt; tensor(CliffordOperator(sCNOT), CliffordOperator(sCNOT))
Xâ‚ âŸ¼ + XX__
Xâ‚‚ âŸ¼ + _X__
Xâ‚ƒ âŸ¼ + __XX
Xâ‚„ âŸ¼ + ___X
Zâ‚ âŸ¼ + Z___
Zâ‚‚ âŸ¼ + ZZ__
Zâ‚ƒ âŸ¼ + __Z_
Zâ‚„ âŸ¼ + __ZZ</code></pre><p>Tensor product between PauliOperators:</p><pre><code class="language-julia-repl hljs">julia&gt; tensor(P&quot;-IXYZ&quot;, P&quot;iIXYZ&quot;)
-i_XYZ_XYZ</code></pre><p>Tensor product between Tableaux:</p><pre><code class="language-julia-repl hljs">julia&gt; s = S&quot;-XX
             +ZZ&quot;;

julia&gt; tensor(s, s, s)
- XX____
+ ZZ____
- __XX__
+ __ZZ__
- ____XX
+ ____ZZ

julia&gt; s = S&quot;+XZI
             -IZI&quot;;

julia&gt; tensor(s, s)
+ XZ____
- _Z____
+ ___XZ_
- ____Z_</code></pre><p>See also <a href="#QuantumInterface.tensor_pow-Tuple{Union{QuantumClifford.AbstractCliffordOperator, QuantumClifford.AbstractStabilizer}, Any}"><code>tensor_pow</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/linalg.jl#L139-L187">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.tensor-Tuple{Vararg{Union{PauliOperator, UnitaryPauliChannel}}}"><a class="docstring-binding" href="#QuantumInterface.tensor-Tuple{Vararg{Union{PauliOperator, UnitaryPauliChannel}}}"><code>QuantumInterface.tensor</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Tensor product between <a href="#QuantumClifford.UnitaryPauliChannel"><code>UnitaryPauliChannel</code></a> and <a href="#QuantumClifford.PauliOperator"><code>PauliOperator</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; pcT âŠ— P&quot;X&quot;
A unitary Pauli channel P = âˆ‘ Ï•áµ¢ Páµ¢ with the following branches:
with Ï•áµ¢ | Páµ¢
 0.853553+0.353553im | + _X
 0.146447-0.353553im | + ZX

julia&gt; pcT âŠ— pcT âŠ— P&quot;X&quot;
A unitary Pauli channel P = âˆ‘ Ï•áµ¢ Páµ¢ with the following branches:
with Ï•áµ¢ | Páµ¢
 0.603553+0.603553im | + __X
 0.25-0.25im | + Z_X
 0.25-0.25im | + _ZX
 -0.103553-0.103553im | + ZZX</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/nonclifford.jl#L716-L734">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.tensor-Tuple{Vararg{Union{QuantumClifford.AbstractStabilizer, GeneralizedStabilizer}}}"><a class="docstring-binding" href="#QuantumInterface.tensor-Tuple{Vararg{Union{QuantumClifford.AbstractStabilizer, GeneralizedStabilizer}}}"><code>QuantumInterface.tensor</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Tensor product between <a href="#QuantumClifford.GeneralizedStabilizer"><code>GeneralizedStabilizer</code></a> and <a href="#QuantumClifford.Stabilizer"><code>Stabilizer</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra; # hide

julia&gt; sm = GeneralizedStabilizer(ghz(2))
A mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z_
+ _X
ğ’®ğ“‰ğ’¶ğ’·
+ XX
+ ZZ
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 1.0+0.0im | + __ | + __

julia&gt; apply!(sm, embed(2, 2, pcT))
A mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z_
+ _X
ğ’®ğ“‰ğ’¶ğ’·
+ XX
+ ZZ
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 0.853553+0.0im | + __ | + __
 0.0+0.353553im | + __ | + Z_
 0.0-0.353553im | + Z_ | + __
 0.146447+0.0im | + Z_ | + Z_

julia&gt; s = ghz(2)
+ XX
+ ZZ

julia&gt; newsm = sm âŠ— s
A mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z___
+ _X__
+ __Z_
+ ___X
ğ’®ğ“‰ğ’¶ğ’·â”â”
+ XX__
+ ZZ__
+ __XX
+ __ZZ
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 0.0+0.353553im | + ____ | + Z___
 0.0-0.353553im | + Z___ | + ____
 0.146447+0.0im | + Z___ | + Z___
 0.853553+0.0im | + ____ | + ____

julia&gt; real(tr(newsm))
1.0</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/nonclifford.jl#L543-L599">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.tensor_pow-Tuple{Union{QuantumClifford.AbstractCliffordOperator, QuantumClifford.AbstractStabilizer}, Any}"><a class="docstring-binding" href="#QuantumInterface.tensor_pow-Tuple{Union{QuantumClifford.AbstractCliffordOperator, QuantumClifford.AbstractStabilizer}, Any}"><code>QuantumInterface.tensor_pow</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Repeated tensor product of an operators or a tableau.</p><p>For <code>CliffordOperator</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; tensor_pow(CliffordOperator(sHadamard), 3)
Xâ‚ âŸ¼ + Z__
Xâ‚‚ âŸ¼ + _Z_
Xâ‚ƒ âŸ¼ + __Z
Zâ‚ âŸ¼ + X__
Zâ‚‚ âŸ¼ + _X_
Zâ‚ƒ âŸ¼ + __X</code></pre><p>For <code>PauliOperator</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; tensor_pow(P&quot;IXYZ&quot;, 2)
+ _XYZ_XYZ</code></pre><p>For <code>Tableaux</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; tensor_pow(S&quot;Z&quot;, 4)
+ Z___
+ _Z__
+ __Z_
+ ___Z

julia&gt; s = S&quot;+XZI
             +IZI&quot;;

julia&gt; tensor_pow(s, 3)
+ XZ_______
+ _Z_______
+ ___XZ____
+ ____Z____
+ ______XZ_
+ _______Z_</code></pre><p>See also <a href="#QuantumInterface.tensor"><code>tensor</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/linalg.jl#L195-L239">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.traceout!-Tuple{Stabilizer, Any}"><a class="docstring-binding" href="#QuantumInterface.traceout!-Tuple{Stabilizer, Any}"><code>QuantumInterface.traceout!</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">traceout!(
    s::Stabilizer,
    qubits;
    phases,
    rank
) -&gt; Union{Tuple{Stabilizer, Int64}, Stabilizer}
</code></pre><p>Trace out a qubit.</p><p>See also: <a href="#QuantumClifford.delete_columns-Tuple{Stabilizer, Any}"><code>delete_columns</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L635">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.traceout!-Tuple{Union{MixedDestabilizer, MixedStabilizer}, Any}"><a class="docstring-binding" href="#QuantumInterface.traceout!-Tuple{Union{MixedDestabilizer, MixedStabilizer}, Any}"><code>QuantumInterface.traceout!</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">traceout!(
    s::Union{MixedDestabilizer, MixedStabilizer},
    qubits;
    phases,
    rank
) -&gt; Union{Tuple{Union{MixedDestabilizer, MixedStabilizer}, Int64}, MixedDestabilizer, MixedStabilizer}
</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L650">source</a></div></details></article><h2 id="Private-API"><a class="docs-heading-anchor" href="#Private-API">Private API</a><a id="Private-API-1"></a><a class="docs-heading-anchor-permalink" href="#Private-API" title="Permalink"></a></h2><div class="admonition is-danger" id="Private-Implementation-Details-2cd567253646cf3d"><header class="admonition-header">Private Implementation Details<a class="admonition-anchor" href="#Private-Implementation-Details-2cd567253646cf3d" title="Permalink"></a></header><div class="admonition-body"><p>These functions are used internally by the library and might be drastically modified or deleted without warning or deprecation.</p></div></div><article><details class="docstring" open="true"><summary id="QuantumClifford.IP_SQRTX_DECOMPOSITION_TABLE"><a class="docstring-binding" href="#QuantumClifford.IP_SQRTX_DECOMPOSITION_TABLE"><code>QuantumClifford.IP_SQRTX_DECOMPOSITION_TABLE</code></a> â€” <span class="docstring-category">Constant</span></summary><div><p>A table mapping group members to the minimal representation in terms of the generators provided.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/single_qubit_tables.jl#L60-L62">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.ISOLATED_CPHASE_TABLE"><a class="docstring-binding" href="#QuantumClifford.ISOLATED_CPHASE_TABLE"><code>QuantumClifford.ISOLATED_CPHASE_TABLE</code></a> â€” <span class="docstring-category">Constant</span></summary><div><p>A mapping</p><p>(k, Uâ‚, Uâ‚‚) -&gt; (m, Uâ‚&#39;, Uâ‚‚&#39;)</p><p>where k, m âˆˆ{0,1} such that</p><p>CPHASEâ‚â‚‚ Uâ‚ âŠ— Uâ‚‚ (CPHASEâ‚â‚‚)áµ |++âŸ© = Uâ‚&#39; âŠ— Uâ‚‚&#39; (CPHASEâ‚â‚‚)áµ |++âŸ©</p><p>and we guarantee if U1 âˆˆ Z<em>COMMUTATION</em>SUBGROUP then U1&#39; âˆˆ Z<em>COMMUTATION</em>SUBGROUP. Same for U2, U2&#39;.</p><p>See also <a href="#QuantumClifford.apply_cphase_isolated-Tuple{Bool, SingleQubitOperator, SingleQubitOperator}"><code>apply_cphase_isolated</code></a> and <a href="#QuantumClifford.gen_isolated_cphase_table-Tuple{}"><code>gen_isolated_cphase_table</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/two_qubits_table.jl#L125-L137">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.PAULI_STABILIZERS"><a class="docstring-binding" href="#QuantumClifford.PAULI_STABILIZERS"><code>QuantumClifford.PAULI_STABILIZERS</code></a> â€” <span class="docstring-category">Constant</span></summary><div><p>Stabilizers needed to convert between equivalent states to satisfy the commutation constraint (see <a href="#QuantumClifford.apply_cphase_isolated-Tuple{Bool, SingleQubitOperator, SingleQubitOperator}"><code>apply_cphase_isolated</code></a>)</p><div class="admonition is-info" id="Large-subgroup-758ec015c5be823c"><header class="admonition-header">Large subgroup<a class="admonition-anchor" href="#Large-subgroup-758ec015c5be823c" title="Permalink"></a></header><div class="admonition-body"><p>Luckily, to satisfy the commutation constraint we don&#39;t need the whole stabilizer subgroup which is quite big, but only a selected few.</p></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/two_qubits_table.jl#L9-L15">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.SINGLE_QUBIT_MULTIPLICATION_TABLE"><a class="docstring-binding" href="#QuantumClifford.SINGLE_QUBIT_MULTIPLICATION_TABLE"><code>QuantumClifford.SINGLE_QUBIT_MULTIPLICATION_TABLE</code></a> â€” <span class="docstring-category">Constant</span></summary><div><p>Single qubit operator multiplication table to speed up the <code>_apply_vop!</code></p><p>The table consists of entries of the form (sX(1), sY(1)) -&gt; sZ(1)</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/single_qubit_tables.jl#L76-L81">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.Z_COMMUTATION_SUBGROUP"><a class="docstring-binding" href="#QuantumClifford.Z_COMMUTATION_SUBGROUP"><code>QuantumClifford.Z_COMMUTATION_SUBGROUP</code></a> â€” <span class="docstring-category">Constant</span></summary><div><p>The subgroup of single qubit Clifford group that commutes with CPHASE.</p><p>Specifically, this means Uáµ¢ * CPHASEâ‚â‚‚ = CPHASEâ‚â‚‚ * Uáµ¢ for all U âˆˆ Z<em>COMMUTATION</em>SUBGROUP and i âˆˆ {1,2}</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/two_qubits_table.jl#L1-L6">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.AbstractMeasurement"><a class="docstring-binding" href="#QuantumClifford.AbstractMeasurement"><code>QuantumClifford.AbstractMeasurement</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>Supertype of all symbolic single-qubit measurements.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L10">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.AbstractResetMeasurement"><a class="docstring-binding" href="#QuantumClifford.AbstractResetMeasurement"><code>QuantumClifford.AbstractResetMeasurement</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>Supertype of all symbolic single-qubit reset measurements</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L12">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.SymbolicDataType"><a class="docstring-binding" href="#QuantumClifford.SymbolicDataType"><code>QuantumClifford.SymbolicDataType</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>An intermediary when we want to create a new concrete type in a macro.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/sumtypes.jl#L6">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.Tableau"><a class="docstring-binding" href="#QuantumClifford.Tableau"><code>QuantumClifford.Tableau</code></a> â€” <span class="docstring-category">Type</span></summary><div><p>Internal Tableau type for storing a list of Pauli operators in a compact form. No special semantic meaning is attached to this type, it is just a convenient way to store a list of Pauli operators. E.g. it is not used to represent a stabilizer state, or a stabilizer group, or a Clifford circuit.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L135-L138">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Tuple{UnitaryPauliChannel, GeneralizedStabilizer}"><a class="docstring-binding" href="#Base.:*-Tuple{UnitaryPauliChannel, GeneralizedStabilizer}"><code>Base.:*</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Apply a <a href="#QuantumClifford.UnitaryPauliChannel"><code>UnitaryPauliChannel</code></a> to a <a href="#QuantumClifford.GeneralizedStabilizer"><code>GeneralizedStabilizer</code></a> state.</p><pre><code class="language-julia-repl hljs">julia&gt; sm = GeneralizedStabilizer(S&quot;-X&quot;)
A mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z
ğ’®ğ“‰ğ’¶ğ’·
- X
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 1.0+0.0im | + _ | + _

julia&gt; pcT*sm
A mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z
ğ’®ğ“‰ğ’¶ğ’·
- X
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 0.0+0.353553im | + _ | + Z
 0.0-0.353553im | + Z | + _
 0.853553+0.0im | + _ | + _
 0.146447+0.0im | + Z | + Z</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/nonclifford.jl#L737-L762">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Base.hcat-Tuple{Vararg{QuantumClifford.Tableau}}"><a class="docstring-binding" href="#Base.hcat-Tuple{Vararg{QuantumClifford.Tableau}}"><code>Base.hcat</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Horizontally concatenates tableaux.</p><pre><code class="language-julia-repl hljs">julia&gt; hcat(ghz(2), ghz(2))
+ XXXX
+ ZZZZ</code></pre><p>See also: <a href="#Base.vcat-Tuple{Vararg{QuantumClifford.Tableau}}"><code>vcat</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L1007-L1017">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Base.inv-Tuple{CliffordOperator}"><a class="docstring-binding" href="#Base.inv-Tuple{CliffordOperator}"><code>Base.inv</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">inv(
    c::CliffordOperator;
    phases
) -&gt; CliffordOperator{QuantumClifford.Tableau{P, XZ}, PauliOperator{P1, XZ1}} where {P&lt;:(Vector{P} where P&lt;:Unsigned), XZ&lt;:(Matrix{T} where T&lt;:Unsigned), P1&lt;:(AbstractArray{&lt;:Unsigned, 0}), XZ1&lt;:(Vector{P} where P&lt;:Unsigned)}
</code></pre><p>Inverse of a <code>CliffordOperator</code></p><pre><code class="language-julia-repl hljs">julia&gt; inv(CliffordOperator(sCNOT))
Xâ‚ âŸ¼ + XX
Xâ‚‚ âŸ¼ + _X
Zâ‚ âŸ¼ + Z_
Zâ‚‚ âŸ¼ + ZZ

julia&gt; inv(CliffordOperator(sCNOT(2, 1), 2))
Xâ‚ âŸ¼ + X_
Xâ‚‚ âŸ¼ + XX
Zâ‚ âŸ¼ + ZZ
Zâ‚‚ âŸ¼ + _Z

julia&gt; inv(CliffordOperator(tHadamard))
Xâ‚ âŸ¼ + Z
Zâ‚ âŸ¼ + X</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/linalg.jl#L26">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Base.vcat-Tuple{Vararg{QuantumClifford.Tableau}}"><a class="docstring-binding" href="#Base.vcat-Tuple{Vararg{QuantumClifford.Tableau}}"><code>Base.vcat</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Vertically concatenates tableaux.</p><pre><code class="language-julia-repl hljs">julia&gt; vcat(ghz(2), ghz(2))
+ XX
+ ZZ
+ XX
+ ZZ</code></pre><p>See also: <a href="#Base.hcat-Tuple{Vararg{QuantumClifford.Tableau}}"><code>hcat</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L985-L997">source</a></div></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.dot-Tuple{QuantumClifford.AbstractStabilizer, QuantumClifford.AbstractStabilizer}"><a class="docstring-binding" href="#LinearAlgebra.dot-Tuple{QuantumClifford.AbstractStabilizer, QuantumClifford.AbstractStabilizer}"><code>LinearAlgebra.dot</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>The inner product of two Stabilizers.</p><p>Based on (<a href="../references/#garcia2012efficient">Garcia <em>et al.</em>, 2012</a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra

julia&gt; dot(S&quot;Z&quot;, S&quot;Z&quot;)
1.0

julia&gt; dot(S&quot;Z&quot;, S&quot;Y&quot;)
0.7071067811865476</code></pre><p>See also: <a href="#QuantumClifford.logdot-Tuple{QuantumClifford.AbstractStabilizer, QuantumClifford.AbstractStabilizer}"><code>logdot</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/linalg.jl#L66-L81">source</a></div></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.tr-Tuple{GeneralizedStabilizer}"><a class="docstring-binding" href="#LinearAlgebra.tr-Tuple{GeneralizedStabilizer}"><code>LinearAlgebra.tr</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Compute the trace of a <a href="#QuantumClifford.GeneralizedStabilizer"><code>GeneralizedStabilizer</code></a> state.</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford; using LinearAlgebra;

julia&gt; sm = GeneralizedStabilizer(S&quot;-X&quot;);

julia&gt; apply!(sm, pcT)
A mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z
ğ’®ğ“‰ğ’¶ğ’·
- X
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 0.0+0.353553im | + _ | + Z
 0.0-0.353553im | + Z | + _
 0.853553+0.0im | + _ | + _
 0.146447+0.0im | + Z | + Z

julia&gt; tr(sm)
1.0 + 0.0im</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/nonclifford.jl#L163-L186">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford._allthreesumtozero-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#QuantumClifford._allthreesumtozero-Tuple{Any, Any, Any}"><code>QuantumClifford._allthreesumtozero</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Same as <code>all(==(0), (a.+b.+c) .% 2)</code></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/nonclifford.jl#L151">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford._apply_nonthread!-Tuple{QuantumClifford.AbstractStabilizer, CliffordOperator, AbstractVector{Int64}}"><a class="docstring-binding" href="#QuantumClifford._apply_nonthread!-Tuple{QuantumClifford.AbstractStabilizer, CliffordOperator, AbstractVector{Int64}}"><code>QuantumClifford._apply_nonthread!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Nonvectorized version of <code>apply!</code> used for unit tests.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/dense_cliffords.jl#L171">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford._apply_nonthread!-Tuple{QuantumClifford.AbstractStabilizer, CliffordOperator}"><a class="docstring-binding" href="#QuantumClifford._apply_nonthread!-Tuple{QuantumClifford.AbstractStabilizer, CliffordOperator}"><code>QuantumClifford._apply_nonthread!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Nonvectorized version of <code>apply!</code> used for unit tests.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/dense_cliffords.jl#L121">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford._mul_left_nonvec!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Unsigned"><a class="docstring-binding" href="#QuantumClifford._mul_left_nonvec!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Unsigned"><code>QuantumClifford._mul_left_nonvec!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Nonvectorized version of <code>mul_left!</code> used for unit tests.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/mul_leftright.jl#L5">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford._projectrand_notnorm-Tuple{GeneralizedStabilizer, PauliOperator, Int64}"><a class="docstring-binding" href="#QuantumClifford._projectrand_notnorm-Tuple{GeneralizedStabilizer, PauliOperator, Int64}"><code>QuantumClifford._projectrand_notnorm</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Returns the updated <code>GeneralizedStabilizer</code> state smâ€² = (Ï‡â€², B(Sâ€², Dâ€²)), where (Sâ€², Dâ€²) is derived from (S, D) through the traditional stabilizer update, and Ï‡â€² is the updated density matrix after measurement. Note: Î›(Ï‡â€²) â‰¤ Î›(Ï‡).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/nonclifford.jl#L191-L195">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford._remove_rowcol!-Tuple{MixedDestabilizer, Any, Any}"><a class="docstring-binding" href="#QuantumClifford._remove_rowcol!-Tuple{MixedDestabilizer, Any, Any}"><code>QuantumClifford._remove_rowcol!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Unexported low-level function that removes a row (by shifting all rows up as necessary)</p><p>Because MixedDestabilizer is not mutable we return a new MixedDestabilizer with the same (modified) xzs array.</p><p>Used on its own, this function will break invariants. Meant to be used with <code>projectremove!</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L829-L835">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford._rowmove!-Union{Tuple{B}, Tuple{QuantumClifford.Tableau, Any, Any}} where B"><a class="docstring-binding" href="#QuantumClifford._rowmove!-Union{Tuple{B}, Tuple{QuantumClifford.Tableau, Any, Any}} where B"><code>QuantumClifford._rowmove!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Unexported low-level function that moves row i to row j.</p><p>Used on its own, this function will break invariants. Meant to be used in <code>_remove_rowcol!</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L816-L820">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford._stim_prodphase-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Unsigned"><a class="docstring-binding" href="#QuantumClifford._stim_prodphase-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Unsigned"><code>QuantumClifford._stim_prodphase</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>The quantumlib/Stim implementation, which performs the prodphase and mul_left! together. Used for unit tests.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L710">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.apply_cphase_isolated-Tuple{Bool, SingleQubitOperator, SingleQubitOperator}"><a class="docstring-binding" href="#QuantumClifford.apply_cphase_isolated-Tuple{Bool, SingleQubitOperator, SingleQubitOperator}"><code>QuantumClifford.apply_cphase_isolated</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Given a 2-qubit graph state (characterized by VOPs Uâ‚, Uâ‚‚ and kâˆˆ{0,1}), find VOPs Uâ‚&#39;, Uâ‚‚&#39;, mâˆˆ{0,1} such that</p><p>CPHASEâ‚â‚‚ Uâ‚ âŠ— Uâ‚‚ (CPHASEâ‚â‚‚)áµ |++âŸ© = Uâ‚&#39; âŠ— Uâ‚‚&#39; (CPHASEâ‚â‚‚)áµ |++âŸ©</p><p>The the following constraint is satisfied:</p><ul><li>if U1 âˆˆ Z<em>COMMUTATION</em>SUBGROUP then U1&#39; âˆˆ Z<em>COMMUTATION</em>SUBGROUP. Same for U2, U2&#39;.</li></ul><p>This is done by applying stabilizer on the resulting state to change VOPs without changing the underlying quantum state. See also <a href="#QuantumClifford.PAULI_STABILIZERS"><code>PAULI_STABILIZERS</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/two_qubits_table.jl#L49-L59">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.apply_isolated_cphase_lookup_table!-Tuple{QuantumClifford.GraphState, Int64, Int64}"><a class="docstring-binding" href="#QuantumClifford.apply_isolated_cphase_lookup_table!-Tuple{QuantumClifford.GraphState, Int64, Int64}"><code>QuantumClifford.apply_isolated_cphase_lookup_table!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>A helper function that applies <code>ISOLATED_CPHASE_TABLE</code>.</p><p>You should make sure it&#39;s suitable to directly copy the result from lookup table. This is the case if either</p><ul><li>vertices are completely isolated</li><li>VOPs of vertices which have non-operand neighbors are all in Z<em>COMMUTATION</em>SUBGROUP</li></ul><p>An example of the second case is</p><p>Uâ‚ = sHadamard, Uâ‚‚ = sInvPhase</p><p>and q2 is connected to some other vertex while q1 has no neighbors except potentially q2.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/cphase.jl#L72-L84">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.apply_right_row_kernel!-NTuple{5, Any}"><a class="docstring-binding" href="#QuantumClifford.apply_right_row_kernel!-NTuple{5, Any}"><code>QuantumClifford.apply_right_row_kernel!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>helper for computing the right multiplication of a row of a Clifford operator with another Clifford operator.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/apply_right.jl#L75">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.apply_single_x!-Tuple{QuantumClifford.AbstractStabilizer, Any}"><a class="docstring-binding" href="#QuantumClifford.apply_single_x!-Tuple{QuantumClifford.AbstractStabilizer, Any}"><code>QuantumClifford.apply_single_x!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Apply a Pauli X to the <code>i</code>-th qubit of state <code>s</code>. You should use <code>apply!(stab,sX(i))</code> instead of this.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L486">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.apply_single_y!-Tuple{QuantumClifford.AbstractStabilizer, Any}"><a class="docstring-binding" href="#QuantumClifford.apply_single_y!-Tuple{QuantumClifford.AbstractStabilizer, Any}"><code>QuantumClifford.apply_single_y!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Apply a Pauli Y to the <code>i</code>-th qubit of state <code>s</code>. You should use <code>apply!(stab,sY(i))</code> instead of this.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L498">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.apply_single_z!-Tuple{QuantumClifford.AbstractStabilizer, Any}"><a class="docstring-binding" href="#QuantumClifford.apply_single_z!-Tuple{QuantumClifford.AbstractStabilizer, Any}"><code>QuantumClifford.apply_single_z!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Apply a Pauli Z to the <code>i</code>-th qubit of state <code>s</code>. You should use <code>apply!(stab,sZ(i))</code> instead of this.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L474">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.applynoise_branches"><a class="docstring-binding" href="#QuantumClifford.applynoise_branches"><code>QuantumClifford.applynoise_branches</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>Compute all possible new states after the application of the given noise model. Reports the probability of each one of them. Deterministic (as it reports all branches of potentially random processes), part of the Noise interface.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/petrajectory.jl#L4">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.colswap!-Tuple{QuantumClifford.Tableau, Any, Any}"><a class="docstring-binding" href="#QuantumClifford.colswap!-Tuple{QuantumClifford.Tableau, Any, Any}"><code>QuantumClifford.colswap!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Swap two columns of a stabilizer in place.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L901">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.decompose_into_generators-Tuple{AbstractSingleQubitOperator, Vector{&lt;:AbstractSingleQubitOperator}}"><a class="docstring-binding" href="#QuantumClifford.decompose_into_generators-Tuple{AbstractSingleQubitOperator, Vector{&lt;:AbstractSingleQubitOperator}}"><code>QuantumClifford.decompose_into_generators</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Generate a table mapping group members to the minimal representation in terms of the generators provided.</p><p>The first argument is the identity element of the group. The second argument is a list of generators.</p><p>For example, <code>decompose_into_generators(sId1(1), [sInvPhase(1), sSQRTX(1)])</code> generates a table in which the <code>sY</code> entry is <code>sY(1) -&gt; [sSQRTX(1), sSQRTX(1), sInvPhase(1), sInvPhase(1)]</code> which means Y = sInvPhase * sInvPhase * sSQRTX * sSQRTX</p><p>The function uses a brute-force, dynamic programming based approach on finding minimal representation (decomposition) of any group elements in terms of the generators provided.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/single_qubit_tables.jl#L1-L15">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.destab_looks_good-Tuple{Any}"><a class="docstring-binding" href="#QuantumClifford.destab_looks_good-Tuple{Any}"><code>QuantumClifford.destab_looks_good</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Check basic consistency requirements of a destabilizer. Used in tests.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L1333-L1335">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.enumerate_cliffords_slow-Tuple{Any, Any}"><a class="docstring-binding" href="#QuantumClifford.enumerate_cliffords_slow-Tuple{Any, Any}"><code>QuantumClifford.enumerate_cliffords_slow</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>The O(n^4) implementation from (<a href="../references/#koenig2014efficiently">Koenig and Smolin, 2014</a>) â€“ their algorithm seems wrong as âŸ¨w&#39;â‚|wâ‚—âŸ©=bâ‚— which is not always zero.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/enumeration.jl#L165">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.fill_tril-Tuple{Random.AbstractRNG, Any, Any}"><a class="docstring-binding" href="#QuantumClifford.fill_tril-Tuple{Random.AbstractRNG, Any, Any}"><code>QuantumClifford.fill_tril</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Assign (symmetric) random ints to off diagonals of matrix.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/randoms.jl#L519">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.gen_graph_state-Tuple{Bool, SingleQubitOperator, SingleQubitOperator}"><a class="docstring-binding" href="#QuantumClifford.gen_graph_state-Tuple{Bool, SingleQubitOperator, SingleQubitOperator}"><code>QuantumClifford.gen_graph_state</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Generate a 2-qubit graph state from the graph (represented by whether vertices are connected) and two VOPs</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/two_qubits_table.jl#L36-L38">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.gen_isolated_cphase_table-Tuple{}"><a class="docstring-binding" href="#QuantumClifford.gen_isolated_cphase_table-Tuple{}"><code>QuantumClifford.gen_isolated_cphase_table</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Generate a lookup table for isolated two qubits CPHASE gate operation</p><p>Specifically, this creates a mapping</p><p>(k, Uâ‚, Uâ‚‚) -&gt; (m, Uâ‚&#39;, Uâ‚‚&#39;)</p><p>where k, m âˆˆ{0,1} such that</p><p>CPHASEâ‚â‚‚ Uâ‚ âŠ— Uâ‚‚ (CPHASEâ‚â‚‚)áµ |++âŸ© = Uâ‚&#39; âŠ— Uâ‚‚&#39; (CPHASEâ‚â‚‚)áµ |++âŸ©</p><p>and we guarantee if U1 âˆˆ Z<em>COMMUTATION</em>SUBGROUP then U1&#39; âˆˆ Z<em>COMMUTATION</em>SUBGROUP. Same for U2, U2&#39;.</p><p>See also <a href="#QuantumClifford.ISOLATED_CPHASE_TABLE"><code>ISOLATED_CPHASE_TABLE</code></a> and <a href="#QuantumClifford.gen_isolated_cphase_table-Tuple{}"><code>gen_isolated_cphase_table</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/two_qubits_table.jl#L95-L109">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.gen_single_qubit_multiplication_table-Tuple{}"><a class="docstring-binding" href="#QuantumClifford.gen_single_qubit_multiplication_table-Tuple{}"><code>QuantumClifford.gen_single_qubit_multiplication_table</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Generate a single qubit operator multiplication table</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/single_qubit_tables.jl#L65">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.get_all_subtypes-Tuple{Any}"><a class="docstring-binding" href="#QuantumClifford.get_all_subtypes-Tuple{Any}"><code>QuantumClifford.get_all_subtypes</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Returns a tuple of all concrete subtypes and all UnionAll non-abstract subtypes of a given type.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/sumtypes.jl#L107">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.get_bitmask_idxs-Tuple{AbstractArray{&lt;:Unsigned}, Int64}"><a class="docstring-binding" href="#QuantumClifford.get_bitmask_idxs-Tuple{AbstractArray{&lt;:Unsigned}, Int64}"><code>QuantumClifford.get_bitmask_idxs</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">get_bitmask_idxs(
    xzs::AbstractArray{&lt;:Unsigned},
    i::Int64
) -&gt; Tuple{Any, Int64, Int64, Any}
</code></pre><p>Computes bitmask indices for an unsigned integer at index <code>i</code> within the binary structure of a <code>Tableau</code> or <code>PauliOperator</code>.</p><p>For <code>Tableau</code>, the method operates on the <code>.xzs</code> field, while for <code>PauliOperator</code>, it uses the <code>.xz</code> field. It calculates the following values based on the index <code>i</code>:</p><ul><li><code>lowbit</code>, the lowest bit.</li><li><code>ibig</code>, the index of the word containing the bit.</li><li><code>ismall</code>, the position of the bit within the word.</li><li><code>ismallm</code>, a bitmask isolating the specified bit.</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L950">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.gf2_H_standard_form_indices-Tuple{Any}"><a class="docstring-binding" href="#QuantumClifford.gf2_H_standard_form_indices-Tuple{Any}"><code>QuantumClifford.gf2_H_standard_form_indices</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>The permutation of columns which turns a binary matrix into standard form. It is assumed the matrix has already undergone Gaussian elimination.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L1186">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.gf2_nullspace-Tuple{AbstractMatrix{Int64}}"><a class="docstring-binding" href="#QuantumClifford.gf2_nullspace-Tuple{AbstractMatrix{Int64}}"><code>QuantumClifford.gf2_nullspace</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>The nullspace of a binary matrix.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L1261">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.gf2_row_echelon_with_pivots!-Tuple{AbstractMatrix{Int64}}"><a class="docstring-binding" href="#QuantumClifford.gf2_row_echelon_with_pivots!-Tuple{AbstractMatrix{Int64}}"><code>QuantumClifford.gf2_row_echelon_with_pivots!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Performs in-place Gaussian elimination on a binary matrix and returns its <em>row echelon form</em>,<em>rank</em>, the <em>transformation matrix</em>, and the <em>pivot columns</em>. The transformation matrix that converts the original matrix into the row echelon form. The <code>full</code> parameter controls the extent of elimination: if <code>true</code>, only rows below the pivot are affected; if <code>false</code>, both above and below the pivot are eliminated.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L1217-L1223">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.gf2_rowspace_basis-Tuple{AbstractMatrix{Int64}}"><a class="docstring-binding" href="#QuantumClifford.gf2_rowspace_basis-Tuple{AbstractMatrix{Int64}}"><code>QuantumClifford.gf2_rowspace_basis</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>The basis for the row space of the binary matrix.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L1273">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.graph-Tuple{QuantumClifford.GraphState}"><a class="docstring-binding" href="#QuantumClifford.graph-Tuple{QuantumClifford.GraphState}"><code>QuantumClifford.graph</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Return the underlying graph of the graph state</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/graphs.jl#L41">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.initZ!-Tuple{PauliFrame}"><a class="docstring-binding" href="#QuantumClifford.initZ!-Tuple{PauliFrame}"><code>QuantumClifford.initZ!</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">initZ!(frame::PauliFrame) -&gt; PauliFrame
</code></pre><p>Inject random Z errors over all frames and qubits for the supplied PauliFrame with probability 0.5.</p><p>Calling this after initialization is essential for simulating any non-deterministic circuit. It is done automatically by most <a href="#QuantumClifford.PauliFrame"><code>PauliFrame</code></a> constructors.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/pauli_frames.jl#L39">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.invsparsity"><a class="docstring-binding" href="#QuantumClifford.invsparsity"><code>QuantumClifford.invsparsity</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>Calculates the number of non-zero elements in the density matrix <code>Ï‡</code> of a <a href="#QuantumClifford.GeneralizedStabilizer"><code>GeneralizedStabilizer</code></a>, representing the inverse sparsity of <code>Ï‡</code>. It provides a measure of the state&#39;s complexity, with bounds <code>Î›(Ï‡) â‰¤ 4â¿</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford: invsparsity; # hide

julia&gt; sm = GeneralizedStabilizer(S&quot;X&quot;)
A mixture âˆ‘ Ï•áµ¢â±¼ Páµ¢ Ï Pâ±¼â€  where Ï is
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z
ğ’®ğ“‰ğ’¶ğ’·
+ X
with Ï•áµ¢â±¼ | Páµ¢ | Pâ±¼:
 1.0+0.0im | + _ | + _

julia&gt; apply!(sm, pcT) |&gt; invsparsity
4</code></pre><p>Similarly, it calculates the number of non-zero elements in the density matrix <code>Ï•áµ¢â±¼</code>â€‹ of a PauliChannel, providing a measure of the channel complexity.</p><pre><code class="language-julia-repl hljs">julia&gt; invsparsity(pcT)
4</code></pre><p>See also: <a href="#QuantumClifford.GeneralizedStabilizer"><code>GeneralizedStabilizer</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/nonclifford.jl#L765-L797">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.local_comp!-Tuple{Any, Int64}"><a class="docstring-binding" href="#QuantumClifford.local_comp!-Tuple{Any, Int64}"><code>QuantumClifford.local_comp!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Perform local complementation on pure graph</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/cphase.jl#L43-L45">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.local_comp!-Tuple{QuantumClifford.GraphState{G, SingleQubitOperator} where G, Int64}"><a class="docstring-binding" href="#QuantumClifford.local_comp!-Tuple{QuantumClifford.GraphState{G, SingleQubitOperator} where G, Int64}"><code>QuantumClifford.local_comp!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Perform local complementation about index id while maintaining the represented quantum state unchanged.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/cphase.jl#L57-L59">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.make_sumtype-Tuple{Any}"><a class="docstring-binding" href="#QuantumClifford.make_sumtype-Tuple{Any}"><code>QuantumClifford.make_sumtype</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">julia&gt; make_sumtype([sCNOT])
quote
    @sum_type CompactifiedGate :hidden begin
        sCNOT(::Int64, ::Int64)
    end
end</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/sumtypes.jl#L49-L58">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.make_sumtype_method"><a class="docstring-binding" href="#QuantumClifford.make_sumtype_method"><code>QuantumClifford.make_sumtype_method</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>``` julia&gt; make<em>sumtype</em>method([sCNOT], :apply!, (:s,)) quote     function QuantumClifford.apply!(s, g::CompactifiedGate)         @cases g begin             sCNOT(q1, q2) =&gt; apply!(s, sCNOT(q1, q2))         end     end end</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/sumtypes.jl#L67-L77">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.make_sumtype_variant_constructor-Tuple{Any}"><a class="docstring-binding" href="#QuantumClifford.make_sumtype_variant_constructor-Tuple{Any}"><code>QuantumClifford.make_sumtype_variant_constructor</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">julia&gt; make_sumtype_variant_constructor(sCNOT)
:(CompactifiedGate(g::sCNOT) = begin
    (CompactifiedGate&#39;).sCNOT(g.q1, g.q2)
end)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/sumtypes.jl#L89-L96">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.make_variant-Tuple{Union{DataType, QuantumClifford.SymbolicDataType}}"><a class="docstring-binding" href="#QuantumClifford.make_variant-Tuple{Union{DataType, QuantumClifford.SymbolicDataType}}"><code>QuantumClifford.make_variant</code></a> â€” <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">julia&gt; make_variant(sCNOT)
:(sCNOT(::Int64, ::Int64))</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/sumtypes.jl#L26-L31">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.make_variant_deconstruct"><a class="docstring-binding" href="#QuantumClifford.make_variant_deconstruct"><code>QuantumClifford.make_variant_deconstruct</code></a> â€” <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">julia&gt; make_variant_deconstruct(sCNOT, :apply!, (:s,))
:(sCNOT(q1, q2) =&gt; apply!(s, sCNOT(q1, q2)))</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/sumtypes.jl#L36-L41">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.mixed_destab_looks_good-Tuple{Any}"><a class="docstring-binding" href="#QuantumClifford.mixed_destab_looks_good-Tuple{Any}"><code>QuantumClifford.mixed_destab_looks_good</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Check basic consistency requirements of a mixed destabilizer. Used in tests.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L1351-L1353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.mixed_stab_looks_good-Tuple{Any}"><a class="docstring-binding" href="#QuantumClifford.mixed_stab_looks_good-Tuple{Any}"><code>QuantumClifford.mixed_stab_looks_good</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Check basic consistency requirements of a mixed stabilizer. Used in tests.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L1318-L1320">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.mul_right_ignore_anticomm!-Union{Tuple{B}, Tuple{QuantumClifford.Tableau, Any, QuantumClifford.Tableau, Any}} where B"><a class="docstring-binding" href="#QuantumClifford.mul_right_ignore_anticomm!-Union{Tuple{B}, Tuple{QuantumClifford.Tableau, Any, QuantumClifford.Tableau, Any}} where B"><code>QuantumClifford.mul_right_ignore_anticomm!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Multiply Pauli operators <code>l * r</code>, ignoring anticommutation phases (keeping only Â±1, not Â±i)</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/apply_right.jl#L365">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.pfmeasurement"><a class="docstring-binding" href="#QuantumClifford.pfmeasurement"><code>QuantumClifford.pfmeasurement</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>For a given simulated state, e.g. a <a href="#QuantumClifford.PauliFrame"><code>PauliFrame</code></a> instance, returns the measurement results.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/pauli_frames.jl#L259-L261">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.precise_inv-Tuple{Any}"><a class="docstring-binding" href="#QuantumClifford.precise_inv-Tuple{Any}"><code>QuantumClifford.precise_inv</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Inverting a binary matrix: uses floating point for small matrices and Nemo for large matrices.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/randoms.jl#L445">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.project_cond!-Union{Tuple{PHASES}, Tuple{RESET}, Tuple{IS}, Tuple{MixedDestabilizer, Int64, Val{IS}, Val{RESET}}} where {IS, RESET, PHASES}"><a class="docstring-binding" href="#QuantumClifford.project_cond!-Union{Tuple{PHASES}, Tuple{RESET}, Tuple{IS}, Tuple{MixedDestabilizer, Int64, Val{IS}, Val{RESET}}} where {IS, RESET, PHASES}"><code>QuantumClifford.project_cond!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Internal method used to implement <a href="#QuantumInterface.projectX!-Tuple{MixedDestabilizer, Int64}"><code>projectX!</code></a>, <a href="#QuantumInterface.projectZ!-Tuple{MixedDestabilizer, Int64}"><code>projectZ!</code></a>, and <a href="#QuantumInterface.projectY!-Tuple{MixedDestabilizer, Int64}"><code>projectY!</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L506">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.projectremoverand!-Union{Tuple{F}, Tuple{MixedDestabilizer, F, Any}} where F&lt;:Union{typeof(projectX!), typeof(projectY!), typeof(projectZ!)}"><a class="docstring-binding" href="#QuantumClifford.projectremoverand!-Union{Tuple{F}, Tuple{MixedDestabilizer, F, Any}} where F&lt;:Union{typeof(projectX!), typeof(projectY!), typeof(projectZ!)}"><code>QuantumClifford.projectremoverand!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Unexported low-level function that projects a qubit and returns the result while making the tableau smaller by a qubit.</p><p>Because MixedDestabilizer is not mutable we return a new MixedDestabilizer with the same (modified) xzs array.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L860-L864">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.quantum_mallows-Tuple{Random.AbstractRNG, Int64}"><a class="docstring-binding" href="#QuantumClifford.quantum_mallows-Tuple{Random.AbstractRNG, Int64}"><code>QuantumClifford.quantum_mallows</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Sample (h, S) from the distribution P_n(h, S) from Bravyi and Maslov Algorithm 1.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/randoms.jl#L461">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.random_tableau"><a class="docstring-binding" href="#QuantumClifford.random_tableau"><code>QuantumClifford.random_tableau</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>A random tableau with r rows on n qubits, suitable for bulk sampling.</p><p>Each row is equivalent to an instance of <a href="#QuantumClifford.random_pauli"><code>random_pauli</code></a> without any additional commutativity constraints. For proper states, consider utilising <a href="#QuantumClifford.random_stabilizer-Tuple{Random.AbstractRNG, Int64}"><code>random_stabilizer</code></a> or <a href="#QuantumClifford.random_destabilizer-Tuple{Random.AbstractRNG, Int64}"><code>random_destabilizer</code></a> as necessary.</p><p>Use <code>nophase=false</code> to randomize the phase. Use <code>realphase=false</code> to get operators with phases including Â±i.</p><p>Optionally, a &quot;flip&quot; probability <code>p</code> can be provided specified, in which case each bit is set to I with probability <code>1-p</code> and to X or Y or Z with probability <code>p</code>. Useful for simulating unbiased Pauli noise.</p><p>See also <a href="#QuantumClifford.random_tableau!"><code>random_tableau!</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/randoms.jl#L75-L90">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.random_tableau!"><a class="docstring-binding" href="#QuantumClifford.random_tableau!"><code>QuantumClifford.random_tableau!</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>An in-place version of <a href="#QuantumClifford.random_tableau"><code>random_tableau</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/randoms.jl#L91">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.remove_column!-Union{Tuple{M}, Tuple{T}, Tuple{V}, Tuple{QuantumClifford.Tableau{V, M}, Int64}} where {V, T&lt;:Unsigned, M&lt;:AbstractMatrix{T}}"><a class="docstring-binding" href="#QuantumClifford.remove_column!-Union{Tuple{M}, Tuple{T}, Tuple{V}, Tuple{QuantumClifford.Tableau{V, M}, Int64}} where {V, T&lt;:Unsigned, M&lt;:AbstractMatrix{T}}"><code>QuantumClifford.remove_column!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Unexported low-level function that removes a column (by shifting all columns to the right of the target by one step to the left)</p><p>Because Tableau is not mutable we return a new Tableau with the same (modified) xzs array.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/project_trace_reset.jl#L791-L794">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.remove_vop!-Tuple{QuantumClifford.GraphState, Int64, Int64}"><a class="docstring-binding" href="#QuantumClifford.remove_vop!-Tuple{QuantumClifford.GraphState, Int64, Int64}"><code>QuantumClifford.remove_vop!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Perform Local Complementation repeatedly to transfer the VOP of src to the target.</p><p>See also <a href="#QuantumClifford.local_comp!-Tuple{Any, Int64}"><code>local_comp!</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/cphase.jl#L17-L21">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.rowdecompose-Tuple{Any, Union{Destabilizer, MixedDestabilizer}}"><a class="docstring-binding" href="#QuantumClifford.rowdecompose-Tuple{Any, Union{Destabilizer, MixedDestabilizer}}"><code>QuantumClifford.rowdecompose</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Decompose a Pauli <span>$P$</span> in terms of stabilizer and destabilizer rows from a given tableaux.</p><p>For given tableaux of rows destabilizer rows <span>$\{d_i\}$</span> and stabilizer rows <span>$\{s_i\}$</span>, there are boolean vectors <span>$b$</span> and <span>$c$</span> such that <span>$P = i^p \prod_i d_i^{b_i} \prod_i s_i^{c_i}$</span>.</p><p>This function returns <code>p</code>, <code>b</code>, <code>c</code>.</p><pre><code class="language-julia hljs">julia&gt; s = MixedDestabilizer(ghz(2))
ğ’Ÿâ„¯ğ“ˆğ“‰ğ’¶ğ’·
+ Z_
+ _X
ğ’®ğ“‰ğ’¶ğ’·
+ XX
+ ZZ

julia&gt; phase, destab_rows, stab_rows = QuantumClifford.rowdecompose(P&quot;XY&quot;, s)
(3, Bool[1, 0], Bool[1, 1])

julia&gt; im^3 * P&quot;Z_&quot; * P&quot;XX&quot; * P&quot;ZZ&quot;
+ XY</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/nonclifford.jl#L601-L625">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.sample_geometric_2-Tuple{Random.AbstractRNG, Integer}"><a class="docstring-binding" href="#QuantumClifford.sample_geometric_2-Tuple{Random.AbstractRNG, Integer}"><code>QuantumClifford.sample_geometric_2</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>This function samples a number from 1 to <code>n</code> where <code>n &gt;= 1</code> probability of outputting <code>i</code> is proportional to <code>2^i</code></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/randoms.jl#L503-L505">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.stab_looks_good-Tuple{Any}"><a class="docstring-binding" href="#QuantumClifford.stab_looks_good-Tuple{Any}"><code>QuantumClifford.stab_looks_good</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Check basic consistency requirements of a stabilizer. Used in tests.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L1293-L1295">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.to_cpu"><a class="docstring-binding" href="#QuantumClifford.to_cpu"><code>QuantumClifford.to_cpu</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>copies the memory content of the object to CPU</p><p>You can only use this function if CUDA.jl is imported</p><p>For more advanced users <code>to_cpu(data, element_type)</code> will reinterpret elements of data and converts them to <code>element_type</code>. For example based on your CPU architecture, if working with matrices of UInt32 is faster than UInt64, you can use <code>to_cpu(data, UInt32)</code></p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford: to_cpu, to_gpu

julia&gt; using CUDA # without this import, to_cpu, to_gpu are just function

julia&gt; stab = S&quot;- X_Z\n+ _ZZ\n+ __Z&quot;
- X_Z
+ _ZZ
+ __Z

julia&gt; stab_gpu = to_gpu(stab);

julia&gt; apply!(stab_gpu, sHadamard(1));

julia&gt; stab_result_cpu = to_cpu(stab_gpu)
- Z_Z
+ _ZZ
+ __Z</code></pre><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford: to_cpu, to_gpu

julia&gt; using CUDA # without this import, to_cpu, to_gpu are just function

julia&gt; pf_gpu = to_gpu(PauliFrame(1000, 2, 2));
julia&gt; circuit = [sMZ(1, 1), sHadamard(2), sMZ(2, 2)];
julia&gt; pftrajectories(pf_gpu, circuit);
julia&gt; measurements = to_cpu(pf_gpu.measurements);</code></pre><p>See also: <a href="#QuantumClifford.to_gpu"><code>to_gpu</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/gpu_adapters.jl#L1-L44">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.to_gpu"><a class="docstring-binding" href="#QuantumClifford.to_gpu"><code>QuantumClifford.to_gpu</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>copies the memory content of the object to GPU</p><p>You can only use this function if CUDA.jl is imported</p><p>For more advanced users <code>to_gpu(data, element_type)</code> will reinterpret elements of data and converts them to <code>element_type</code>. For example based on your GPU architecture, if working with matrices of UInt64 is faster than UInt32, you can use <code>to_gpu(data, UInt64)</code></p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford: to_cpu, to_gpu

julia&gt; using CUDA # without this import, to_cpu, to_gpu are just function

julia&gt; stab = S&quot;- X_Z\n+ _ZZ\n+ __Z&quot;
- X_Z
+ _ZZ
+ __Z

julia&gt; stab_gpu = to_gpu(stab);

julia&gt; apply!(stab_gpu, sHadamard(1));

julia&gt; stab_result_cpu = to_cpu(stab_gpu)
- Z_Z
+ _ZZ
+ __Z</code></pre><pre><code class="language-julia-repl hljs">julia&gt; using QuantumClifford: to_cpu, to_gpu

julia&gt; using CUDA # without this import, to_cpu, to_gpu are just function

julia&gt; pf_gpu = to_gpu(PauliFrame(1000, 2, 2));
julia&gt; circuit = [sMZ(1, 1), sHadamard(2), sMZ(2, 2)];
julia&gt; pftrajectories(pf_gpu, circuit);
julia&gt; measurements = to_cpu(pf_gpu.measurements);</code></pre><p>See also: <a href="#QuantumClifford.to_cpu"><code>to_cpu</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/gpu_adapters.jl#L48-L91">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.toggle_edge!-Tuple{Any, Int64, Int64}"><a class="docstring-binding" href="#QuantumClifford.toggle_edge!-Tuple{Any, Int64, Int64}"><code>QuantumClifford.toggle_edge!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Toggle the edge of a graph between vertices v1 and v2.</p><p>Uses <code>rem_edge!</code> and <code>add_edge!</code></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/cphase.jl#L3-L7">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.trusted_rank"><a class="docstring-binding" href="#QuantumClifford.trusted_rank"><code>QuantumClifford.trusted_rank</code></a> â€” <span class="docstring-category">Function</span></summary><div><p>A &quot;trusted&quot; <code>rank</code> which returns <code>rank(state)</code> for <code>Mixed[De]Stabilizer</code> and <code>length(state)</code> for <code>[De]Stabilizer</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/linalg.jl#L132">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.vops-Tuple{QuantumClifford.GraphState}"><a class="docstring-binding" href="#QuantumClifford.vops-Tuple{QuantumClifford.GraphState}"><code>QuantumClifford.vops</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Return the VOPs (Vertex Operators) of the graph state</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/graphs/graphs.jl#L44">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.zero!-Union{Tuple{PauliOperator{P, XZ}}, Tuple{XZ}, Tuple{P}} where {P, XZ}"><a class="docstring-binding" href="#QuantumClifford.zero!-Union{Tuple{PauliOperator{P, XZ}}, Tuple{XZ}, Tuple{P}} where {P, XZ}"><code>QuantumClifford.zero!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Zero-out the phases and single-qubit operators in a <a href="#QuantumClifford.PauliOperator"><code>PauliOperator</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/pauli_operator.jl#L177">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.zero!-Union{Tuple{XZ}, Tuple{P}, Tuple{QuantumClifford.Tableau{P, XZ}, Any}} where {P, XZ}"><a class="docstring-binding" href="#QuantumClifford.zero!-Union{Tuple{XZ}, Tuple{P}, Tuple{QuantumClifford.Tableau{P, XZ}, Any}} where {P, XZ}"><code>QuantumClifford.zero!</code></a> â€” <span class="docstring-category">Method</span></summary><div><p>Zero-out a given row of a <a href="#QuantumClifford.Tableau"><code>Tableau</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/QuantumClifford.jl#L269">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.@qubitop1-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#QuantumClifford.@qubitop1-Tuple{Any, Any, Any}"><code>QuantumClifford.@qubitop1</code></a> â€” <span class="docstring-category">Macro</span></summary><div><p>Macro used to define single qubit symbolic gates and their <code>qubit_kernel</code> methods.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L90">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.@qubitop2-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#QuantumClifford.@qubitop2-Tuple{Any, Any, Any}"><code>QuantumClifford.@qubitop2</code></a> â€” <span class="docstring-category">Macro</span></summary><div><p>Macro used to define 2-qubit symbolic gates and their <code>qubit_kernel</code> methods.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/symbolic_cliffords.jl#L343">source</a></div></details></article><article><details class="docstring" open="true"><summary id="QuantumClifford.@valbooldispatch-Tuple{Any, Vararg{Any}}"><a class="docstring-binding" href="#QuantumClifford.@valbooldispatch-Tuple{Any, Vararg{Any}}"><code>QuantumClifford.@valbooldispatch</code></a> â€” <span class="docstring-category">Macro</span></summary><div><p>Turns <code>f(Val(x))</code> into <code>x ? f(Val(true)) : f(Val(false))</code> in order to avoid dynamic dispatch</p><p>See <a href="https://discourse.julialang.org/t/allocations-due-to-boolean-keyword-arguments-how-to-avoid-them/87654">discourse discussion</a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumClifford.jl/blob/cf0eb1804dfe5b02c77cb0234ab956854a00991d/src/macrotools.jl#L3-L6">source</a></div></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../plotting/">Â« Visualizations</a><a class="docs-footer-nextpage" href="../tutandpub/">Tutorials and Publications Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Sunday 16 November 2025 03:03">Sunday 16 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

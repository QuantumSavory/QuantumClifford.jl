var documenterSearchIndex = {"docs":
[{"location":"references/#Suggested-reading","page":"Suggested Readings & References","title":"Suggested reading","text":"","category":"section"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"For the basis of the tableaux methods first read (Gottesman, 1998) followed by the more efficient approach described in (Aaronson and Gottesman, 2004).","category":"page"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"The tableaux can be canonicalized (i.e. Gaussian elimination can be performed on them) in a number of different ways, and considering the different approaches provides useful insight. The following methods are implemented in this library:","category":"page"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"The default one: (Garcia *et al.*, 2012)\nUseful when in need of tracing out a set of qubits: (Audenaert and Plenio, 2005)\nUseful when defining logical operators of codes: (Gottesman, 1997)","category":"page"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"For the use of these methods in error correction and the subtle overlap between the two fields consider these resources. They are also useful in defining some of the specific constraints in commutation between rows in the tableaux:","category":"page"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"(Steane, 2007)\n(Calderbank *et al.*, 1998)\n(MacKay *et al.*, 2004)\n(Wilde, 2009)","category":"page"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"These publications describe the uniform sampling of random stabilizer states:","category":"page"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"(Koenig and Smolin, 2014)\n(Bravyi and Maslov, 2021)\n(Van Den Berg, 2021)\n(Li *et al.*, 2019)","category":"page"},{"location":"references/#References","page":"Suggested Readings & References","title":"References","text":"","category":"section"},{"location":"references/","page":"Suggested Readings & References","title":"Suggested Readings & References","text":"<div class=\"citation canonical\"><ul><li>\n<div id=\"aaronson2004improved\">Aaronson, S. and Gottesman, D. (2004). <i>Improved simulation of stabilizer circuits</i>. <a href='https://doi.org/10.1103/PhysRevA.70.052328'>Physical Review A <b>70</b>, 052328</a>.</div>\n</li><li>\n<div id=\"audenaert2005entanglement\">Audenaert, K. M. and Plenio, M. B. (2005). <i>Entanglement on mixed stabilizer states: normal forms and reduction procedures</i>. <a href='https://doi.org/10.1088/1367-2630/7/1/170'>New Journal of Physics <b>7</b>, 170</a>.</div>\n</li><li>\n<div id=\"bravyi2020hadamard\">Bravyi, S. and Maslov, D. (2021). <i>Hadamard-free circuits expose the structure of the Clifford group</i>. <a href='https://doi.org/10.1109/TIT.2021.3081415'>IEEE Transactions on Information Theory <b>67</b>, 4546–4563</a>.</div>\n</li><li>\n<div id=\"calderbank1998quantum\">Calderbank, A. R.; Rains, E. M.; Shor, P. and Sloane, N. J. (1998). <i>Quantum error correction via codes over GF (4)</i>. <a href='https://doi.org/10.1109/18.681315'>IEEE Transactions on Information Theory <b>44</b>, 1369–1387</a>.</div>\n</li><li>\n<div id=\"garcia2012efficient\">Garcia, H. J.; Markov, I. L. and Cross, A. W. (2012). <a href='https://arxiv.org/abs/1210.6646'><i>Efficient inner-product algorithm for stabilizer states</i></a>, arXiv preprint arXiv:1210.6646.</div>\n</li><li>\n<div id=\"gottesman1997stabilizer\">Gottesman, D. (1997). <a href='https://arxiv.org/abs/quant-ph/9705052'><i>Stabilizer codes and quantum error correction</i></a>. Phd thesis, California Institute of Technology.</div>\n</li><li>\n<div id=\"gottesman1998heisenberg\">Gottesman, D. (1998). <a href='https://arxiv.org/abs/quant-ph/9807006'><i>The Heisenberg representation of quantum computers</i></a>. In: International Conference on Group Theoretic Methods in Physics.</div>\n</li><li>\n<div id=\"gullans2020quantum\">Gullans, M. J.; Krastanov, S.; Huse, D. A.; Jiang, L. and Flammia, S. T. (2020). <i>Quantum coding with low-depth random circuits</i>, arXiv preprint arXiv:2010.09775.</div>\n</li><li>\n<div id=\"koenig2014efficiently\">Koenig, R. and Smolin, J. A. (2014). <i>How to efficiently select an arbitrary Clifford group element</i>. <a href='https://doi.org/10.1063/1.4903507'>Journal of Mathematical Physics <b>55</b>, 122202</a>.</div>\n</li><li>\n<div id=\"krastanov2020heterogeneous\">Krastanov, S.; de la Cerda, A. S. and Narang, P. (2020). <i>Heterogeneous Multipartite Entanglement Purification for Size-Constrained Quantum Devices</i>, arXiv preprint arXiv:2011.11640.</div>\n</li><li>\n<div id=\"li2019measurement\">Li, Y.; Chen, X. and Fisher, M. P. (2019). <i>Measurement-driven entanglement transition in hybrid quantum circuits</i>. <a href='https://doi.org/10.1103/PhysRevB.100.134306'>Physical Review B <b>100</b>, 134306</a>.</div>\n</li><li>\n<div id=\"mackay2004sparse\">MacKay, D. J.; Mitchison, G. and McFadden, P. L. (2004). <i>Sparse-graph codes for quantum error correction</i>. <a href='https://doi.org/10.1109/TIT.2004.834737'>IEEE Transactions on Information Theory <b>50</b>, 2315–2330</a>.</div>\n</li><li>\n<div id=\"nahum2017quantum\">Nahum, A.; Ruhman, J.; Vijay, S. and Haah, J. (2017). <a href='https://link.aps.org/doi/10.1103/PhysRevX.7.031016'><i>Quantum Entanglement Growth under Random Unitary Dynamics</i></a>. <a href='https://doi.org/10.1103/PhysRevX.7.031016'>Physical Review X <b>7</b>, 031016</a>.</div>\n</li><li>\n<div id=\"steane2007tutorial\">Steane, A. M. (2007). <i>A tutorial on quantum error correction</i>. <a href='https://doi.org/10.3254/978-1-61499-018-5-1'> In: PROCEEDINGS-INTERNATIONAL SCHOOL OF PHYSICS ENRICO FERMI, 1</a>.</div>\n</li><li>\n<div id=\"berg2020simple\">Van Den Berg, E. (2021). <i>A simple method for sampling random Clifford operators</i>. <a href='https://doi.org/10.1109/QCE52317.2021.00021'> In: 2021 IEEE International Conference on Quantum Computing and Engineering (QCE), 54–59</a>.</div>\n</li><li>\n<div id=\"wilde2009logical\">Wilde, M. M. (2009). <i>Logical operators of quantum codes</i>. <a href='https://doi.org/10.1103/PhysRevA.79.062322'>Physical Review A <b>79</b>, 062322</a>.</div>\n</li>\n</ul></div>","category":"page"},{"location":"noise/#noise","page":"Noise Processes","title":"Noise Processes","text":"","category":"section"},{"location":"noise/","page":"Noise Processes","title":"Noise Processes","text":"DocTestSetup = quote\n    using QuantumClifford\n    using StableRNGs\n    rng = StableRNG(42)\nend","category":"page"},{"location":"noise/","page":"Noise Processes","title":"Noise Processes","text":"As seen in the list of possible gates, the simulator is capable of modeling different types of noise. If that is your goal, please consider using the available Monte Carlo simulator or the Symbolic Perturbative Expansion system.","category":"page"},{"location":"noise/","page":"Noise Processes","title":"Noise Processes","text":"The implemented types of noise include:","category":"page"},{"location":"noise/","page":"Noise Processes","title":"Noise Processes","text":"UnbiasedUncorrelatedNoise\nPauliNoise","category":"page"},{"location":"noise/","page":"Noise Processes","title":"Noise Processes","text":"The low-level functionality to work with noise is applynoise!, but most of the time you would probably just want to use PauliError,  NoisyGate, NoiseOp and NoiseOpAll.","category":"page"},{"location":"ecc_example_sim/#noisycircuits_pf_ecc_example","page":"ECC example","title":"ECC example with Pauli Frames","text":"","category":"section"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"DocTestSetup = quote\n    using QuantumClifford\n    using Quantikz\nend\nCurrentModule = QuantumClifford.Experimental.NoisyCircuits","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"Consider Steane 7-qubit code:","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"using QuantumClifford\nusing QuantumClifford.ECC: Steane7, naive_syndrome_circuit, naive_encoding_circuit, parity_checks, code_s, code_n\nusing Quantikz\n\ncode = Steane7()\nH = parity_checks(code)","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"... and the corresponding encoding circuit","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"ecirc = naive_encoding_circuit(code)","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"... and the corresponding syndrome measurement circuit (the non-fault tolerant one)","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"scirc, _ = naive_syndrome_circuit(code)","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"The most straightforward way to start sampling syndromes is to set up a table of Pauli frames.","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"circuit = [ecirc..., scirc...]\nnframes = 4\nframes = pftrajectories(circuit; trajectories=nframes) # run the sims\npfmeasurements(frames)                                 # extract the measurements","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"The pftrajectories function is multithreaded. If you want more low-level control over these Pauli frame simulations, check out the PauliFrame structure, the other methods of pftrajectories, and the circuit compactifaction function compactify_circuit.","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"If you want to model Pauli errors, use:","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"The helper PauliError for unbiased Pauli noise operation acting on a given qubit\nThe lower level NoiseOp (for a single qubit) or NoiseOpAll (for all qubits) parameterized with a particular noise type, e.g. UnbiasedUncorrelatedNoise","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"errprob = 0.1\nerrors = [PauliError(i,errprob) for i in 1:code_n(code)]\nfullcircuit = [ecirc..., errors..., scirc...]","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"And running this noisy simulation:","category":"page"},{"location":"ecc_example_sim/","page":"ECC example","title":"ECC example","text":"frames = pftrajectories(fullcircuit; trajectories=nframes)\npfmeasurements(frames)","category":"page"},{"location":"stab-algebra-manual/#Stabilizer-Tableau-Algebra-Manual","page":"Manual","title":"Stabilizer Tableau Algebra Manual","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"DocTestSetup = quote\n    using QuantumClifford\nend","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"The library consists of two main parts: Tools for working with the algebra of Stabilizer tableaux and tools specifically for efficient Circuit Simulation. This chapter discusses the former \"lower level\" Stabilizer tableau algebra tools.","category":"page"},{"location":"stab-algebra-manual/#Pauli-Operators","page":"Manual","title":"Pauli Operators","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"The PauliOperator object representes multi-qubit Pauli operator (1iIZXY^otimes n). It is stored in memory as a phase (a single byte where 0x0,0x1,0x2,0x3 corresponds to 1i-1-i) and two bit-arrays, for X and for Z components.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"You can create them with a P string.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> P\"-iXZ\"\n-iXZ","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Or by specifying phase and X/Z components:","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> PauliOperator(0x0,Bool[0,1,0],Bool[0,0,1])\n+ _XZ","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Both underscore and I can be used for identity.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> P\"I_XYZ\"\n+ __XYZ","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Multiplication with scalars or other Pauli operators works as expected, as well as tensor products of Pauli operators.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> -1im*P\"X\"\n-iX\n\njulia> P\"X\" * P\"Z\"\n-iY\n\njulia> P\"X\" ⊗ P\"Z\"\n+ XZ","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"One can check for commutativity with comm.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> comm(P\"X\",P\"Z\")\n0x01\n\njulia> comm(P\"XX\",P\"ZZ\")\n0x00","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"And check the phase of a product with prodphase.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> prodphase(P\"X\", P\"Z\")\n0x03\n\njulia> prodphase(P\"X\", P\"iZ\")\n0x00\n\njulia> prodphase(P\"X\",P\"Y\")\n0x01","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Indexing operations are available.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> p = P\"IXYZ\";\n\njulia> p[1], p[2], p[3], p[4]\n((false, false), (true, false), (true, true), (false, true))\n\njulia> p = P\"III\";\n\njulia> p[2] = (true, true);\n\njulia> p\n+ _Y_","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Including fancy indexing:","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> P\"IXYZ\"[[2,3]]\n+ XY\n\njulia> P\"IXYZ\"[[false,true,true,false]]\n+ XY","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"The operator is represented in memory by bit arrays (much denser than using byte arrays).","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> p = P\"-IXYZ\";\n\njulia> p.nqubits, p.xz\n(4, UInt64[0x0000000000000006, 0x000000000000000c])","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Views that give just the X or Z components of the xz bitarray are available through xview and zview.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> xview(P\"XYZI\")\n1-element view(::Vector{UInt64}, 1:1) with eltype UInt64:\n 0x0000000000000003","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"The convenience methods xbit and zbit give you Bool (GF2) vectors.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> xbit(P\"XYZI\")\n4-element Vector{Bool}:\n 1\n 1\n 0\n 0","category":"page"},{"location":"stab-algebra-manual/#Stabilizers","page":"Manual","title":"Stabilizers","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"A Stabilizer object is a tableau of Pauli operators. When the tableau is meant to represent a (pure or mixed) stabilizer state, all of these operators should commute (but that is not enforced, rather Stabilizer is a generic tableau data structure). It is stored in memory as a phase list and a bit-matrix for X and Z components. It can be instantiated by an S string, or with a number of different constructors.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"tip: Stabilizers and Destabilizers\nIn many cases you probably would prefer to use the MixedDestabilizer data structure, as it caries a lot of useful additional information, like tracking rank and destabilizer operators. Stabilizer has mostly a pedagogical value, and it is also used for slightly faster simulation of a particular subset of Clifford operations. See also the data structures discussion page.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> S\"-XX\n         +ZZ\"\n- XX\n+ ZZ\n\njulia> Stabilizer([P\"-XX\",P\"+ZZ\"])\n- XX\n+ ZZ\n\njulia> Stabilizer([0x2, 0x0],\n                  Bool[1 1;\n                       0 0],\n                  Bool[0 0;\n                       1 1])\n- XX\n+ ZZ","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Direct sums can be performed,","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> S\"-XX\" ⊗ S\"ZZ\"\n- XX__\n+ __ZZ","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Indexing operations are available, including fancy indexing. Be careful about how phase information gets transferred during sub-indexing.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> s = S\"-XYZ\n             -ZIX\n             +XIZ\";\n\njulia> s[1]\n- XYZ\n\njulia> s[1,2]\n(true, true)\n\njulia> s[[3,1]]\n+ X_Z\n- XYZ\n\njulia> s[[3,1],[2]]\n+ _\n- Y","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Consistency at creation is not verified so nonsensical stabilizers can be created, both in terms of content and shape.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> S\"iX\n         +Z\"\n+iX\n+ Z","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Similarly to the Pauli operators, a bit array representation is used.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> s = S\"-XXX\n             +ZZI\n             -IZZ\"\n- XXX\n+ ZZ_\n- _ZZ\n\njulia> phases(s), tab(s).xzs\n(UInt8[0x02, 0x00, 0x02], UInt64[0x0000000000000007 0x0000000000000000 0x0000000000000000; 0x0000000000000000 0x0000000000000003 0x0000000000000006])","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"And there are convenience functions that can extract the corresponding binary check matrix.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> stab_to_gf2(s)\n3×6 Matrix{Bool}:\n 1  1  1  0  0  0\n 0  0  0  1  1  0\n 0  0  0  0  1  1","category":"page"},{"location":"stab-algebra-manual/#Canonicalization-of-Stabilizers","page":"Manual","title":"Canonicalization of Stabilizers","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Canonicalization (akin to Gaussian elimination over F(2,2)) is implemented in the canonicalize! function. Besides the default canonicalization prescription, alternative ones are available as described in the canonicalization page.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> s = S\"-XXX\n             +ZZX\n             +III\";\n\njulia> canonicalize!(s)\n+ YY_\n+ ZZX\n+ ___","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"If phases are inconsequential, the operations can be faster by not tracking and updating them.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> s = S\"-XXX\n             +ZZX\n             +III\";\n\njulia> canonicalize!(s; phases=false)\n- YY_\n+ ZZX\n+ ___","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"These operations are in place (as customarily signified by \"!\").","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> s = S\"-XXX\n             +ZZX\n             +III\";\n\njulia> canonicalize!(s; phases=false);\n\njulia> s\n- YY_\n+ ZZX\n+ ___","category":"page"},{"location":"stab-algebra-manual/#Projective-Measurements","page":"Manual","title":"Projective Measurements","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"The project! function is used to perform generic projective measurements.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"tip: Single qubit projections\nIf you know your Pauli measurement operator acts on a single qubit, there are much faster projection functions available, discussed in the next section. Namely projectX!, projectY!, and projectZ!.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"To observe the effect of different projections, we will start with a GHZ state.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> s = S\"-XXX\n             +ZZI\n             -IZZ\";","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"The project! function returns the new stabilizer, the index where the anticommutation was detected, and the result of the projection (nothing being an undetermined result). For instance here we project on an operator that does not commute with all stabilizer generators.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> project!(copy(s), P\"ZII\")[1]\n+ Z__\n+ ZZ_\n- _ZZ","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Importantly, when there is an undetermined result, we return nothing and leave the phase of the new stabilizer the same as the phase of the projection operator. If you want to perform a Monte Carlo simulation, you need to randomize the phase of the stabilizer at the anticommuting index yourself. For instance, one can do:","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> newstate, anticomindex, result = project!(copy(s), P\"XII\")\n       if isnothing(result)\n           phases(newstate)[anticomindex] = rand([0x0,0x2])\n       end\n       result, anticomindex\n(nothing, 2)","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Of course, this is a rather cumbersome way to run a simulation, so we also provide projectrand! which does the necessary randomization automatically, for cases where you do not need the fine grained control of project!.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"We can project on a commuting operator, hence no anticommuting terms (the index is zero), and the result is perfectly determined (-1, or in our convention to represent the phase, 0x2).","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> project!(copy(s), P\"-ZZI\")\n(Stabilizer 3×3, 0, 0x02)","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"When the projection is consistent with the stabilizer (i.e. the measurement result is not nothing), this would trigger an expensive canonicalization procedure in order to calculate the measurement result (unless we are using more advanced data structures to represent the state, which are discussed later). If all you want to know is whether the projection is consistent with the stabilizer, but you do not care about the measurement result, you can skip the canonicalization and calculation of the result.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> project!(copy(s), P\"-ZZI\", keep_result=false)\n(Stabilizer 3×3, 0, nothing)","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Lastly, in either case, you can skip the calculation of the phases as well, if they are unimportant.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> project!(copy(s), P\"ZZI\", phases=false)\n(Stabilizer 3×3, 0, 0x00)","category":"page"},{"location":"stab-algebra-manual/#Sparse-single-qubit-measurements","page":"Manual","title":"Sparse single-qubit measurements","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"In many circumstances only a single-qubit operator is being measured. In that case one should use the projectX!, projectY!, and projectZ! functions as they are much faster thanks to tracking only a single qubit. They have versions that randomize the phase as necessary as well:  projectXrand!, projectYrand!, and projectZrand!.","category":"page"},{"location":"stab-algebra-manual/#Gate-like-interface","page":"Manual","title":"Gate-like interface","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"If you do not need all this boilerplate, and especially if you want to perform the randomization automatically, you can use the gate-like \"symbolic\" objects sMX, sMY, and sMZ, that perform the measurement and the necessary randomization of phase. If the measurement result is to be stored, you can use the Register structure that stores both stabilizer tableaux and bit values.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> state = Register(ghz(3), [false,false])\nRegister{Vector{UInt8}, Matrix{UInt64}}(Rank 3 stabilizer\n+ Z__\n+ _X_\n+ __X\n═════\n+ XXX\n+ ZZ_\n+ Z_Z\n═════\n, Bool[0, 0])\n\njulia> apply!(state, sMX(3,2)) # which qubit is measured and in which bit it is stored\nRegister{Vector{UInt8}, Matrix{UInt64}}(Rank 3 stabilizer\n+ Z__\n+ _X_\n+ Z_Z\n═════\n+ XXX\n+ ZZ_\n- __X\n═════\n, Bool[0, 1])\n\njulia> bitview(state)\n2-element Vector{Bool}:\n 0\n 1","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Or you can use the projectXrand!, projectYrand!, and projectZrand! if you prefer a function-call interface.","category":"page"},{"location":"stab-algebra-manual/#Partial-Traces","page":"Manual","title":"Partial Traces","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Partial trace (using traceout!) over even a single qubit might cause many of them to decohere due to entanglement.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> ghz = S\"XXX\n               ZZ_\n               _ZZ\";\n\njulia> traceout!(ghz, [1])\n+ _ZZ\n+ ___\n+ ___","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"This is somewhat more elegant when the datastructure being used explicitly supports mixed states.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> ghz = MixedStabilizer(S\"XXX\n                               ZZ_\n                               _ZZ\");\n\njulia> traceout!(ghz, [1])\n+ _ZZ","category":"page"},{"location":"stab-algebra-manual/#Generating-a-Pauli-Operator-with-Stabilizer-Generators","page":"Manual","title":"Generating a Pauli Operator with Stabilizer Generators","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"The generate! function attempts to generate a Pauli operator by multiplying together the operators belonging to a given stabilizer (or reports their independence). This particular function requires the stabilizer to be already canonicalized.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> s = S\"-XXX\n             +ZZI\n             -IZZ\";\n\njulia> s = canonicalize!(s)\n- XXX\n- Z_Z\n- _ZZ","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"It modifies the Pauli operator in place, reducing it to identity if possible. The leftover phase is present to indicate if the phase itself could not have been canceled. The list of indices specifies which rows of the stabilizer were used to generated the desired Pauli operator.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> generate!(P\"XYY\", s)\n(- ___, [1, 3])","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Phases can be neglected, for higher performance.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> generate!(P\"XYY\", s, phases=false)\n(+ ___, [1, 3])","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"If the Pauli operator can not be generated by the stabilizer, nothing value is returned.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> generate!(P\"ZZZ\", s)\n\njulia> generate!(P\"XZX\", s)\n\njulia> generate!(P\"YYY\", s)","category":"page"},{"location":"stab-algebra-manual/#Clifford-Operators","page":"Manual","title":"Clifford Operators","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"The CliffordOperator structure represents a linear mapping between stabilizers (which should also preserve commutation relationships, but that is not checked at instantiation). These are n-qubit dense tableaux, representing an operation on n-qubit states. For single- or two-qubit gates, it is much more efficient to use small sparse symbolic clifford operators. A number of predefined Clifford operators are available, their name prefixed with t to mark them as dense tableaux.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> tHadamard\nX₁ ⟼ + Z\nZ₁ ⟼ + X\n\njulia> tPhase\nX₁ ⟼ + Y\nZ₁ ⟼ + Z\n\njulia> tCNOT\nX₁ ⟼ + XX\nX₂ ⟼ + _X\nZ₁ ⟼ + Z_\nZ₂ ⟼ + ZZ\n\njulia> tId1\nX₁ ⟼ + X\nZ₁ ⟼ + Z","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Chaining and tensor products are possible. Same for qubit permutations.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> tHadamard ⊗ tPhase\nX₁ ⟼ + Z_\nX₂ ⟼ + _Y\nZ₁ ⟼ + X_\nZ₂ ⟼ + _Z\n\njulia> tHadamard * tPhase\nX₁ ⟼ - Y\nZ₁ ⟼ + X\n\njulia> permute(tCNOT, [2,1])\nX₁ ⟼ + X_\nX₂ ⟼ + XX\nZ₁ ⟼ + ZZ\nZ₂ ⟼ + _Z","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"You can create custom Clifford operators with C-strings or with a list of Pauli operators.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> C\"-ZZ\n         +_Z\n         -X_\n         +XX\"\nX₁ ⟼ - ZZ\nX₂ ⟼ + _Z\nZ₁ ⟼ - X_\nZ₂ ⟼ + XX\n\njulia> CliffordOperator([P\"-ZZ\", P\"_Z\", P\"-X_\", P\"XX\"])\nX₁ ⟼ - ZZ\nX₂ ⟼ + _Z\nZ₁ ⟼ - X_\nZ₂ ⟼ + XX","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Naturally, the operators can be applied to stabilizer states. This includes high performance in-place operations (and the phase can be neglected with phases=false for faster computation).","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> tCNOT * S\"X_\"\n+ XX\n\njulia> s = S\"X_\";\n\njulia> apply!(s,tCNOT)\n+ XX","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Sparse applications where a small Clifford operator is applied only on a particular subset of a larger stabilizer is also possible, but in such circumstances it is useful to consider using symbolic operators too.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> s = S\"Z_YX\";\n\njulia> apply!(s, tCNOT, [4,2]) # Apply the CNOT on qubits 4 and 2\n+ ZXYX","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Pauli operators act as Clifford operators too (but they are rather boring, as they only change signs).","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> P\"XII\" * S\"ZXX\"\n- ZXX","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Internally, the CliffordOperator structure simply stores the tableau representation of the operation.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"The apply! function is efficiently multithreaded for CliffordOperators. To start multithreaded Julia, use julia -t<N> where <N> specifies the number of threads.","category":"page"},{"location":"stab-algebra-manual/#Symbolic-Clifford-Operators","page":"Manual","title":"Symbolic Clifford Operators","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Much faster implementations for a number of common Clifford operators are available. They are stored as special named structs, instead of as a full tableau. These are the subtypes of AbstractSingleQubitOperator and AbstractTwoQubitOperator. Currently these are:","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"using QuantumClifford # hide\nusing InteractiveUtils # hide\nsubtypes(QuantumClifford.AbstractSingleQubitOperator)","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"subtypes(QuantumClifford.AbstractTwoQubitOperator)","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Generally, they have the prefix s for symbolic/small/sparse. They are used slightly differently, as one needs to specify the qubits on which they act while instantiating them:","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> sHadamard(2)\nsHadamard on qubit 2\nX₁ ⟼ + Z\nZ₁ ⟼ + X\n\njulia> sHadamard(2)*S\"XXX\"\n+ XZX\n\njulia> sCNOT(2,3)*S\"XYY\"\n- XXZ","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"The apply! function is efficiently multithreaded for these symbolic operators as well. To start multithreaded Julia, use julia -t<N> where <N> specifies the number of threads.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Symbolic projectors on single qubits also exist: sMX, sMY, sMZ. When used with the Register state representation, they can store the measurement results in the corresponding classical register.","category":"page"},{"location":"stab-algebra-manual/#Destabilizers","page":"Manual","title":"Destabilizers","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Slightly abusing the name: What we call \"destabilizers\" here is a stabilizer and its destabilizing operators saved together. They are implemented with the Destabilizer object and are initialized from a stabilizer.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> s=S\"-XXX\n           -ZZI\n           +IZZ\";\n\njulia> d = Destabilizer(s)\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z__\n+ _X_\n+ __X\n𝒮𝓉𝒶𝒷━\n- XXX\n- ZZ_\n- Z_Z","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"They have convenience methods to extract only the stabilizer and destabilizer pieces:","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> stabilizerview(d)\n- XXX\n- ZZ_\n- Z_Z\n\njulia> destabilizerview(d)\n+ Z__\n+ _X_\n+ __X","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Importantly commuting projections are much faster when tracking the destabilizer as canonicalization is not necessary (an mathcalO(n^2) complexity because it avoids the expensive mathcalO(n^3) canonicalization operation).","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> project!(d,P\"ZZI\")\n(Destablizer 3×3, 0, 0x02)","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Non-commuting projections are just as fast as when using only stabilizers.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> project!(d,P\"ZZZ\")\n(Destablizer 3×3, 1, nothing)","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Clifford operations can be applied the same way they are applied to stabilizers.","category":"page"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"julia> apply!(d,tCNOT⊗tHadamard)\n𝒟ℯ𝓈𝓉𝒶𝒷\n- X_Z\n+ XXZ\n+ X__\n𝒮𝓉𝒶𝒷━\n+ _ZX\n- _Z_\n- Z_X","category":"page"},{"location":"stab-algebra-manual/#Mixed-States","page":"Manual","title":"Mixed States","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"Both the Stabilizer and Destabilizer structures have more general forms that enable work with mixed stabilizer states. They are the MixedStabilizer and MixedDestabilizer structures, described in Mixed States. More information that can be seen in the data structures page, which expands upon the algorithms available for each structure.","category":"page"},{"location":"stab-algebra-manual/#Random-States-and-Circuits","page":"Manual","title":"Random States and Circuits","text":"","category":"section"},{"location":"stab-algebra-manual/","page":"Manual","title":"Manual","text":"random_clifford, random_stabilizer, and enumerate_cliffords can be used for the generation of random states.","category":"page"},{"location":"tutandpub/#tutandpub","page":"Tutorials and Publications","title":"Tutorials and Publications","text":"","category":"section"},{"location":"tutandpub/","page":"Tutorials and Publications","title":"Tutorials and Publications","text":"This list has a number of notebooks with tutorials, examples, and reproduction of published results (some of these results originally obtained with this very library).","category":"page"},{"location":"tutandpub/#On-the-topic-of-explicit-use-of-the-Tableaux-formalism-for-Stabilizer-states","page":"Tutorials and Publications","title":"On the topic of explicit use of the Tableaux formalism for Stabilizer states","text":"","category":"section"},{"location":"tutandpub/","page":"Tutorials and Publications","title":"Tutorials and Publications","text":"Quantum coding with low-depth random circuits reproducing results from (Gullans *et al.*, 2020). view on nbviewer.jupyter.org","category":"page"},{"location":"tutandpub/#On-the-Monte-Carlo-and-Perturbative-Expansions-for-**Noisy**-Clifford-circuits","page":"Tutorials and Publications","title":"On the Monte Carlo and Perturbative Expansions for Noisy Clifford circuits","text":"","category":"section"},{"location":"tutandpub/","page":"Tutorials and Publications","title":"Tutorials and Publications","text":"In-depth study of multi-partite entanglement purification circuits reproducing results from (Krastanov *et al.*, 2020). view on nbviewer.jupyter.org\nComparing the Monte Carlo and Perturbative method for noisy circuit simulations. view on nbviewer.jupyter.org\nShowcasing symbolic perturbative expansions of noisy circuits. view on nbviewer.jupyter.org","category":"page"},{"location":"noisycircuits_API/#Full-API-(autogenerated)","page":"API","title":"Full API (autogenerated)","text":"","category":"section"},{"location":"noisycircuits_API/","page":"API","title":"API","text":"warning: Unstable\nThis is experimental functionality with an unstable API.","category":"page"},{"location":"noisycircuits_API/","page":"API","title":"API","text":"Modules = [QuantumClifford.Experimental.NoisyCircuits]\nPrivate = false","category":"page"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.ConditionalGate","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.ConditionalGate","text":"A conditional gate that either performs truegate or falsegate, depending on the value of controlbit.\n\n\n\n\n\n","category":"type"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.DecisionGate","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.DecisionGate","text":"A conditional gate that performs one of the gates, depending on the output of decisionfunction applied to the entire classical bit register.\n\n\n\n\n\n","category":"type"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.NoisyBellMeasurement","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.NoisyBellMeasurement","text":"A Bell measurement in which each of the measured qubits has a chance to have flipped.\n\n\n\n\n\n","category":"type"},{"location":"noisycircuits_perturb/#noisycircuits_perturb","page":"Perturbative Expansions","title":"Perturbative expansions for simulating noisy Clifford circuits","text":"","category":"section"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"DocTestSetup = quote\n    using QuantumClifford\n    using QuantumClifford.Experimental.NoisyCircuits\n    using Quantikz\nend\nCurrentModule = QuantumClifford.Experimental.NoisyCircuits","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"warning: Unstable\nThis is experimental functionality with an unstable API.","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"Import with using QuantumClifford.Experimental.NoisyCircuits.","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"This module enables the simulation of noisy Clifford circuits through a perturbative expansion in the noise parameter (assuming the noise is small). Instead of simulating many Monte Carlo trajectories, only the leading order trajectories are exhaustively enumerated and simulated.","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"Here is an example of a purification circuit (the same circuit seen in the Monte Carlo example)","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"using QuantumClifford # hide\nusing QuantumClifford.Experimental.NoisyCircuits # hide\nusing Quantikz # hide\ngood_bell_state = S\"XX\n                    ZZ\"\ncanonicalize_rref!(good_bell_state)\ninitial_state = MixedDestabilizer(good_bell_state⊗good_bell_state)\n\ng1 = sCNOT(1,3) # CNOT between qubit 1 and qubit 3 (both with Alice)\ng2 = sCNOT(2,4) # CNOT between qubit 2 and qubit 4 (both with Bob)\nm = BellMeasurement([sMX(3),sMX(4)]) # Bell measurement on qubit 3 and 4\nv = VerifyOp(good_bell_state,[1,2]) # Verify that qubit 1 and 2 indeed form a good Bell pair\nepsilon = 0.01 # The error rate\nn = NoiseOpAll(UnbiasedUncorrelatedNoise(epsilon))\n\n# This circuit performs a depolarization at rate `epsilon` to all qubits,\n# then bilater CNOT operations\n# then a Bell measurement\n# followed by checking whether the final result indeed corresponds to the correct Bell pair.\ncircuit = [n,g1,g2,m,v]\n\npetrajectories(initial_state, circuit)","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"For more examples, see the notebook comparing the Monte Carlo and Perturbative method or this tutorial on entanglement purification.","category":"page"},{"location":"noisycircuits_perturb/#Symbolic-expansions","page":"Perturbative Expansions","title":"Symbolic expansions","text":"","category":"section"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"The perturbative expansion method works with symbolic variables as well. One can use any of the symbolic libraries available in Julia and simply plug symbolic parameters in lieu of numeric parameters. A detailed example is available as a Jupyter notebook.","category":"page"},{"location":"noisycircuits_perturb/#Interface-for-custom-operations","page":"Perturbative Expansions","title":"Interface for custom operations","text":"","category":"section"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"If you want to create a custom gate type (e.g. calling it Operation), you need to definite the following methods.","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"applyop_branches!(s::T, g::Operation; max_order=1)::Vector{Tuple{T,Symbol,Real,Int}} where T is a tableaux type like Stabilizer or a Register. The Symbol is the status of the operation, the Real is the probability for that branch, and the Int is the order of that branch.","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"There is also applynoise_branches! which is convenient for use in NoisyGate, but you can also just make up your own noise operator simply by implementing applyop_branches! for it.","category":"page"},{"location":"noisycircuits_perturb/","page":"Perturbative Expansions","title":"Perturbative Expansions","text":"You can also consult the list of implemented operators.","category":"page"},{"location":"graphs/#Graph-States","page":"Graph States","title":"Graph States","text":"","category":"section"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"warning: The `graphstate` API is not considered stable\ngraphstate returns a lot of information about encoding a given stabilizer state in a graph. A different API is being designed that streamlines the work with graph states.","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"Conversion to and from graph states is possible.","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"Consider a GHZ state:","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"using QuantumClifford # hide\nghz(4)","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"It can be converted to a graph state with graphstate","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"graphstate(ghz(4))[1]","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"using Random; Random.seed!(1); using QuantumClifford, GraphMakie, CairoMakie;\nf = Figure(resolution=(200,200))\na = Axis(f[1,1])\ngraphplot!(a,graphstate(ghz(4))[1])\nhidedecorations!(a); hidespines!(a)\na.aspect = DataAspect()\nsave(\"ghz4graph.png\", f); nothing","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"(Image: )","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"Notice that the initial GHZ state was not in the typical graph state form. We can see that explicitly by converting back and forth between the two forms:","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"julia> using Graphs, QuantumClifford\n\njulia> ghz(4)\n+ XXXX\n+ ZZ__\n+ _ZZ_\n+ __ZZ\n\njulia> Stabilizer(Graph(ghz(4)))\n+ XZZZ\n+ ZX__\n+ Z_X_\n+ Z__X","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"There is a set of single-qubit operations that can convert any stabilizer tableau into a state representable as a graph. These transformations are performed implicitly by the Graph constructor when converting from a Stabilizer. If you need the explicit transformation you can use the graphstate function that specifies which qubits require a Hadamard, Inverse Phase, or Phase Flip gate. The graph_gatesequence or graph_gate helper functions can be used to generate the exact operations:","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"julia> s = ghz(4)\n+ XXXX\n+ ZZ__\n+ _ZZ_\n+ __ZZ\n\njulia> g, h_idx, ip_idx, z_idx = graphstate(s);\n\njulia> gate = graph_gate(h_idx, ip_idx, z_idx, nqubits(s))\nX₁ ⟼ + X___\nX₂ ⟼ + _Z__\nX₃ ⟼ + __Z_\nX₄ ⟼ + ___Z\nZ₁ ⟼ + Z___\nZ₂ ⟼ + _X__\nZ₃ ⟼ + __X_\nZ₄ ⟼ + ___X\n\njulia> canonicalize!(apply!(s,gate)) == canonicalize!(Stabilizer(g))\ntrue","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"These converters also provides for a convenient way to create graph and cluster states, by using the helper constructors provided in Graphs.jl.","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"julia> Stabilizer(grid([4,1])) # Linear cluster state\n+ XZ__\n+ ZXZ_\n+ _ZXZ\n+ __ZX\n\njulia> Stabilizer(grid([2,2])) # Small 2D cluster state\n+ XZZ_\n+ ZX_Z\n+ Z_XZ\n+ _ZZX","category":"page"},{"location":"graphs/","page":"Graph States","title":"Graph States","text":"Graphs are represented with the Graphs.jl package and plotting can be done both in Plots.jl and Makie.jl (with GraphMakie).","category":"page"},{"location":"allops/#all-operations","page":"All Gates","title":"Operations - Gates, Measurements, and More","text":"","category":"section"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"DocTestSetup = quote\n    using QuantumClifford\n    using StableRNGs\n    rng = StableRNG(42)\nend","category":"page"},{"location":"allops/#Operations","page":"All Gates","title":"Operations","text":"","category":"section"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"Acting on quantum states can be performed either:","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"In a \"linear algebra\" language where unitaries, measurements, and other operations have separate interfaces. This is an explicitly deterministic lower-level interface, which provides a great deal of control over how tableaux are manipulated. See the Stabilizer Tableau Algebra Manual as a primer on these approaches.\nOr in a \"circuit\" language, where the operators (and measurements and noise) are represented as circuit gates. This is a higher-level interface in which the outcome of an operation can be stochastic. The API for it is centered around the apply! function. Particularly useful for Monte Carlo simulations and Perturbative Expansion Symbolic Results.","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"In the circuit language, all operations can be applied on a state with the apply! function. Whether they are deterministic and their computational complexity is listed in the table below. A list of lower-level \"linear algebra style\" functions for more control over how an operation is performed is also given.","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"<style>\ntd > code {\n    white-space: pre;\n}\n.content table td, .content table th {\n\tpadding: 0 1em;\n}\n</style>","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"Type Deterministic 𝒪(nˣ) Low-level functions\nAbstractOperation   \n├─ AbstractCliffordOperator   \n│   ├─ AbstractSymbolicOperator   \n│   │   ├─ AbstractSingleQubitOperator   \n│   │   │   ├─ SingleQubitOperator ✔️ n \n│   │   │   ├─ sHadamard ✔️ n \n│   │   │   ├─ sId1 ✔️ n \n│   │   │   ├─ sInvPhase ✔️ n \n│   │   │   ├─ sPhase ✔️ n \n│   │   │   ├─ sX ✔️ n \n│   │   │   ├─ sY ✔️ n \n│   │   │   └─ sZ ✔️ n \n│   │   └─ AbstractTwoQubitOperator   \n│   │       ├─ sCNOT ✔️ n \n│   │       ├─ sCPHASE ✔️ n \n│   │       └─ sSWAP ✔️ n \n│   │   \n│   ├─ CliffordOperator ✔️ n³ \n│   ├─ PauliOperator ✔️ n² \n│   └─ SparseGate ✔️ kn² \n├─ AbstractMeasurement   \n│   ├─ PauliMeasurement ❌ n² project!, projectrand!\n│   ├─ sMX ❌ n² projectX!\n│   ├─ sMY ❌ n² projectY!\n│   └─ sMZ ❌ n² projectZ!\n│   \n├─ BellMeasurement ❌ n² \n├─ NoiseOp ❌ ? applynoise!\n├─ NoiseOpAll ❌ ? applynoise!\n├─ NoisyGate ❌ ? applynoise!\n└─ Reset ✔️ kn² reset_qubits!","category":"page"},{"location":"allops/#Details-of-Operations-Supported-by-[apply!](@ref)","page":"All Gates","title":"Details of Operations Supported by apply!","text":"","category":"section"},{"location":"allops/#Unitary-Gates","page":"All Gates","title":"Unitary Gates","text":"","category":"section"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"We distinguish between symbolic gates like sCNOT that have specialized (fast) apply! methods (usually just for single and two qubit gates) and general tableau representation of gates like CliffordOperator that can represent any multi-qubit gate.","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"Predefined unitary gates are available, like sCNOT, sHadamard, etc.","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"using QuantumClifford # hide\nusing QuantumClifford.Experimental.NoisyCircuits # hide\nusing Quantikz # hide\n[sCNOT(2,4),sHadamard(2),sCPHASE(1,3),sSWAP(2,4)]","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"Any arbitrary tableaux can be used as a gate too. ","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"They can be specified by giving a Clifford operator tableaux and the indices on which it acts (particularly useful for gates acting on a small part of a circuit):","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"using QuantumClifford # hide\nusing QuantumClifford.Experimental.NoisyCircuits # hide\nusing Quantikz # hide\nSparseGate(tCNOT, [2,4])","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"The Clifford operator tableaux can be completely arbitrary.","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"SparseGate(random_clifford(3), [2,4,5])","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"If the Clifford operator acts on all qubits, we do not need to specify indices, just use the operator.","category":"page"},{"location":"allops/#Noisy-Gates","page":"All Gates","title":"Noisy Gates","text":"","category":"section"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"Each gate can be followed by noise applied to the qubits on which it has acted. This is done by wrapping the given gate into a NoisyGate","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"ε = 0.03 # X/Y/Z error probability\nnoise = UnbiasedUncorrelatedNoise(ε)\nnoisy_gate = NoisyGate(SparseGate(tCNOT, [2,4]), noise)","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"In circuit diagrams the noise is not depicted, but after each application of the gate defined in noisy_gate, a noise operator will also be applied. The example above is of Pauli Depolarization implemented by UnbiasedUncorrelatedNoise.","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"One can also apply only the noise operator by using NoiseOp which acts only on specified qubits. Or alternatively, one can use NoiseOpAll in order to apply noise to all qubits.","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"[NoiseOp(noise, [4,5]), NoiseOpAll(noise)]","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"The machinery behind noise processes and different types of noise is detailed in the section on noise","category":"page"},{"location":"allops/#Coincidence-Measurements","page":"All Gates","title":"Coincidence Measurements","text":"","category":"section"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"Global parity measurements involving single-qubit projections and classical communication are implemented with BellMeasurement. One needs to specify the axes of measurement and the qubits being measured. If the parity is trivial, the circuit continues, if the parity is non-trivial, the circuit ends and reports a detected failure. This operator is frequently used in the simulation of entanglement purification.","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"BellMeasurement([sMX(1), sMY(3), sMZ(4)])","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"There is also NoisyBellMeasurement that takes the bit-flip probability of a single-qubit measurement as a third argument.","category":"page"},{"location":"allops/#Stabilizer-Measurements","page":"All Gates","title":"Stabilizer Measurements","text":"","category":"section"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"A measurement over one or more qubits can also be performed, e.g., a direct stabilizer measurement on multiple qubits without the use of ancillary qubits. When applied to multiple qubits, this differs from BellMeasurement as it performs a single projection, unlike BellMeasurement which performs a separate projection for every single qubit involved. This measurement is implemented in PauliMeasurement which requires a Pauli operator on which to project and the index of the classical bit in which to store the result. Alternatively, there are sMX, sMZ, sMY if you are measuring a single qubit.","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"[PauliMeasurement(P\"XYZ\", 1), sMZ(2, 2)]","category":"page"},{"location":"allops/#Reset-Operations","page":"All Gates","title":"Reset Operations","text":"","category":"section"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"The Reset operations lets you trace out the specified qubits and set their state to a specific tableau.","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"new_state = random_stabilizer(3)\nqubit_indices = [1,2,3]\nReset(new_state, qubit_indices)","category":"page"},{"location":"allops/","page":"All Gates","title":"All Gates","text":"It can be done anywhere in a circuit, not just at the beginning.","category":"page"},{"location":"noisycircuits/#Simulation-of-Noisy-Clifford-Circuits","page":"Simulation of Noisy Circuits","title":"Simulation of Noisy Clifford Circuits","text":"","category":"section"},{"location":"noisycircuits/","page":"Simulation of Noisy Circuits","title":"Simulation of Noisy Circuits","text":"DocTestSetup = quote\n    using QuantumClifford\n    using QuantumClifford.Experimental.NoisyCircuits\nend\nCurrentModule = QuantumClifford.Experimental.NoisyCircuits","category":"page"},{"location":"noisycircuits/","page":"Simulation of Noisy Circuits","title":"Simulation of Noisy Circuits","text":"warning: Unstable\nThis is unfinished experimental functionality that will change significantly.","category":"page"},{"location":"noisycircuits/","page":"Simulation of Noisy Circuits","title":"Simulation of Noisy Circuits","text":"We have experimental support for simulation of noisy Clifford circuits which can be imported with using QuantumClifford.Experimental.NoisyCircuits.","category":"page"},{"location":"noisycircuits/","page":"Simulation of Noisy Circuits","title":"Simulation of Noisy Circuits","text":"Both Monte Carlo and Perturbative Expansion approaches are supported. When performing a perturbative expansion in the noise parameter, the expansion can optionally be performed symbolically, to arbitrary high orders.","category":"page"},{"location":"noisycircuits/","page":"Simulation of Noisy Circuits","title":"Simulation of Noisy Circuits","text":"Multiple notebooks with examples are also available. For instance, see this tutorial on entanglement purification for many examples.","category":"page"},{"location":"canonicalization/#Canonicalization-operations","page":"Canonicalization","title":"Canonicalization operations","text":"","category":"section"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"Different types of canonicalization operations are implemented. All of them are types of Gaussian elimination.","category":"page"},{"location":"canonicalization/#[canonicalize!](@ref)","page":"Canonicalization","title":"canonicalize!","text":"","category":"section"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"First do elimination on all X components and only then perform elimination on the Z components. Based on (Garcia *et al.*, 2012). It is used in logdot for inner products of stabilizer states.","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"The final tableaux, if square should look like the following (Image: )","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"If the tableaux is shorter than a square, the diagonals might not reach all the way to the right.","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"using QuantumClifford, CairoMakie\nf=Figure()\nstabilizerplot_axis(f[1,1], canonicalize!(random_stabilizer(20,30)))\nf","category":"page"},{"location":"canonicalization/#[canonicalize_rref!](@ref)","page":"Canonicalization","title":"canonicalize_rref!","text":"","category":"section"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"Cycle between elimination on X and Z for each qubit. Particularly useful for tracing out qubits. Based on (Audenaert and Plenio, 2005). For convenience reasons, the canonicalization starts from the bottom row, and you can specify as a second argument which columns to be canonicalized (useful for tracing out arbitrary qubits, e.g., in traceout!).","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"The tableau canonicalization is done in recursive steps, each one of which results in something akin to one of these three options (Image: )","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"using QuantumClifford, CairoMakie\nf=Figure()\nstabilizerplot_axis(f[1,1], canonicalize_rref!(random_stabilizer(20,30),1:30)[1])\nf","category":"page"},{"location":"canonicalization/#[canonicalize_gott!](@ref)","page":"Canonicalization","title":"canonicalize_gott!","text":"","category":"section"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"First do elimination on all X components and only then perform elimination on the Z components, but without touching the qubits that were eliminated during the X pass. Unlike other canonicalization operations, qubit columns are reordered, providing for a straight diagonal in each block. Particularly useful as certain blocks of the new created matrix are related to logical operations of the corresponding code, e.g. computing the logical X and Z operators of a MixedDestabilizer. Based on (Gottesman, 1997).","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"A canonicalized tableau would look like the following (the right-most block does not exist for square tableaux). (Image: )","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"using QuantumClifford, CairoMakie\nf=Figure()\nstabilizerplot_axis(f[1,1], canonicalize_gott!(random_stabilizer(30))[1])\nf","category":"page"},{"location":"canonicalization/#[canonicalize_clip!](@ref)","page":"Canonicalization","title":"canonicalize_clip!","text":"","category":"section"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"Convert to the \"clipped\" gauge of a stabilizer state resulting in a \"river\" of non-identity operators around the diagonal.","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"using QuantumClifford, CairoMakie\nf=Figure()\nstabilizerplot_axis(f[1,1], canonicalize_clip!(random_stabilizer(30)))\nf","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"The properties of the clipped gauge are:","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"Each qubit is the left/right \"endpoint\" of exactly two stabilizer rows.\nFor the same qubit the two endpoints are always different Pauli operators.","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"This canonicalization is used to derive the bigram a stabilizer state, which is also related to entanglement entropy in the state.","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"Introduced in (Nahum *et al.*, 2017), with a more detailed explanation of the algorithm in Appendix A of (Li *et al.*, 2019).","category":"page"},{"location":"noisycircuits_mc/#noisycircuits_mc","page":"Monte Carlo","title":"Monte Carlo simulations of noisy Clifford circuits","text":"","category":"section"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"DocTestSetup = quote\n    using QuantumClifford\n    using QuantumClifford.Experimental.NoisyCircuits\n    using Quantikz\nend\nCurrentModule = QuantumClifford.Experimental.NoisyCircuits","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"warning: Unstable\nThis is experimental functionality with an unstable API.","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"Import with using QuantumClifford.Experimental.NoisyCircuits.","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"This module enables the simulation of noisy Clifford circuits through a Monte Carlo method where the same circuit is evaluated multiple times with random errors interspersed through it as prescribed by a given error model.","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"Below is an example of a purification circuit. We first prepare the circuit we desire to use, including a noise model. Quantikz.jl was is used to visualize the circuit.","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"using QuantumClifford # hide\nusing QuantumClifford.Experimental.NoisyCircuits # hide\nusing Quantikz # hide\ngood_bell_state = S\"XX\n                    ZZ\"\ninitial_state = MixedDestabilizer(good_bell_state⊗good_bell_state)\n\ng1 = sCNOT(1,3) # CNOT between qubit 1 and qubit 3 (both with Alice)\ng2 = sCNOT(2,4) # CNOT between qubit 2 and qubit 4 (both with Bob)\nm = BellMeasurement([sMX(3),sMX(4)]) # Bell measurement on qubit 3 and 4\nv = VerifyOp(good_bell_state,[1,2]) # Verify that qubit 1 and 2 indeed form a good Bell pair\nepsilon = 0.01 # The error rate\nn = NoiseOpAll(UnbiasedUncorrelatedNoise(epsilon))\n\n# This circuit performs a depolarization at rate `epsilon` to all qubits,\n# then bilater CNOT operations\n# then a Bell measurement\n# followed by checking whether the final result indeed corresponds to the correct Bell pair.\ncircuit = [n,g1,g2,m,v]","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"And we can run a Monte Carlo simulation of that circuit with mctrajectories.","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"mctrajectories(initial_state, circuit, trajectories=500)","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"For more examples, see the notebook comparing the Monte Carlo and Perturbative method or this tutorial on entanglement purification for many examples.","category":"page"},{"location":"noisycircuits_mc/#Interface-for-custom-operations","page":"Monte Carlo","title":"Interface for custom operations","text":"","category":"section"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"If you want to create a custom gate type (e.g. calling it Operation), you need to definite the following methods.","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"applywstatus!(s::T, g::Operation)::Tuple{T,Symbol} where T is a tableaux type like Stabilizer or a Register. The Symbol is the status of the operation. Predefined statuses are kept in the registered_statuses list, but you can add more. Be sure to expand this list if you want the trajectory simulators using your custom statuses to output all trajectories.","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"There is also applynoise! which is convenient wait to create a noise model that can then be plugged into the NoisyGate struct, letting you reuse the predefined perfect gates and measurements. However, you can also just make up your own noise operator simply by implementing applywstatus! for it.","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"You can also consult the list of implemented operators.","category":"page"},{"location":"commonstates/#Useful-States-and-Operators","page":"Useful States","title":"Useful States and Operators","text":"","category":"section"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"DocTestSetup = quote\n    using QuantumClifford\n    using StableRNGs\n    rng = StableRNG(42)\nend","category":"page"},{"location":"commonstates/#States","page":"Useful States","title":"States","text":"","category":"section"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"Stabilizer states can be represented with the Stabilizer, Destabilizer, MixedStabilizer, and MixedDestabilizer tableau data structures. You probably want to use MixedDestabilizer which supports the widest set of operations.","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"Moreover, a MixedDestabilizer can be stored inside a Register together with a set of classical bits in which measurement results can be written.","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"Below are convenience constructors for common types of states and operators, already implemented in this library.","category":"page"},{"location":"commonstates/#Pauli-Operators","page":"Useful States","title":"Pauli Operators","text":"","category":"section"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"Single qubit PauliOperator is implemented in [single_z] and [single_x].","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"julia> single_z(4,2)\n+ _Z__\n\njulia> single_x(4,3)\n+ __X_","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"All identity operators use zero.","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"julia> zero(PauliOperator, 3)\n+ ___\n\njulia> zero(P\"XYZXYZ\")\n+ ______","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"Random Pauli operators are implemented as well (with or without a random phase).","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"julia> using StableRNGs; rng = StableRNG(42);\n\njulia> random_pauli(rng, 4)\n+i_ZZ_\n\njulia> random_pauli(rng, 4; nophase=true)\n+ ZXZY","category":"page"},{"location":"commonstates/#Stabilizer-States","page":"Useful States","title":"Stabilizer States","text":"","category":"section"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"An all-identity stabilizer can be created with zero.","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"julia> zero(Stabilizer, 3)\n+ ___\n+ ___\n+ ___\n\njulia> zero(Stabilizer, 2, 3)\n+ ___\n+ ___\n\njulia> zero(S\"XIZ\n              YZX\")\n+ ___\n+ ___","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"Diagonal stabilizers in different bases are available as well, through one.","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"julia> one(Stabilizer, 3)\n+ Z__\n+ _Z_\n+ __Z\n\njulia> one(Stabilizer, 3; basis=:Y)\n+ Y__\n+ _Y_\n+ __Y\n\njulia> one(S\"XX\n             ZZ\")\n+ Z_\n+ _Z","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"A random stabilizer (or destabilizers or Clifford operators) can be created as well. We use the algorithm described in (Bravyi and Maslov, 2021).","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"julia> random_stabilizer(rng, 2,5)\n+ YZXZZ\n- XZYYY","category":"page"},{"location":"commonstates/#Mixed-States","page":"Useful States","title":"Mixed States","text":"","category":"section"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"Similarly, one can create a diagonal mixed state.","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"julia> one(MixedDestabilizer, 2, 3)\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ X__\n+ _X_\n𝒳ₗ━━━\n+ __X\n𝒮𝓉𝒶𝒷━\n+ Z__\n+ _Z_\n𝒵ₗ━━━\n+ __Z","category":"page"},{"location":"commonstates/#Enumerating-all-Clifford-Operations","page":"Useful States","title":"Enumerating all Clifford Operations","text":"","category":"section"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"The algorithm from (Koenig and Smolin, 2014) can be used to enumerate all Clifford operations on a given number of qubits through enumerate_cliffords. Or one can use random_clifford, random_stabilizer to directly sample from that set.","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"julia> length(enumerate_cliffords(1))\n6\n\njulia> length(enumerate_cliffords(2))\n720","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"To also enumerate possible phases, you can use enumerate_phases.","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"julia> length(collect(enumerate_phases(tCNOT)))\n16\n\njulia> length(collect(enumerate_phases(enumerate_cliffords(2))))\n11520","category":"page"},{"location":"commonstates/#Common-entangled-states","page":"Useful States","title":"Common entangled states","text":"","category":"section"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"Bell states and GHZ states have convenience constructors:","category":"page"},{"location":"commonstates/","page":"Useful States","title":"Useful States","text":"julia> bell()\n+ XX\n+ ZZ\n\njulia> bell(2)\n+ XX__\n+ ZZ__\n+ __XX\n+ __ZZ\n\njulia> ghz(4)\n+ XXXX\n+ ZZ__\n+ _ZZ_\n+ __ZZ","category":"page"},{"location":"API/#Full-API","page":"API","title":"Full API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API/#States","page":"API","title":"States","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Stabilizer states can be represented with the Stabilizer, Destabilizer, MixedStabilizer, and MixedDestabilizer tableau data structures. You probably want to use MixedDestabilizer which supports the widest set of operations.","category":"page"},{"location":"API/","page":"API","title":"API","text":"Moreover, a MixedDestabilizer can be stored inside a Register together with a set of classical bits in which measurement results can be written.","category":"page"},{"location":"API/","page":"API","title":"API","text":"Lastly, for Pauli frame simulations there is the PauliFrame type, a tableau in which each row represents a different Pauli frame.","category":"page"},{"location":"API/","page":"API","title":"API","text":"There are convenience constructors for common types of states and operators.","category":"page"},{"location":"API/#Operations","page":"API","title":"Operations","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Acting on quantum states can be performed either:","category":"page"},{"location":"API/","page":"API","title":"API","text":"In a \"linear algebra\" language where unitaries, measurements, and other operations have separate interfaces. This is an explicitly deterministic lower-level interface, which provides a great deal of control over how tableaux are manipulated. See the Stabilizer Tableau Algebra Manual as a primer on these approaches.\nOr in a \"circuit\" language, where the operators (and measurements and noise) are represented as circuit gates. This is a higher-level interface in which the outcome of an operation can be stochastic. The API for it is centered around the apply! function. Particularly useful for Monte Carlo simulations and Perturbative Expansion Symbolic Results.","category":"page"},{"location":"API/","page":"API","title":"API","text":"See the full list of operations for a list of implemented operations.","category":"page"},{"location":"API/#Autogenerated-API-list","page":"API","title":"Autogenerated API list","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [QuantumClifford]\nPrivate = false","category":"page"},{"location":"API/#QuantumClifford.QuantumClifford","page":"API","title":"QuantumClifford.QuantumClifford","text":"A module for using the Stabilizer formalism and simulating Clifford circuits.\n\n\n\n\n\n","category":"module"},{"location":"API/#QuantumClifford.continue_stat","page":"API","title":"QuantumClifford.continue_stat","text":"Returned by applywstatus! if the circuit simulation should continue.\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumClifford.failure_stat","page":"API","title":"QuantumClifford.failure_stat","text":"Returned by applywstatus! if the circuit reports a failure.\n\nSee also: VerifyOp, BellMeasurement.\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumClifford.false_success_stat","page":"API","title":"QuantumClifford.false_success_stat","text":"Returned by applywstatus! if the circuit reports a success, but it is a false positive (i.e., there was an undetected error).\n\nSee also: VerifyOp, BellMeasurement.\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumClifford.true_success_stat","page":"API","title":"QuantumClifford.true_success_stat","text":"Returned by applywstatus! if the circuit reports a success and there is no undetected error.\n\nSee also: VerifyOp, BellMeasurement.\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumClifford.AbstractSingleQubitOperator","page":"API","title":"QuantumClifford.AbstractSingleQubitOperator","text":"Supertype of all single-qubit symbolic operators.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.AbstractSymbolicOperator","page":"API","title":"QuantumClifford.AbstractSymbolicOperator","text":"Supertype of all symbolic operators. Subtype of AbstractCliffordOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.AbstractTwoQubitOperator","page":"API","title":"QuantumClifford.AbstractTwoQubitOperator","text":"Supertype of all two-qubit symbolic operators.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.BellMeasurement","page":"API","title":"QuantumClifford.BellMeasurement","text":"A Bell measurement performing the correlation measurement corresponding to the given pauli projections on the qubits at the selected indices.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.CircuitStatus","page":"API","title":"QuantumClifford.CircuitStatus","text":"A convenience struct to represent the status of a circuit simulated by mctrajectories\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.ClassicalXOR","page":"API","title":"QuantumClifford.ClassicalXOR","text":"Applies an XOR gate to classical bits. Currently only implemented for funcitonality with pauli frames.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.CliffordOperator","page":"API","title":"QuantumClifford.CliffordOperator","text":"Clifford Operator specified by the mapping of the basis generators.\n\njulia> tCNOT\nX₁ ⟼ + XX\nX₂ ⟼ + _X\nZ₁ ⟼ + Z_\nZ₂ ⟼ + ZZ\n\njulia> phase_gate = C\"Y\n                      Z\"\nX₁ ⟼ + Y\nZ₁ ⟼ + Z\n\njulia> stab = S\"XI\n                IZ\";\n\n\njulia> entangled = tCNOT*stab\n+ XX\n+ ZZ\n\njulia> CliffordOperator(T\"YY\")\nERROR: DimensionMismatch: Input tableau should be of size 2n×n (top half is the X mappings and the bottom half are the Z mappings).\n[...]\n\nDestabilizer can also be converted.\n\njulia> d = Destabilizer(S\"Y\")\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n+ Y\n\njulia> CliffordOperator(d)\nX₁ ⟼ + Z\nZ₁ ⟼ + Y\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.Destabilizer","page":"API","title":"QuantumClifford.Destabilizer","text":"A tableau representation of a pure stabilizer state. The tableau tracks the destabilizers as well, for efficient projections. On initialization there are no checks that the provided state is indeed pure. This enables the use of this data structure for mixed stabilizer state, but a better choice would be to use MixedDestabilizer.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.MixedDestabilizer","page":"API","title":"QuantumClifford.MixedDestabilizer","text":"A tableau representation for mixed stabilizer states that keeps track of the destabilizers in order to provide efficient projection operations.\n\nThe rank r of the n-qubit tableau is tracked, either so that it can be used to represent a mixed stabilizer state, or so that it can be used to represent an n-r logical-qubit code over n physical qubits. The \"logical\" operators are tracked as well.\n\nWhen the constructor is called on an incomplete Stabilizer it automatically calculates the destabilizers and logical operators, following chapter 4 of (Gottesman, 1997). Under the hood the conversion uses the canonicalize_gott! canonicalization. That canonicalization permutes the columns of the tableau, but we automatically undo the column permutation in the preparation of a MixedDestabilizer so that qubits are not reindexed. The boolean keyword arguments undoperm and reportperm can be used to control this behavior and to report the permutations explicitly.\n\nSee also: stabilizerview, destabilizerview, logicalxview, logicalzview\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.MixedStabilizer","page":"API","title":"QuantumClifford.MixedStabilizer","text":"A slight improvement of the Stabilizer data structure that enables more naturally and completely the treatment of mixed states, in particular when the project! function is used.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.NoiseOp","page":"API","title":"QuantumClifford.NoiseOp","text":"An operator that applies the given noise model to the qubits at the selected indices.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.NoiseOpAll","page":"API","title":"QuantumClifford.NoiseOpAll","text":"An operator that applies the given noise model to all qubits.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.NoisyGate","page":"API","title":"QuantumClifford.NoisyGate","text":"A gate consisting of the given noise applied after the given perfect Clifford gate.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.PauliChannel","page":"API","title":"QuantumClifford.PauliChannel","text":"A Pauli channel datastructure, mainly for use with StabMixture\n\nSee also: UnitaryPauliChannel\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.PauliFrame","page":"API","title":"QuantumClifford.PauliFrame","text":"struct PauliFrame{T, S} <: QuantumClifford.AbstractQCState\n\nThis is a wrapper around a tableau. This \"frame\" tableau is not to be viewed as a normal stabilizer tableau, although it does conjugate the same under Clifford operations. Each row in the tableau refers to a single frame. The row represents the Pauli operation by which the frame and the reference differ.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.PauliFrame-Tuple{Any, Any, Any}","page":"API","title":"QuantumClifford.PauliFrame","text":"PauliFrame(\n    frames,\n    qubits,\n    measurements\n) -> PauliFrame{Stabilizer{QuantumClifford.Tableau{Vector{UInt8}, LinearAlgebra.Adjoint{UInt64, Matrix{UInt64}}}}, Matrix{Bool}}\n\n\nPrepare an empty set of Pauli frames with the given number of frames and qubits. Preallocates spaces for measurement number of measurements.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.PauliMeasurement","page":"API","title":"QuantumClifford.PauliMeasurement","text":"A Stabilizer measurement on the entirety of the quantum register.\n\nprojectrand!(state, pauli) and apply!(state, PauliMeasurement(pauli)) give the same (possibly non-deterministic) result. Particularly useful when acting on Register.\n\nSee also: apply!, projectrand!.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.PauliOperator","page":"API","title":"QuantumClifford.PauliOperator","text":"A multi-qubit Pauli operator (1iIZXY^otimes n).\n\nA Pauli can be constructed with the P custom string macro or by building up one through products and tensor products of smaller operators.\n\njulia> pauli3 = P\"-iXYZ\"\n-iXYZ\n\njulia> pauli4 = 1im * pauli3 ⊗ X\n+ XYZX\n\njulia> Z*X\n+iY\n\nWe use a typical F(2,2) encoding internally. The X and Z bits are stored in a single concatenated padded array of UInt chunks of a bit array.\n\njulia> p = P\"-IZXY\";\n\n\njulia> p.xz\n2-element Vector{UInt64}:\n 0x000000000000000c\n 0x000000000000000a\n\nYou can access the X and Z bits through getters and setters or through the xview, zview, xbit, and zbit functions.\n\njulia> p = P\"XYZ\"; p[1]\n(true, false)\n\njulia> p[1] = (true, true); p\n+ YYZ\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.Register","page":"API","title":"QuantumClifford.Register","text":"A register, representing the state of a computer including both a tableaux and an array of classical bits (e.g. for storing measurement results)\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.Reset","page":"API","title":"QuantumClifford.Reset","text":"Reset the specified qubits to the given state.\n\nBe careful, this operation implies first tracing out the qubits, which can lead to mixed states if these qubits were entangled with the rest of the system.\n\nSee also: sMRZ\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.SingleQubitOperator","page":"API","title":"QuantumClifford.SingleQubitOperator","text":"A \"symbolic\" general single-qubit operator which permits faster multiplication than an operator expressed as an explicit tableau.\n\njulia> op = SingleQubitOperator(2, true, true, true, false, true, true) # Tableau components and phases\nSingleQubitOperator on qubit 2\nX₁ ⟼ - Y\nZ₁ ⟼ - X\n\njulia> typeof(op)\nSingleQubitOperator\n\njulia> t_op = CliffordOperator(op, 3) # Transforming it back into an explicit tableau representation (specifying the size)\nX₁ ⟼ + X__\nX₂ ⟼ - _Y_\nX₃ ⟼ + __X\nZ₁ ⟼ + Z__\nZ₂ ⟼ - _X_\nZ₃ ⟼ + __Z\n\njulia> typeof(t_op)\nCliffordOperator{QuantumClifford.Tableau{Vector{UInt8}, Matrix{UInt64}}}\n\njulia> CliffordOperator(op, 1, compact=true) # You can also extract just the non-trivial part of the tableau\nX₁ ⟼ - Y\nZ₁ ⟼ - X\n\nSee also: sHadamard, sPhase, sId1, sX, sY, sZ, CliffordOperator\n\nOr simply consult subtypes(QuantumClifford.AbstractSingleQubitOperator) and subtypes(QuantumClifford.AbstractTwoQubitOperator) for a full list. You can think of the s prefix as \"symbolic\" or \"sparse\".\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.SparseGate","page":"API","title":"QuantumClifford.SparseGate","text":"A Clifford gate, applying the given cliff operator to the qubits at the selected indices.\n\napply!(state, cliff, indices) and apply!(state, SparseGate(cliff, indices)) give the same result.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.StabMixture","page":"API","title":"QuantumClifford.StabMixture","text":"mutable struct StabMixture{T, F}\n\nRepresents mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is a pure stabilizer state.\n\njulia> StabMixture(S\"-X\")\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n- X\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 1.0+0.0im | + _ | + _\n\njulia> pcT\nA unitary Pauli channel P = ∑ ϕᵢ Pᵢ with the following branches:\nwith ϕᵢ | Pᵢ\n 0.853553+0.353553im | + _\n 0.146447-0.353553im | + Z\n\njulia> apply!(StabMixture(S\"-X\"), pcT)\nA mixture ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† where ρ is\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n- X\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 0.0+0.353553im | + _ | + Z\n 0.0-0.353553im | + Z | + _\n 0.853553+0.0im | + _ | + _\n 0.146447+0.0im | + Z | + Z\n\nSee also: PauliChannel\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.Stabilizer","page":"API","title":"QuantumClifford.Stabilizer","text":"Stabilizer, i.e. a list of commuting multi-qubit Hermitian Pauli operators.\n\nInstances can be created with the S custom string macro or as direct sum of other stabilizers.\n\ntip: Stabilizers and Destabilizers\nIn many cases you probably would prefer to use the MixedDestabilizer data structure, as it caries a lot of useful additional information, like tracking rank and destabilizer operators. Stabilizer has mostly a pedagogical value, and it is also used for slightly faster simulation of a particular subset of Clifford operations.\n\njulia> s = S\"XXX\n             ZZI\n             IZZ\"\n+ XXX\n+ ZZ_\n+ _ZZ\n\njulia> s⊗s\n+ XXX___\n+ ZZ____\n+ _ZZ___\n+ ___XXX\n+ ___ZZ_\n+ ____ZZ\n\nIt has an indexing API, looking like a list of PauliOperators.\n\njulia> s[2]\n+ ZZ_\n\nPauli operators can act directly on the a stabilizer.\n\njulia> P\"YYY\" * s\n- XXX\n+ ZZ_\n+ _ZZ\n\nThere are a number of ways to create a Stabilizer, including:\n\ngenerate Stabilizers from a list of Pauli operators\n\njulia> Stabilizer([P\"XX\", P\"ZZ\"])\n+ XX\n+ ZZ\n\ngenerate Stabilizers from boolean matrices\n\njulia> a = [true true; false false]; b = [false true; true true];\n\njulia> Stabilizer(a, b)\n+ XY\n+ ZZ\n\njulia> Stabilizer([0x0, 0x2], a, b)\n+ XY\n- ZZ\n\ninitialize an empty Stabilizer and fill it through indexing\n\njulia> s = zero(Stabilizer, 2)\n+ __\n+ __\n\njulia> s[1,1] = (true, false); s\n+ X_\n+ __\n\nThere are no automatic checks for correctness (i.e. independence of all rows, commutativity of all rows, hermiticity of all rows). The rank (number of rows) is permitted to be less than the number of qubits (number of columns): canonilization, projection, etc. continue working in that case. To great extent this library uses the Stabilizer data structure simply as a tableau. This might be properly abstracted away in future versions.\n\nSee also: PauliOperator, canonicalize!\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.Stabilizer-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"API","title":"QuantumClifford.Stabilizer","text":"Convert a graph representing a stabilizer state to an explicit Stabilizer.\n\nSee also: graphstate\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.UnbiasedUncorrelatedNoise","page":"API","title":"QuantumClifford.UnbiasedUncorrelatedNoise","text":"Depolarization noise model with total probability of error 3*errprobthird.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.UnitaryPauliChannel","page":"API","title":"QuantumClifford.UnitaryPauliChannel","text":"A Pauli channel datastructure, mainly for use with StabMixture.\n\nMore convenient to use than PauliChannel when you know your Pauli channel is unitary.\n\njulia> Tgate = UnitaryPauliChannel(\n           (I, Z),\n           ((1+exp(im*π/4))/2, (1-exp(im*π/4))/2)\n       )\nA unitary Pauli channel P = ∑ ϕᵢ Pᵢ with the following branches:\nwith ϕᵢ | Pᵢ\n 0.853553+0.353553im | + _\n 0.146447-0.353553im | + Z\n\njulia> PauliChannel(Tgate)\nPauli channel ρ ↦ ∑ ϕᵢⱼ Pᵢ ρ Pⱼ† with the following branches:\nwith ϕᵢⱼ | Pᵢ | Pⱼ:\n 0.853553+0.0im | + _ | + _\n 0.0+0.353553im | + _ | + Z\n 0.0-0.353553im | + Z | + _\n 0.146447+0.0im | + Z | + Z\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.VerifyOp","page":"API","title":"QuantumClifford.VerifyOp","text":"A \"probe\" to verify that the state of the qubits corresponds to a desired good_state, e.g. at the end of the execution of a circuit.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sCNOT","page":"API","title":"QuantumClifford.sCNOT","text":"A \"symbolic\" CNOT. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sCPHASE","page":"API","title":"QuantumClifford.sCPHASE","text":"A \"symbolic\" CPHASE. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sHadamard","page":"API","title":"QuantumClifford.sHadamard","text":"A \"symbolic\" single-qubit Hadamard. See also: SingleQubitOperator, AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sId1","page":"API","title":"QuantumClifford.sId1","text":"A \"symbolic\" single-qubit Identity operation.\n\nSee also: SingleQubitOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sInvPhase","page":"API","title":"QuantumClifford.sInvPhase","text":"A \"symbolic\" single-qubit InvPhase. See also: SingleQubitOperator, AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sMRX","page":"API","title":"QuantumClifford.sMRX","text":"Measure a qubit in the X basis and reset to the |+⟩ state.\n\nSee also: sMRZ, Reset, sMZ\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sMRY","page":"API","title":"QuantumClifford.sMRY","text":"Measure a qubit in the Y basis and reset to the |i₊⟩ state.\n\nSee also: sMRZ, Reset, sMZ\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sMRZ","page":"API","title":"QuantumClifford.sMRZ","text":"Measure a qubit in the Z basis and reset to the |0⟩ state.\n\nwarning: It does not trace out the qubit!\nAs described below there is a difference between measuring the qubit (followed by setting it to a given known state) and \"tracing out\" the qubit. By reset here we mean \"measuring and setting to a known state\", not \"tracing out\".\n\njulia> s = MixedDestabilizer(S\"XXX ZZI IZZ\") # |000⟩+|111⟩\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z__\n+ _X_\n+ __X\n𝒮𝓉𝒶𝒷━\n+ XXX\n+ ZZ_\n+ Z_Z\n\njulia> traceout!(copy(s), 1) # = I⊗(|00⟩⟨00| + |11⟩⟨11|)\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ _X_\n𝒳ₗ━━━\n+ _XX\n+ Z__\n𝒮𝓉𝒶𝒷━\n+ _ZZ\n𝒵ₗ━━━\n+ Z_Z\n+ XXX\n\njulia> projectZ!(traceout!(copy(s), 1), 1)[1] # = |000⟩⟨000|+|011⟩⟨011| or |100⟩⟨100|+|111⟩⟨111| (use projectZrand! to actually get a random result)\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ _X_\n+ XXX\n𝒳ₗ━━━\n+ _XX\n𝒮𝓉𝒶𝒷━\n+ _ZZ\n+ Z__\n𝒵ₗ━━━\n+ Z_Z\n\njulia> projectZ!(copy(s), 1)[1] # = |000⟩ or |111⟩ (use projectZrand! to actually get a random result)\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ XXX\n+ _X_\n+ __X\n𝒮𝓉𝒶𝒷━\n+ Z__\n+ ZZ_\n+ Z_Z\n\njulia> apply!(Register(copy(s)), sMRZ(1)) |> quantumstate # |000⟩ or |011⟩, depending on randomization\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ XXX\n+ _X_\n+ __X\n𝒮𝓉𝒶𝒷━\n+ Z__\n- ZZ_\n- Z_Z\n\nSee also: Reset, sMZ\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sMX","page":"API","title":"QuantumClifford.sMX","text":"Symbolic single qubit X measurement. See also Register, projectXrand!, sMY, sMZ\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sMY","page":"API","title":"QuantumClifford.sMY","text":"Symbolic single qubit Y measurement. See also Register, projectYrand!, sMX, sMZ\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sMZ","page":"API","title":"QuantumClifford.sMZ","text":"Symbolic single qubit Z measurement. See also Register, projectZrand!, sMX, sMY\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sPhase","page":"API","title":"QuantumClifford.sPhase","text":"A \"symbolic\" single-qubit Phase. See also: SingleQubitOperator, AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sSWAP","page":"API","title":"QuantumClifford.sSWAP","text":"A \"symbolic\" SWAP. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sX","page":"API","title":"QuantumClifford.sX","text":"A \"symbolic\" single-qubit X. See also: SingleQubitOperator, AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sXCX","page":"API","title":"QuantumClifford.sXCX","text":"A \"symbolic\" XCX. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sXCY","page":"API","title":"QuantumClifford.sXCY","text":"A \"symbolic\" XCY. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sXCZ","page":"API","title":"QuantumClifford.sXCZ","text":"A \"symbolic\" XCZ. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sY","page":"API","title":"QuantumClifford.sY","text":"A \"symbolic\" single-qubit Y. See also: SingleQubitOperator, AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sYCX","page":"API","title":"QuantumClifford.sYCX","text":"A \"symbolic\" YCX. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sYCY","page":"API","title":"QuantumClifford.sYCY","text":"A \"symbolic\" YCY. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sYCZ","page":"API","title":"QuantumClifford.sYCZ","text":"A \"symbolic\" YCZ. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sZ","page":"API","title":"QuantumClifford.sZ","text":"A \"symbolic\" single-qubit Z. See also: SingleQubitOperator, AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sZCX","page":"API","title":"QuantumClifford.sZCX","text":"A \"symbolic\" ZCX. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sZCY","page":"API","title":"QuantumClifford.sZCY","text":"A \"symbolic\" ZCY. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sZCZ","page":"API","title":"QuantumClifford.sZCZ","text":"A \"symbolic\" ZCZ. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.sZCrY","page":"API","title":"QuantumClifford.sZCrY","text":"A \"symbolic\" ZCrY. See also: AbstractSymbolicOperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.PauliError","page":"API","title":"QuantumClifford.PauliError","text":"A convenient constructor for various types of Pauli errors, that can be used as circuit gates in simulations. Returns more specific types when necessary.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.PauliError-Tuple{Any, Any}","page":"API","title":"QuantumClifford.PauliError","text":"\"Construct a gate operation that applies an unbiased Pauli error on all qubits, each with independent probability p.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.PauliError-Tuple{Int64, Any}","page":"API","title":"QuantumClifford.PauliError","text":"\"Construct a gate operation that applies an unbiased Pauli error on qubit q with probability p.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.PauliNoise","page":"API","title":"QuantumClifford.PauliNoise","text":"A convenient constructor for various types of Pauli noise models. Returns more specific types when necessary.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.PauliNoise-Tuple{Any}","page":"API","title":"QuantumClifford.PauliNoise","text":"Constructs an unbiased Pauli noise model with total probability of error p.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.affectedqubits","page":"API","title":"QuantumClifford.affectedqubits","text":"A method giving the qubits acted upon by a given operation. Part of the Noise interface.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.applybranches","page":"API","title":"QuantumClifford.applybranches","text":"Compute all possible new states after the application of the given operator. Reports the probability of each one of them. Deterministic (as it reports all branches of potentially random processes), part of the Perturbative Expansion interface.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.applynoise!","page":"API","title":"QuantumClifford.applynoise!","text":"A method modifying a given state by applying the corresponding noise model. It is non-deterministic, part of the Noise interface.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.applywstatus!-Tuple{Any, Any}","page":"API","title":"QuantumClifford.applywstatus!","text":"Used for mctrajectories.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.bell","page":"API","title":"QuantumClifford.bell","text":"Prepare one or more Bell pairs (with optional phases).\n\njulia> bell()\n+ XX\n+ ZZ\n\njulia> bell(2)\n+ XX__\n+ ZZ__\n+ __XX\n+ __ZZ\n\njulia> bell((true, false))\n- XX\n+ ZZ\n\njulia> bell([true, false, true, true])\n- XX__\n+ ZZ__\n- __XX\n- __ZZ\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.bigram-Tuple{QuantumClifford.AbstractStabilizer}","page":"API","title":"QuantumClifford.bigram","text":"bigram(\n    state::QuantumClifford.AbstractStabilizer;\n    clip\n) -> Matrix{Int64}\n\n\nGet the bigram of a tableau.\n\nIt is the list of endpoints of a tableau in the clipped gauge.\n\nIf clip=true (the default) the tableau is converted to the clipped gauge in-place before calculating the bigram. Otherwise, the clip gauge conversion is skipped (for cases where the input is already known to be in the correct gauge).\n\nIntroduced in (Nahum *et al.*, 2017), with a more detailed explanation of the algorithm in (Li *et al.*, 2019) and (Gullans *et al.*, 2020).\n\nSee also: canonicalize_clip!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.bitview","page":"API","title":"QuantumClifford.bitview","text":"A view of the classical bits stored with the state\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.canonicalize!-Tuple{QuantumClifford.AbstractStabilizer}","page":"API","title":"QuantumClifford.canonicalize!","text":"canonicalize!(\n    state::QuantumClifford.AbstractStabilizer;\n    phases,\n    ranks\n) -> Any\n\n\nCanonicalize a stabilizer (in place).\n\nAssumes the input is a valid stabilizer (all operators commute and have real phases). It permits redundant generators and identity generators.\n\njulia> ghz = S\"XXXX\n               ZZII\n               IZZI\n               IIZZ\";\n\n\njulia> canonicalize!(ghz)\n+ XXXX\n+ Z__Z\n+ _Z_Z\n+ __ZZ\n\njulia> canonicalize!(S\"XXXX\n                       IZZI\n                       IIZZ\")\n+ XXXX\n+ _Z_Z\n+ __ZZ\n\nNot all rows in the tableau in the next example are independent:\n\njulia> canonicalize!(S\"XXXX\n                       ZZII\n                       IZZI\n                       IZIZ\n                       IIZZ\")\n+ XXXX\n+ Z__Z\n+ _Z_Z\n+ __ZZ\n+ ____\n\nIn cases of lower rank, more advanced tableau structures might be better. For instance the MixedStabilizer or MixedDestabilizer structures (you can read more about them in the Data Structures section of the documentation).\n\nIf phases=false is set, the canonicalization does not track the phases in the tableau, leading to significant (constant factor) speedup.\n\njulia> s = S\"-ZX\n              XZ\"\n- ZX\n+ XZ\n\njulia> canonicalize!(copy(s), phases=false)\n- XZ\n+ ZX\n\njulia> canonicalize!(copy(s))\n+ XZ\n- ZX\n\nIf ranks=true is set, the last pivot indices for the X and Z stage of the canonicalization are returned as well.\n\njulia> s = S\"XXXX\n             ZZII\n             IZIZ\n             ZIIZ\";\n\n\njulia> _, ix, iz = canonicalize!(s, ranks=true); ix, iz\n(1, 3)\n\njulia> s\n+ XXXX\n+ Z__Z\n+ _Z_Z\n+ ____\n\nBased on (Garcia *et al.*, 2012).\n\nSee also: canonicalize_rref!, canonicalize_gott!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.canonicalize_clip!-Tuple{QuantumClifford.AbstractStabilizer}","page":"API","title":"QuantumClifford.canonicalize_clip!","text":"canonicalize_clip!(\n    state::QuantumClifford.AbstractStabilizer;\n    phases\n) -> QuantumClifford.AbstractStabilizer\n\n\nFix the clipped gauge of a stabilizer (in place).\n\nAssumes the input is a valid full-rank stabilizer (all operators commute and have real phases).\n\njulia> s = S\"- X_ZX_X\n             + XXYZ__\n             - YZ_Z_X\n             - XZX__Y\n             + _Z_Y_Y\n             - ____Z_\";\n\n\njulia> canonicalize_clip!(s)\n- X_XY__\n+ YZY___\n+ _XZX__\n- _ZYX_Z\n- __YZ_X\n- ____Z_\n\nIf phases=false is set, the canonicalization does not track the phases in the tableau, leading to a significant speedup.\n\nIntroduced in (Nahum *et al.*, 2017), with a more detailed explanation of the algorithm in Appendix A of (Li *et al.*, 2019)\n\nSee also: canonicalize!, canonicalize_rref!, canonicalize_gott!.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.canonicalize_gott!-Tuple{Stabilizer}","page":"API","title":"QuantumClifford.canonicalize_gott!","text":"Inplace Gottesman canonicalization of a tableau.\n\nThis uses different canonical form from canonicalize!. It is used in the computation of the logical X and Z operators of a MixedDestabilizer.\n\nIt returns the (in place) modified state, the indices of the last pivot of both Gaussian elimination steps, and the permutations that have been used to put the X and Z tableaux in standard form.\n\nBased on (Gottesman, 1997).\n\nSee also: canonicalize!, canonicalize_rref!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.canonicalize_rref!-Tuple{QuantumClifford.AbstractStabilizer, Any}","page":"API","title":"QuantumClifford.canonicalize_rref!","text":"canonicalize_rref!(\n    state::QuantumClifford.AbstractStabilizer,\n    colindices;\n    phases\n) -> Tuple{QuantumClifford.AbstractStabilizer, Any}\n\n\nCanonicalize a stabilizer (in place) along only some columns.\n\nThis uses different canonical form from canonicalize!. It also indexes in reverse in order to make its use in traceout! more efficient. Its use in traceout! is its main application.\n\nIt returns the (in place) modified state and the index of the last pivot.\n\nBased on (Audenaert and Plenio, 2005).\n\nSee also: canonicalize!, canonicalize_gott!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.canonicalize_rref!-Tuple{QuantumClifford.AbstractStabilizer}","page":"API","title":"QuantumClifford.canonicalize_rref!","text":"canonicalize_rref!(\n    state::QuantumClifford.AbstractStabilizer;\n    phases\n) -> Tuple{QuantumClifford.AbstractStabilizer, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.clifford_cardinality-Tuple{Int64}","page":"API","title":"QuantumClifford.clifford_cardinality","text":"The size of the Clifford group over a given number of qubits, possibly modulo the phases.\n\nFor n qubits, not accounting for phases is 2ⁿⁿΠⱼ₌₁ⁿ(4ʲ-1). There are 4ⁿ different phase configurations.\n\nSee also: enumerate_cliffords.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.comm-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:Unsigned","page":"API","title":"QuantumClifford.comm","text":"Check whether two operators commute.\n\n0x0 if they commute, 0x1 if they anticommute.\n\njulia> P\"XX\"*P\"ZZ\", P\"ZZ\"*P\"XX\"\n(- YY, - YY)\n\njulia> comm(P\"ZZ\", P\"XX\")\n0x00\n\njulia> comm(P\"IZ\", P\"XX\")\n0x01\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.compactify_circuit-Tuple{Any}","page":"API","title":"QuantumClifford.compactify_circuit","text":"Convert a list of gates to a more optimized \"sum type\" format which permits faster dispatch.\n\nGenerally, this should be called on a circuit before it is used in a simulation.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.destabilizerview-Tuple{Destabilizer}","page":"API","title":"QuantumClifford.destabilizerview","text":"A view of the subtableau corresponding to the destabilizer. See also tab, stabilizerview, logicalxview, logicalzview\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.enumerate_cliffords-Tuple{Any, Any}","page":"API","title":"QuantumClifford.enumerate_cliffords","text":"Give the i-th n-qubit Clifford operation, where i∈{1..2ⁿⁿΠⱼ₌₁ⁿ(4ʲ-1)}\n\nThe algorithm is detailed in (Koenig and Smolin, 2014).\n\nSee also: symplecticGS, clifford_cardinality.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.enumerate_cliffords-Tuple{Any}","page":"API","title":"QuantumClifford.enumerate_cliffords","text":"Give all n-qubit Clifford operations.\n\nThe algorithm is detailed in (Koenig and Smolin, 2014).\n\nSee also: symplecticGS, clifford_cardinality.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.enumerate_phases-Tuple{CliffordOperator}","page":"API","title":"QuantumClifford.enumerate_phases","text":"Given an operator, return all operators that have the same tableau but different phases.\n\njulia> length(collect(enumerate_phases(tCNOT)))\n16\n\nSee also: enumerate_cliffords, clifford_cardinality.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.enumerate_phases-Tuple{Union{Base.Generator, AbstractVector}}","page":"API","title":"QuantumClifford.enumerate_phases","text":"Given a set of operators, return all operators that have the same tableaux but different phases.\n\njulia> length(collect(enumerate_phases(enumerate_cliffords(2))))\n11520\n\nSee also: enumerate_cliffords, clifford_cardinality.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.enumerate_single_qubit_gates-Tuple{Any}","page":"API","title":"QuantumClifford.enumerate_single_qubit_gates","text":"Generate a symbolic single-qubit gate given its index. Optionally, set non-trivial phases.\n\nSee also: enumerate_cliffords.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.fastcolumn","page":"API","title":"QuantumClifford.fastcolumn","text":"Convert a tableau to a memory layout that is fast for column operations.\n\nIn this layout a column of the tableau is stored (mostly) contiguously in memory. Due to bitpacking, e.g., packing 64 bits into a single UInt64, the memory layout is not perfectly contiguous, but it is still optimal given that some bitwrangling is required to extract a given bit.\n\nSee also: fastrow\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.fastrow","page":"API","title":"QuantumClifford.fastrow","text":"Convert a tableau to a memory layout that is fast for row operations.\n\nIn this layout a Pauli string (a row of the tableau) is stored contiguously in memory.\n\nSee also: fastrow\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.generate!-Tuple{PauliOperator, Stabilizer}","page":"API","title":"QuantumClifford.generate!","text":"Generate a Pauli operator by using operators from a given the Stabilizer.\n\nIt assumes the stabilizer is already canonicalized. It modifies the Pauli operator in place, generating it in reverse, up to a phase. That phase is left in the modified operator, which should be the identity up to a phase. Returns the new operator and the list of indices denoting the elements of stabilizer that were used for the generation.\n\njulia> ghz = S\"XXXX\n               ZZII\n               IZZI\n               IIZZ\";\n\n\njulia> canonicalize!(ghz)\n+ XXXX\n+ Z__Z\n+ _Z_Z\n+ __ZZ\n\njulia> generate!(P\"-ZIZI\", ghz)\n(- ____, [2, 4])\n\nWhen the Pauli operator can not be generated by the given tableau, nothing is returned.\n\njulia> generate!(P\"XII\",canonicalize!(S\"ZII\")) === nothing\ntrue\n\njulia> generate!(P\"XII\",canonicalize!(S\"XII\")) === nothing\nfalse\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.gf2_H_to_G-Tuple{Any}","page":"API","title":"QuantumClifford.gf2_H_to_G","text":"For a given F(2,2) parity check matrix, return the generator matrix.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.gf2_gausselim!-Tuple{Any}","page":"API","title":"QuantumClifford.gf2_gausselim!","text":"Gaussian elimination over the binary field.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.gf2_invert-Tuple{Any}","page":"API","title":"QuantumClifford.gf2_invert","text":"Invert a binary matrix.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.gf2_isinvertible-Tuple{Any}","page":"API","title":"QuantumClifford.gf2_isinvertible","text":"Check whether a binary matrix is invertible.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.ghz","page":"API","title":"QuantumClifford.ghz","text":"Prepare a GHZ state of n qubits.\n\njulia> ghz()\n+ XXX\n+ ZZ_\n+ _ZZ\n\njulia> ghz(2)\n+ XX\n+ ZZ\n\njulia> ghz(4)\n+ XXXX\n+ ZZ__\n+ _ZZ_\n+ __ZZ\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.graph_gate-NTuple{4, Any}","page":"API","title":"QuantumClifford.graph_gate","text":"A helper function converting the gate indices from graphstate into a Clifford operator.\n\njulia> s = S\" XXX\n              YZ_\n             -_ZZ\";\n\n\njulia> graph, h_idx, ip_idx, z_idx = graphstate(s);\n\n\njulia> gate = graph_gate(h_idx, ip_idx, z_idx, nqubits(s));\n\n\njulia> apply!(s, gate) # This is now a graph state (notice you need to multiply row 1 by row 2)\n+ YYZ\n+ XZ_\n+ _ZX\n\njulia> canonicalize!(s) == canonicalize!(Stabilizer(graph))\ntrue\n\nSee also: graph_gatesequence\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.graph_gatesequence-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}","page":"API","title":"QuantumClifford.graph_gatesequence","text":"A helper function converting the gate indices from graphstate into a sequence of gates.\n\njulia> s = S\" XXX\n              YZ_\n             -_ZZ\";\n\n\njulia> graph, h_idx, ip_idx, z_idx = graphstate(s);\n\n\njulia> gates = graph_gatesequence(h_idx, ip_idx, z_idx);\n\n\njulia> for gate in vcat(gates...) apply!(s, gate) end\n\n\njulia> s # This is now a graph state (notice you need to multiply row 1 by row 2)\n+ YYZ\n+ XZ_\n+ _ZX\n\njulia> canonicalize!(s) == canonicalize!(Stabilizer(graph))\ntrue\n\nSee also: graph_gatesequence\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.graphstate!-Tuple{Stabilizer}","page":"API","title":"QuantumClifford.graphstate!","text":"An in-place version of graphstate.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.graphstate-Tuple{QuantumClifford.AbstractStabilizer}","page":"API","title":"QuantumClifford.graphstate","text":"Convert any stabilizer state to a graph state\n\nGraph states are a special type of entangled stabilizer states that can be represented by a graph. For a graph G=(VE) the corresponding stabilizers are S_v = X_v prod_u  N(v) Z_u. Notice that such tableau rows contain only a single X operator. There is a set of single qubit gates that converts any stabilizer state to a graph state.\n\nThis function returns the graph state corresponding to a stabilizer and the gates that might be necessary to convert the stabilizer into a state representable as a graph.\n\nFor a tableau stab you can convert it with:\n\ngraph, hadamard_idx, iphase_idx, flips_idx = graphstate()\n\nwhere graph is the graph representation of stab, and the rest specifies the single-qubit gates converting stab to graph: hadamard_idx are the qubits that require a Hadamard gate (mapping X ↔ Z), iphase_idx are (different) qubits that require an inverse Phase gate (Y → X), and flips_idx are the qubits that require a phase flip (Pauli Z gate), after the previous two sets of gates.\n\njulia> using Graphs\n\njulia> s = S\" XXX\n              ZZ_\n             -_ZZ\";\n\n\njulia> g, h_idx, ip_idx, z_idx = graphstate(s);\n\n\njulia> collect(edges(g))\n2-element Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n Edge 1 => 3\n\njulia> h_idx\n2-element Vector{Int64}:\n 2\n 3\n\njulia> ip_idx\nInt64[]\n\njulia> z_idx\n1-element Vector{Int64}:\n 3\n\nThe Graphs.jl library provides many graph-theory tools and the MakieGraphs.jl library provides plotting utilies for graphs.\n\nYou can directly call the graph constructor on a stabilizer, if you just want the graph and do not care about the Clifford operation necessary to convert an arbitrary state to a state representable as a graph:\n\njulia> collect(edges( Graph(bell()) ))\n1-element Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n\nFor a version that does not copy the stabilizer, but rather performs transformations in-place, use graphstate!. It would perform canonicalize_gott! on its argument as it finds a way to convert it to a graph state.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.logdot-Tuple{QuantumClifford.AbstractStabilizer, QuantumClifford.AbstractStabilizer}","page":"API","title":"QuantumClifford.logdot","text":"Logarithm of the inner product between to Stabilizer states.\n\nIf the result is nothing, the dot inner product is zero. Otherwise the inner product is 2^(-logdot/2).\n\nThe actual inner product can be computed with LinearAlgebra.dot.\n\nBased on (Garcia *et al.*, 2012).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.logicalxview-Tuple{MixedDestabilizer}","page":"API","title":"QuantumClifford.logicalxview","text":"A view of the subtableau corresponding to the logical X operators. See also tab, stabilizerview, destabilizerview, logicalzview\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.logicalzview-Tuple{MixedDestabilizer}","page":"API","title":"QuantumClifford.logicalzview","text":"A view of the subtableau corresponding to the logical Z operators. See also tab, stabilizerview, destabilizerview, logicalxview\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.mctrajectories-Tuple{Any, Any}","page":"API","title":"QuantumClifford.mctrajectories","text":"Run multiple Monte Carlo trajectories and report the aggregate final statuses of each.\n\nSee also: pftrajectories, petrajectories\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.mctrajectory!-Tuple{Any, Any}","page":"API","title":"QuantumClifford.mctrajectory!","text":"Run a single Monte Carlo sample, starting with (and modifying) state by applying the given circuit. Uses apply! under the hood.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.petrajectories-Tuple{Any, Any}","page":"API","title":"QuantumClifford.petrajectories","text":"Run a perturbative expansion to a given order. This is the main public fuction for the perturbative expansion approach.\n\nSee also: pftrajectories, mctrajectories\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.pfmeasurements-Tuple{PauliFrame}","page":"API","title":"QuantumClifford.pfmeasurements","text":"pfmeasurements(frame::PauliFrame) -> Any\n\n\nReturns the measurement results for each frame in the PauliFrame instance.\n\nwarning: Relative mesurements\nThe return measurements are relative to the reference measurements, i.e. they only say whether the reference measurements have been flipped in the given frame.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.pfmeasurements-Tuple{Register, PauliFrame}","page":"API","title":"QuantumClifford.pfmeasurements","text":"pfmeasurements(register::Register, frame::PauliFrame) -> Any\n\n\nTakes the references measurements from the given Register and applies the flips as prescribed by the PauliFrame relative measurements. The result is the actual (non-relative) measurement results for each frame.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.pfmeasurements-Tuple{Register}","page":"API","title":"QuantumClifford.pfmeasurements","text":"pfmeasurements(register::Register) -> Vector{Bool}\n\n\nReturns the measurements stored in the bits of the given Register.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.pftrajectories","page":"API","title":"QuantumClifford.pftrajectories","text":"Perform a \"Pauli frame\" style simulation of a quantum circuit.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.pftrajectories-Tuple{Any}","page":"API","title":"QuantumClifford.pftrajectories","text":"pftrajectories(\n    circuit;\n    trajectories,\n    threads\n) -> PauliFrame{Stabilizer{QuantumClifford.Tableau{Vector{UInt8}, LinearAlgebra.Adjoint{UInt64, Matrix{UInt64}}}}, Matrix{Bool}}\n\n\nThe main method for running Pauli frame simulations of circuits. See the other methods for lower level access.\n\nMultithreading is enabled by default, but can be disabled by setting threads=false. Do not forget to launch Julia with multiple threads enabled, e.g. julia -t4, if you want to use multithreading.\n\nSee also: mctrajectories, petrajectories\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.pftrajectories-Tuple{PauliFrame, Any}","page":"API","title":"QuantumClifford.pftrajectories","text":"pftrajectories(state::PauliFrame, circuit) -> PauliFrame\n\n\nEvolve each frame stored in PauliFrame by the given circuit.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.pftrajectories-Tuple{Register, Any}","page":"API","title":"QuantumClifford.pftrajectories","text":"pftrajectories(\n    register::Register,\n    circuit;\n    trajectories\n) -> Tuple{Register, PauliFrame{Stabilizer{QuantumClifford.Tableau{Vector{UInt8}, LinearAlgebra.Adjoint{UInt64, Matrix{UInt64}}}}, Matrix{Bool}}}\n\n\nFor a given Register and circuit, simulates the reference circuit acting on the register and then also simulate numerous PauliFrame trajectories. Returns the register and the PauliFrame instance.\n\nUse pfmeasurements to get the measurement results.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.phases-Tuple{QuantumClifford.Tableau}","page":"API","title":"QuantumClifford.phases","text":"The phases of a given tableau. It is a view, i.e. if you modify this array, the original tableau caries these changes.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.prodphase-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:Unsigned","page":"API","title":"QuantumClifford.prodphase","text":"Get the phase of the product of two Pauli operators.\n\nPhase is encoded as F(4) in the low qubits of an UInt8.\n\njulia> P\"ZZZ\"*P\"XXX\"\n-iYYY\n\njulia> prodphase(P\"ZZZ\", P\"XXX\")\n0x03\n\njulia> prodphase(P\"XXX\", P\"ZZZ\")\n0x01\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.projectXrand!-Tuple{Any, Any}","page":"API","title":"QuantumClifford.projectXrand!","text":"projectXrand!(state, qubit) -> Tuple{Register, UInt8}\n\n\nProject qubit of state along the X axis and randomize the phase if necessary.\n\nLower boilerplate version of project!.\n\nSee also: project!, projectX!, projectZrand!, projectYrand!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.projectYrand!-Tuple{Any, Any}","page":"API","title":"QuantumClifford.projectYrand!","text":"projectYrand!(state, qubit) -> Tuple{Register, UInt8}\n\n\nProject qubit of state along the Y axis and randomize the phase if necessary.\n\nLower boilerplate version of project!.\n\nSee also: project!, projectY!, projectXrand!, projectZrand!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.projectZrand!-Tuple{Any, Any}","page":"API","title":"QuantumClifford.projectZrand!","text":"projectZrand!(state, qubit) -> Tuple{Register, UInt8}\n\n\nProject qubit of state along the Z axis and randomize the phase if necessary.\n\nLower boilerplate version of project!.\n\nSee also: project!, projectZ!, projectXrand!, projectYrand!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.projectrand!-Tuple{Any, Any}","page":"API","title":"QuantumClifford.projectrand!","text":"projectrand!(\n    state,\n    pauli\n) -> Tuple{QuantumClifford.AbstractStabilizer, UInt8}\n\n\nMeasure pauli operator on state and randomize the phase if necessary.\n\nLower boilerplate version of project!.\n\nSee also: project!, projectXrand!, projectZrand!, projectYrand!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.puttableau!-Union{Tuple{M2}, Tuple{M1}, Tuple{T}, Tuple{V2}, Tuple{V1}, Tuple{B}, Tuple{QuantumClifford.Tableau{V1, M1}, QuantumClifford.Tableau{V2, M2}, Int64, Int64}} where {B, V1, V2, T<:Unsigned, M1<:AbstractMatrix{T}, M2<:AbstractMatrix{T}}","page":"API","title":"QuantumClifford.puttableau!","text":"Put source tableau in target tableau at given row and column. Assumes target location is zeroed out.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.quantumstate","page":"API","title":"QuantumClifford.quantumstate","text":"Only the quantum part of the state (excluding classical bits)\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.random_clifford-Tuple{Random.AbstractRNG, Int64}","page":"API","title":"QuantumClifford.random_clifford","text":"A random Clifford operator generated by the Bravyi-Maslov Algorithm 2 from (Bravyi and Maslov, 2021).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.random_clifford1-Tuple{Random.AbstractRNG, Any}","page":"API","title":"QuantumClifford.random_clifford1","text":"Random symbolic single-qubit Clifford applied to qubit at index qubit.\n\nSee also: SingleQubitOperator, random_clifford\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.random_destabilizer-Tuple{Random.AbstractRNG, Int64}","page":"API","title":"QuantumClifford.random_destabilizer","text":"A random Stabilizer/Destabilizer tableau generated by the Bravyi-Maslov Algorithm 2 from (Bravyi and Maslov, 2021).\n\nrandom_destabilizer(n) gives a n-qubit tableau of rank n. random_destabilizer(r,n) gives a n-qubit tableau of rank r.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.random_pauli-Tuple{Random.AbstractRNG, Int64}","page":"API","title":"QuantumClifford.random_pauli","text":"A random Pauli operator on n qubits.\n\nUse realphase=true to get operators with phase ±1 (excluding ±i). nophase=true sets the phase to +1.\n\nOptionally, a \"flip\" probability p can be provided specified, in which case each bit is set to I with probability 1-p and to X, Y, or Z, each with probability p. Useful for simulating Pauli noise.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.random_stabilizer-Tuple{Random.AbstractRNG, Int64}","page":"API","title":"QuantumClifford.random_stabilizer","text":"A random Stabilizer tableau generated by the Bravyi-Maslov Algorithm 2 from (Bravyi and Maslov, 2021).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.single_x-Tuple{Any, Any}","page":"API","title":"QuantumClifford.single_x","text":"A multiqubit operator corresponding to all identities except for Pauli X at i. See also: sX, sMX\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.single_y-Tuple{Any, Any}","page":"API","title":"QuantumClifford.single_y","text":"A multiqubit operator corresponding to all identities except for Pauli Y at i. See also: sY, sMY\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.single_z-Tuple{Any, Any}","page":"API","title":"QuantumClifford.single_z","text":"A multiqubit operator corresponding to all identities except for Pauli Z at i. See also: sY, sMY\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.stab_to_gf2-Tuple{QuantumClifford.Tableau}","page":"API","title":"QuantumClifford.stab_to_gf2","text":"The F(2,2) matrix of a given tableau, represented as the concatenation of two binary matrices, one for X and one for Z.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.stabilizerplot","page":"API","title":"QuantumClifford.stabilizerplot","text":"A Makie.jl recipe for pictorial representation of a tableau.\n\nRequires a Makie.jl backend to be loaded, e.g. using CairoMakie.\n\nAlternatively, you can use the Plots.jl plotting ecosystem, e.g. using Plots; plot(S\"XXX ZZZ\").\n\nConsult the documentation for more details on visualization options.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.stabilizerplot_axis","page":"API","title":"QuantumClifford.stabilizerplot_axis","text":"A Makie.jl recipe for pictorial representation of a tableau.\n\nRequires a Makie.jl backend to be loaded, e.g. using CairoMakie.\n\nAlternatively, you can use the Plots.jl plotting ecosystem, e.g. using Plots; plot(S\"XXX ZZZ\").\n\nConsult the documentation for more details on visualization options.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.stabilizerview-Tuple{Stabilizer}","page":"API","title":"QuantumClifford.stabilizerview","text":"A view of the subtableau corresponding to the stabilizer. See also tab, destabilizerview, logicalxview, logicalzview\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.symplecticGS-Tuple{PauliOperator}","page":"API","title":"QuantumClifford.symplecticGS","text":"Perform the Symplectic Gram-Schmidt procedure that gives a Clifford operator canonically related to a given Pauli operator.\n\nThe algorithm is detailed in (Koenig and Smolin, 2014).\n\nSee also: enumerate_cliffords, clifford_cardinality.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.tab-Union{Tuple{Stabilizer{T}}, Tuple{T}} where T","page":"API","title":"QuantumClifford.tab","text":"Extract the underlying tableau structure.\n\njulia> s = S\"X\"\n+ X\n\njulia> tab(s)\n+ X\n\njulia> tab(Destabilizer(s))\n+ Z\n+ X\n\njulia> tab(MixedDestabilizer(s))\n+ Z\n+ X\n\njulia> tab(tHadamard)\n+ Z\n+ X\n\njulia> typeof(tab(tHadamard))\nQuantumClifford.Tableau{Vector{UInt8}, Matrix{UInt64}}\n\nSee also: stabilizerview, destabilizerview, logicalxview, logicalzview\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.xbit-Tuple{PauliOperator}","page":"API","title":"QuantumClifford.xbit","text":"Extract as a new bit array the X part of the UInt array of packed qubits of a given Pauli operator.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.xview-Tuple{PauliOperator}","page":"API","title":"QuantumClifford.xview","text":"Get a view of the X part of the UInt array of packed qubits of a given Pauli operator.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.zbit-Tuple{PauliOperator}","page":"API","title":"QuantumClifford.zbit","text":"Extract as a new bit array the Z part of the UInt array of packed qubits of a given Pauli operator.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.zview-Tuple{PauliOperator}","page":"API","title":"QuantumClifford.zview","text":"Get a view of the Y part of the UInt array of packed qubits of a given Pauli operator.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.apply!","page":"API","title":"QuantumInterface.apply!","text":"In QuantumClifford the apply! function is used to apply any quantum operation to a stabilizer state, including unitary Clifford operations, Pauli measurements, and noise. Thus, this function may result in a random/stochastic result (e.g. with measurements or noise).\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumInterface.embed-Tuple{Int64, Int64, PauliOperator}","page":"API","title":"QuantumInterface.embed","text":"Embed a Pauli operator in a larger Pauli operator.\n\njulia> embed(5, 3, P\"-Y\")\n- __Y__\n\njulia> embed(5, (3,5), P\"-YX\")\n- __Y_X\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.entanglement_entropy","page":"API","title":"QuantumInterface.entanglement_entropy","text":"Get bipartite entanglement entropy of a subsystem\n\nDefined as entropy of the reduced density matrix.\n\nIt can be calculated with multiple different algorithms, the most performant one depending on the particular case.\n\nCurrently implemented are the :clip (clipped gauge), :graph (graph state), and :rref (Gaussian elimination) algorithms. Benchmark your particular case to choose the best one.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumInterface.entanglement_entropy-Tuple{QuantumClifford.AbstractStabilizer, AbstractVector, Val{:graph}}","page":"API","title":"QuantumInterface.entanglement_entropy","text":"Get bipartite entanglement entropy by first converting the state to a graph and computing the rank of the adjacency matrix.\n\nBased on \"Entanglement in graph states and its applications\".\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.entanglement_entropy-Tuple{QuantumClifford.AbstractStabilizer, AbstractVector, Val{:rref}}","page":"API","title":"QuantumInterface.entanglement_entropy","text":"Get bipartite entanglement entropy by converting to RREF form (i.e., partial trace form).\n\nThe state will be partially canonicalized in an RREF form.\n\nSee also: canonicalize_rref!, traceout!.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.entanglement_entropy-Tuple{QuantumClifford.AbstractStabilizer, UnitRange, Val{:clip}}","page":"API","title":"QuantumInterface.entanglement_entropy","text":"Get bipartite entanglement entropy of a contiguous subsystem by passing through the clipped gauge.\n\nIf clip=false is set the canonicalization step is skipped, useful if the input state is already in the clipped gauge.\n\nSee also: bigram, canonicalize_clip!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.expect-Tuple{PauliOperator, QuantumClifford.AbstractStabilizer}","page":"API","title":"QuantumInterface.expect","text":"expect(p::PauliOperator, st::AbstractStabilizer)\n\nCompute the expectation value of a Pauli operator p on a stabilizer state st. This function will allocate a temporary copy of the stabilizer state st.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.nqubits-Tuple{QuantumClifford.AbstractStabilizer}","page":"API","title":"QuantumInterface.nqubits","text":"The number of qubits of a given state.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.project!-Tuple{Any, PauliOperator}","page":"API","title":"QuantumInterface.project!","text":"project!(\n    state,\n    pauli::PauliOperator;\n    keep_result,\n    phases\n) -> Tuple{MixedStabilizer, Any, Any}\n\n\nProject the state of a Stabilizer on the two eigenspaces of a Pauli operator.\n\nAssumes the input is a valid stabilizer. The projection is done inplace on that stabilizer and it does not modify the projection operator.\n\nIt returns\n\na stabilizer that might not be in canonical form\nthe index of the row where the non-commuting operator was (that row is now equal to pauli; its phase is not updated and for a faithful measurement simulation it needs to be randomized by the user)\nand the result of the projection if there was no non-commuting operator (nothing otherwise)\n\nIf keep_result==false that result of the projection in case of anticommutation is not computed, sparing a canonicalization operation. This canonicalization operation is the only one potentially of cubic complexity. The rest of the calculations are of quadratic complexity.\n\nIf you need to measure a single qubit instead of a multiqubit Pauli operator, the faster projectX!, projectY!, and projectZ! are available.\n\nFor less boilerplate and automatic randomization of the phase use projectrand!.\n\nHere is an example of a projection destroying entanglement:\n\njulia> ghz = S\"XXXX\n               ZZII\n               IZZI\n               IIZZ\";\n\n\njulia> canonicalize!(ghz)\n+ XXXX\n+ Z__Z\n+ _Z_Z\n+ __ZZ\n\njulia> state, anticom_index, result = project!(ghz, P\"ZIII\");\n\n\njulia> state\n+ Z___\n+ Z__Z\n+ _Z_Z\n+ __ZZ\n\njulia> canonicalize!(state)\n+ Z___\n+ _Z__\n+ __Z_\n+ ___Z\n\njulia> anticom_index, result\n(1, nothing)\n\nAnd an example of projection consistent with the stabilizer state.\n\njulia> s = S\"ZII\n             IXI\n             IIY\";\n\n\njulia> canonicalize!(s)\n+ _X_\n+ __Y\n+ Z__\n\njulia> state, anticom_index, result = project!(s, P\"-ZII\");\n\n\njulia> state\n+ _X_\n+ __Y\n+ Z__\n\njulia> anticom_index, result\n(0, 0x02)\n\nWhile not the best choice, Stabilizer can be used for mixed states, simply by providing an incomplete tableau. In that case it is possible to attempt to project on an operator that can not be generated by the provided stabilizer operators. In that case we have anticom_index==rank and result===nothing, where rank is the the new rank of the tableau, one more than the number of rows in the initial tableau. However, if keep_result was set to false, then anticom_index would stay at zero.\n\njulia> s = S\"XZI\n             IZI\";\n\n\njulia> project!(s, P\"IIX\")[1]\n+ X__\n+ _Z_\n\nIf we had used MixedStabilizer we would have added the projector to the list of stabilizers.\n\njulia> s = one(MixedStabilizer, 2, 3)\n+ Z__\n+ _Z_\n\njulia> project!(s, P\"IIX\")[1]\n+ Z__\n+ _Z_\n+ __X\n\nHowever, MixedDestabilizer would be an even better choice as it has mathcalO(n^2) complexity instead of the mathcalO(n^3) complexity of *Stabilizer.\n\njulia> s = one(MixedDestabilizer, 2, 3)\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ X__\n+ _X_\n𝒳ₗ━━━\n+ __X\n𝒮𝓉𝒶𝒷━\n+ Z__\n+ _Z_\n𝒵ₗ━━━\n+ __Z\n\njulia> project!(s, P\"IIX\")[1]\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ X__\n+ _X_\n+ __Z\n𝒮𝓉𝒶𝒷━\n+ Z__\n+ _Z_\n+ __X\n\nSee the \"Datastructure Choice\" section in the documentation for more details.\n\nSee also: projectX!, projectY!, projectZ!, projectrand!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.project!-Tuple{MixedStabilizer, PauliOperator}","page":"API","title":"QuantumInterface.project!","text":"project!(\n    state::MixedStabilizer,\n    pauli::PauliOperator;\n    phases\n) -> Tuple{MixedStabilizer, Any, Any}\n\n\nWhen using project! on MixedStabilizer it automates some of the extra steps we encounter when implicitly using the Stabilizer datastructure to represent mixed states. Namely, it helps when the projector is not among the list of stabilizers:\n\njulia> s = S\"XZI\n             IZI\";\n\n\njulia> ms = MixedStabilizer(s)\n+ X__\n+ _Z_\n\njulia> project!(ms, P\"IIY\")[1]\n+ X__\n+ _Z_\n+ __Y\n\nSimilarly to project! on Stabilizer, this function has cubic complexity when the Pauli operator commutes with all rows of the tableau. Most of the time it is better to simply use MixedDestabilizer representation.\n\nUnlike other project! methods, this one does not allow for keep_result=false, as the correct rank or anticommutation index can not be calculated without the expensive (cubic) canonicalization operation required by keep_result=true.\n\nSee the \"Datastructure Choice\" section in the documentation for more details.\n\nSee also: projectX!, projectY!, projectZ!.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.projectX!-Tuple{MixedDestabilizer, Int64}","page":"API","title":"QuantumInterface.projectX!","text":"Measure a given qubit in the X basis. A faster special-case version of project!.\n\nSee also: project!, projectXrand!, projectY!, projectZ!.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.projectY!-Tuple{MixedDestabilizer, Int64}","page":"API","title":"QuantumInterface.projectY!","text":"Measure a given qubit in the Y basis. A faster special-case version of project!.\n\nSee also: project!, projectYrand!, projectX!, projectZ!.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.projectZ!-Tuple{MixedDestabilizer, Int64}","page":"API","title":"QuantumInterface.projectZ!","text":"Measure a given qubit in the Z basis. A faster special-case version of project!.\n\nSee also: project!, projectZrand!, projectY!, projectX!.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.reset_qubits!-Tuple{MixedDestabilizer, QuantumClifford.AbstractStabilizer, Any}","page":"API","title":"QuantumInterface.reset_qubits!","text":"reset_qubits!(\n    s::MixedDestabilizer,\n    newstate::QuantumClifford.AbstractStabilizer,\n    qubits;\n    phases\n) -> MixedDestabilizer\n\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.reset_qubits!-Tuple{MixedStabilizer, Any, Any}","page":"API","title":"QuantumInterface.reset_qubits!","text":"reset_qubits!(\n    s::MixedStabilizer,\n    newstate,\n    qubits;\n    phases\n) -> MixedStabilizer\n\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.reset_qubits!-Tuple{Stabilizer, Any, Any}","page":"API","title":"QuantumInterface.reset_qubits!","text":"reset_qubits!(\n    s::Stabilizer,\n    newstate,\n    qubits;\n    phases\n) -> Any\n\n\nReset a given set of qubits to be in the state newstate. These qubits are traced out first, which could lead to \"nonlocal\" changes in the tableau.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.tensor","page":"API","title":"QuantumInterface.tensor","text":"Tensor product between operators or tableaux. See also tensor_pow.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumInterface.tensor_pow-Tuple{Union{QuantumClifford.AbstractCliffordOperator, QuantumClifford.AbstractStabilizer}, Any}","page":"API","title":"QuantumInterface.tensor_pow","text":"Repeated tensor product of an operators or a tableau. See also tensor.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.traceout!-Tuple{Stabilizer, Any}","page":"API","title":"QuantumInterface.traceout!","text":"traceout!(s::Stabilizer, qubits; phases, rank) -> Any\n\n\nTrace out a qubit.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.traceout!-Tuple{Union{MixedDestabilizer, MixedStabilizer}, Any}","page":"API","title":"QuantumInterface.traceout!","text":"traceout!(\n    s::Union{MixedDestabilizer, MixedStabilizer},\n    qubits;\n    phases,\n    rank\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#Private-API","page":"API","title":"Private API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"danger: Private Implementation Details\nThese functions are used internally by the library and might be drastically modified or deleted without warning or deprecation.","category":"page"},{"location":"API/","page":"API","title":"API","text":"Modules = [QuantumClifford]\nPrivate = true\nPublic = false","category":"page"},{"location":"API/#QuantumClifford.AbstractMeasurement","page":"API","title":"QuantumClifford.AbstractMeasurement","text":"Supertype of all symbolic single-qubit measurements.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.Tableau","page":"API","title":"QuantumClifford.Tableau","text":"Internal Tableau type for storing a list of Pauli operators in a compact form. No special semantic meaning is attached to this type, it is just a convenient way to store a list of Pauli operators. E.g. it is not used to represent a stabilizer state, or a stabilizer group, or a Clifford circuit.\n\n\n\n\n\n","category":"type"},{"location":"API/#Base.inv-Tuple{CliffordOperator}","page":"API","title":"Base.inv","text":"inv(\n    c::CliffordOperator;\n    phases\n) -> CliffordOperator{QuantumClifford.Tableau{Vector{UInt8}, Matrix{UInt64}}}\n\n\nInverse of a CliffordOperator\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.permute!-Tuple{QuantumClifford.AbstractStabilizer, AbstractVector}","page":"API","title":"Base.permute!","text":"Permute the qubits (i.e., columns) of the state in place.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.permute!-Tuple{QuantumClifford.Tableau, AbstractVector}","page":"API","title":"Base.permute!","text":"Permute the qubits (i.e., columns) of the tableau in place.\n\n\n\n\n\n","category":"method"},{"location":"API/#LinearAlgebra.dot-Tuple{QuantumClifford.AbstractStabilizer, QuantumClifford.AbstractStabilizer}","page":"API","title":"LinearAlgebra.dot","text":"The inner product of two Stabilizers.\n\nBased on (Garcia *et al.*, 2012).\n\nSee also: logdot\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford._apply_nonthread!-Tuple{QuantumClifford.AbstractStabilizer, CliffordOperator, AbstractVector{Int64}}","page":"API","title":"QuantumClifford._apply_nonthread!","text":"Nonvectorized version of apply! used for unit tests.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford._apply_nonthread!-Tuple{QuantumClifford.AbstractStabilizer, CliffordOperator}","page":"API","title":"QuantumClifford._apply_nonthread!","text":"Nonvectorized version of apply! used for unit tests.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford._mul_left_nonvec!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:Unsigned","page":"API","title":"QuantumClifford._mul_left_nonvec!","text":"Nonvectorized version of mul_left! used for unit tests.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford._remove_rowcol!-Tuple{MixedDestabilizer, Any, Any}","page":"API","title":"QuantumClifford._remove_rowcol!","text":"Unexported low-level function that removes a row (by shifting all rows up as necessary)\n\nBecause MixedDestabilizer is not mutable we return a new MixedDestabilizer with the same (modified) xzs array.\n\nUsed on its own, this function will break invariants. Meant to be used with projectremove!.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford._rowmove!-Union{Tuple{B}, Tuple{QuantumClifford.Tableau, Any, Any}} where B","page":"API","title":"QuantumClifford._rowmove!","text":"Unexported low-level function that moves row i to row j.\n\nUsed on its own, this function will break invariants. Meant to be used in _remove_rowcol!.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford._stim_prodphase-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:Unsigned","page":"API","title":"QuantumClifford._stim_prodphase","text":"The quantumlib/Stim implementation, which performs the prodphase and mul_left! together. Used for unit tests.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.apply_single_x!-Tuple{QuantumClifford.AbstractStabilizer, Any}","page":"API","title":"QuantumClifford.apply_single_x!","text":"Apply a Pauli X to the i-th qubit of state s. You should use apply!(stab,sX(i)) instead of this.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.apply_single_y!-Tuple{QuantumClifford.AbstractStabilizer, Any}","page":"API","title":"QuantumClifford.apply_single_y!","text":"Apply a Pauli Y to the i-th qubit of state s. You should use apply!(stab,sY(i)) instead of this.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.apply_single_z!-Tuple{QuantumClifford.AbstractStabilizer, Any}","page":"API","title":"QuantumClifford.apply_single_z!","text":"Apply a Pauli Z to the i-th qubit of state s. You should use apply!(stab,sZ(i)) instead of this.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.applynoise_branches","page":"API","title":"QuantumClifford.applynoise_branches","text":"Compute all possible new states after the application of the given noise model. Reports the probability of each one of them. Deterministic (as it reports all branches of potentially random processes), part of the Noise interface.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.colswap!-Tuple{QuantumClifford.Tableau, Any, Any}","page":"API","title":"QuantumClifford.colswap!","text":"Swap two columns of a stabilizer in place.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.destab_looks_good-Tuple{Any}","page":"API","title":"QuantumClifford.destab_looks_good","text":"Check basic consistency requirements of a destabilizer. Used in tests.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.enumerate_cliffords_slow-Tuple{Any, Any}","page":"API","title":"QuantumClifford.enumerate_cliffords_slow","text":"The O(n^4) implementation from (Koenig and Smolin, 2014) – their algorithm seems wrong as ⟨w'₁|wₗ⟩=bₗ which is not always zero.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.fill_tril-Tuple{Any, Any, Any}","page":"API","title":"QuantumClifford.fill_tril","text":"Assign (symmetric) random ints to off diagonals of matrix.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.gf2_H_standard_form_indices-Tuple{Any}","page":"API","title":"QuantumClifford.gf2_H_standard_form_indices","text":"The permutation of columns which turns a binary matrix into standard form. It is assumed the matrix has already undergone Gaussian elimination.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.initZ!-Tuple{PauliFrame}","page":"API","title":"QuantumClifford.initZ!","text":"initZ!(frame::PauliFrame) -> PauliFrame\n\n\nInject random Z errors over all frames and qubits for the supplied PauliFrame with probability 0.5.\n\nCalling this after initialization is essential for simulating any non-deterministic circuit. It is done automatically by most PauliFrame constructors.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.make_sumtype-Tuple{Any}","page":"API","title":"QuantumClifford.make_sumtype","text":"julia> make_sumtype([sCNOT])\nquote\n    @sum_type CompactifiedGate :hidden begin\n        sCNOT(::Int64, ::Int64)\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.make_sumtype_method","page":"API","title":"QuantumClifford.make_sumtype_method","text":"``` julia> makesumtypemethod([sCNOT], :apply!, (:s,)) quote     function QuantumClifford.apply!(s, g::CompactifiedGate)         @cases g begin             sCNOT(q1, q2) => apply!(s, sCNOT(q1, q2))         end     end end\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.make_sumtype_variant_constructor-Tuple{Any}","page":"API","title":"QuantumClifford.make_sumtype_variant_constructor","text":"julia> make_sumtype_variant_constructor(sCNOT)\n:(CompactifiedGate(g::sCNOT) = begin\n    (CompactifiedGate').sCNOT(g.q1, g.q2)\nend)\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.make_variant-Tuple{DataType}","page":"API","title":"QuantumClifford.make_variant","text":"julia> make_variant(sCNOT)\n:(sCNOT(::Int64, ::Int64))\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.make_variant_deconstruct","page":"API","title":"QuantumClifford.make_variant_deconstruct","text":"julia> make_variant_deconstruct(sCNOT, :apply!, (:s,))\n:(sCNOT(q1, q2) => apply!(s, sCNOT(q1, q2)))\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.mixed_destab_looks_good-Tuple{Any}","page":"API","title":"QuantumClifford.mixed_destab_looks_good","text":"Check basic consistency requirements of a mixed destabilizer. Used in tests.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.mixed_stab_looks_good-Tuple{Any}","page":"API","title":"QuantumClifford.mixed_stab_looks_good","text":"Check basic consistency requirements of a mixed stabilizer. Used in tests.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.pfmeasurement","page":"API","title":"QuantumClifford.pfmeasurement","text":"For a given simulated state, e.g. a PauliFrame instance, returns the measurement results.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.precise_inv-Tuple{Any}","page":"API","title":"QuantumClifford.precise_inv","text":"Inverting a binary matrix: uses floating point for small matrices and Nemo for large matrices.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.project_cond!-Union{Tuple{PHASES}, Tuple{RESET}, Tuple{IS}, Tuple{MixedDestabilizer, Int64, Val{IS}, Val{RESET}}} where {IS, RESET, PHASES}","page":"API","title":"QuantumClifford.project_cond!","text":"Internal method used to implement projectX!, projectZ!, and projectY!.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.projectremoverand!-Union{Tuple{F}, Tuple{MixedDestabilizer, F, Any}} where F<:Union{typeof(projectX!), typeof(projectY!), typeof(projectZ!)}","page":"API","title":"QuantumClifford.projectremoverand!","text":"Unexported low-level function that projects a qubit and returns the result while making the tableau smaller by a qubit.\n\nBecause MixedDestabilizer is not mutable we return a new MixedDestabilizer with the same (modified) xzs array.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.quantum_mallows-Tuple{Any, Any}","page":"API","title":"QuantumClifford.quantum_mallows","text":"Sample (h, S) from the distribution P_n(h, S) from Bravyi and Maslov Algorithm 1.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.remove_column!-Union{Tuple{M}, Tuple{T}, Tuple{V}, Tuple{QuantumClifford.Tableau{V, M}, Int64}} where {V, T<:Unsigned, M<:AbstractMatrix{T}}","page":"API","title":"QuantumClifford.remove_column!","text":"Unexported low-level function that removes a column (by shifting all columns to the right of the target by one step to the left)\n\nBecause Tableau is not mutable we return a new Tableau with the same (modified) xzs array.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.rowdecompose-Tuple{Any, Union{Destabilizer, MixedDestabilizer}}","page":"API","title":"QuantumClifford.rowdecompose","text":"Decompose a Pauli P in terms of stabilizer and destabilizer rows from a given tableaux.\n\nFor given tableaux of rows destabilizer rows d_i and stabilizer rows s_i, there are boolean vectors b and c such that P = i^p prod_i d_i^b_i prod_i s_i^c_i.\n\nThis function returns p, b, c.\n\njulia> s = MixedDestabilizer(ghz(2))\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z_\n+ _X\n𝒮𝓉𝒶𝒷\n+ XX\n+ ZZ\n\njulia> phase, destab_rows, stab_rows = QuantumClifford.rowdecompose(P\"XY\", s)\n(3, Bool[1, 0], Bool[1, 1])\n\njulia> im^3 * P\"Z_\" * P\"XX\" * P\"ZZ\"\n+ XY\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.sample_geometric_2-Tuple{Any, Integer}","page":"API","title":"QuantumClifford.sample_geometric_2","text":"This function samples a number from 1 to n where n >= 1 probability of outputting i is proportional to 2^i\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.stab_looks_good-Tuple{Any}","page":"API","title":"QuantumClifford.stab_looks_good","text":"Check basic consistency requirements of a stabilizer. Used in tests.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.to_cpu","page":"API","title":"QuantumClifford.to_cpu","text":"copies the memory content of the object to CPU\n\nYou can only use this function if CUDA.jl is imported\n\nFor more advanced users to_cpu(data, element_type) will reinterpret elements of data and converts them to element_type. For example based on your CPU architecture, if working with matrices of UInt32 is faster than UInt64, you can use to_cpu(data, UInt32)\n\njulia> using QuantumClifford: to_cpu, to_gpu\n\njulia> using CUDA # without this import, to_cpu, to_gpu are just function\n\njulia> stab = S\"- X_Z\\n+ _ZZ\\n+ __Z\"\n- X_Z\n+ _ZZ\n+ __Z\n\njulia> stab_gpu = to_gpu(stab);\n\njulia> apply!(stab_gpu, sHadamard(1));\n\njulia> stab_result_cpu = to_cpu(stab_gpu)\n- Z_Z\n+ _ZZ\n+ __Z\n\njulia> using QuantumClifford: to_cpu, to_gpu\n\njulia> using CUDA # without this import, to_cpu, to_gpu are just function\n\njulia> pf_gpu = to_gpu(PauliFrame(1000, 2, 2));\njulia> circuit = [sMZ(1, 1), sHadamard(2), sMZ(2, 2)];\njulia> pftrajectories(pf_gpu, circuit);\njulia> measurements = to_cpu(pf_gpu.measurements);\n\nSee also: to_gpu\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.to_gpu","page":"API","title":"QuantumClifford.to_gpu","text":"copies the memory content of the object to GPU\n\nYou can only use this function if CUDA.jl is imported\n\nFor more advanced users to_gpu(data, element_type) will reinterpret elements of data and converts them to element_type. For example based on your GPU architecture, if working with matrices of UInt64 is faster than UInt32, you can use to_gpu(data, UInt64)\n\njulia> using QuantumClifford: to_cpu, to_gpu\n\njulia> using CUDA # without this import, to_cpu, to_gpu are just function\n\njulia> stab = S\"- X_Z\\n+ _ZZ\\n+ __Z\"\n- X_Z\n+ _ZZ\n+ __Z\n\njulia> stab_gpu = to_gpu(stab);\n\njulia> apply!(stab_gpu, sHadamard(1));\n\njulia> stab_result_cpu = to_cpu(stab_gpu)\n- Z_Z\n+ _ZZ\n+ __Z\n\njulia> using QuantumClifford: to_cpu, to_gpu\n\njulia> using CUDA # without this import, to_cpu, to_gpu are just function\n\njulia> pf_gpu = to_gpu(PauliFrame(1000, 2, 2));\njulia> circuit = [sMZ(1, 1), sHadamard(2), sMZ(2, 2)];\njulia> pftrajectories(pf_gpu, circuit);\njulia> measurements = to_cpu(pf_gpu.measurements);\n\nSee also: to_cpu\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.trusted_rank","page":"API","title":"QuantumClifford.trusted_rank","text":"A \"trusted\" rank which returns rank(state) for Mixed[De]Stabilizer and lenght(state) for [De]Stabilizer.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumClifford.zero!-Tuple{QuantumClifford.Tableau, Any}","page":"API","title":"QuantumClifford.zero!","text":"Zero-out a given row of a Tableau\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.zero!-Union{Tuple{PauliOperator{Tz, Tv}}, Tuple{Tv}, Tuple{Tve}, Tuple{Tz}} where {Tz, Tve<:Unsigned, Tv<:AbstractVector{Tve}}","page":"API","title":"QuantumClifford.zero!","text":"Zero-out the phases and single-qubit operators in a PauliOperator\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.@qubitop1-Tuple{Any, Any}","page":"API","title":"QuantumClifford.@qubitop1","text":"Macro used to define single qubit symbolic gates and their qubit_kernel methods.\n\n\n\n\n\n","category":"macro"},{"location":"API/#QuantumClifford.@qubitop2-Tuple{Any, Any}","page":"API","title":"QuantumClifford.@qubitop2","text":"Macro used to define 2-qubit symbolic gates and their qubit_kernel methods.\n\n\n\n\n\n","category":"macro"},{"location":"API/#QuantumClifford.@valbooldispatch-Tuple{Any, Vararg{Any}}","page":"API","title":"QuantumClifford.@valbooldispatch","text":"Turns f(Val(x)) into x ? f(Val(true)) : f(Val(false)) in order to avoid dynamic dispatch\n\nSee discourse discussion\n\n\n\n\n\n","category":"macro"},{"location":"mixed/#Mixed-Stabilizer-States","page":"Mixed States","title":"Mixed Stabilizer States","text":"","category":"section"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"DocTestSetup = quote\n    using QuantumClifford\nend","category":"page"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"The Stabilizer and Destabilizer have some support for mixed states (by being initialized with an incomplete list of stabilizer generators), but for most purposes one would use the Mixed* data structures.","category":"page"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"Mixed stabilizer states are implemented with MixedStabilizer and MixedDestabilizer, the latter of which is the preferred data structure for most tasks as it is much faster by virtue of tracking the destabilizer generators.","category":"page"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"julia> s = S\"XXX\n             IZZ\";\n\njulia> Destabilizer(s)\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z__\n+ _X_\n𝒮𝓉𝒶𝒷━\n+ XXX\n+ _ZZ","category":"page"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"Unlike Destabilizer, MixedDestabilizer also tracks the logical operation generators.","category":"page"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"julia> m = MixedDestabilizer(s)\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z__\n+ _X_\n𝒳ₗ━━━\n+ _XX\n𝒮𝓉𝒶𝒷━\n+ XXX\n+ _ZZ\n𝒵ₗ━━━\n+ Z_Z\n\njulia> stabilizerview(m)\n+ XXX\n+ _ZZ\n\njulia> destabilizerview(m)\n+ Z__\n+ _X_\n\njulia> logicalxview(m)\n+ _XX\n\njulia> logicalzview(m)\n+ Z_Z","category":"page"},{"location":"mixed/#Gottesman-Canonicalization","page":"Mixed States","title":"Gottesman Canonicalization","text":"","category":"section"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"To obtain the logical operators we perform a different type of canonicalization, described in Gottesman's thesis and implemented in canonicalize_gott!. Unlike canonicalize! which uses only row operations, canonicalize_gott! performs column swaps as well. MixedDestabilizer undoes those swaps by default when instantiated, but that behavior can be turned off, if you prefer to work with the canonicalized tableau.","category":"page"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"julia> s = S\"XXX\n             ZIZ\";\n\njulia> MixedDestabilizer(s)\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z__\n+ __X\n𝒳ₗ━━━\n+ _X_\n𝒮𝓉𝒶𝒷━\n+ XXX\n+ Z_Z\n𝒵ₗ━━━\n+ ZZ_\n\njulia> MixedDestabilizer(s; undoperm=false)\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z__\n+ _X_\n𝒳ₗ━━━\n+ __X\n𝒮𝓉𝒶𝒷━\n+ XXX\n+ ZZ_\n𝒵ₗ━━━\n+ Z_Z","category":"page"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"Destabilizer and MixedStabilizer do not use any column swaps on instantiation as they do not track the logical operators.","category":"page"},{"location":"datastructures/#Data-Structures-Options","page":"Datastructure Choice","title":"Data Structures Options","text":"","category":"section"},{"location":"datastructures/#Choosing-Appropriate-Data-Structure","page":"Datastructure Choice","title":"Choosing Appropriate Tableau Data Structure","text":"","category":"section"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"There are four different data structures used to represent stabilizer states. If you will never need projective measurements you probably would want to use Stabilizer. If you require projective measurements, but only on pure states, Destabilizer should be the appropriate data structure. If mixed stabilizer states are involved, MixedStabilizer would be necessary.","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"Stabilizer is simply a list of Pauli operators in a tableau form. As a data structure it does not enforce the requirements for a pure stabilizer state (the rows of the tableau do not necessarily commute, nor are they forced to be Hermitian; the tableau might be underdetermined, redundant, or contradictory). It is up to the user to ensure that the initial values in the tableau are meaningful and consistent.","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"canonicalize!, project!, and generate! can accept an under determined (mixed state) Stabilizer instance and operate correctly. canonicalize! can also accept a redundant Stabilizer (i.e. not all rows are independent), leaving as many identity rows at the bottom of the canonicalized tableau as the number of redundant stabilizers in the initial tableau.","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"canonicalize! takes mathcalO(n^3) steps. generate! expects a canonicalized input and then takes mathcalO(n^2) steps. project! takes mathcalO(n^3) for projecting on commuting operators due to the need to call canonicalize! and generate!. If the projections is on an anticommuting operator (or if keep_result=false) then it takes mathcalO(n^2) steps.","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"MixedStabilizer provides explicit tracking of the rank of the mixed state and works properly when the projection is on a commuting operator not in the stabilizer (see table below for details). Otherwise it has the same performance as Stabilizer.","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"The canonicalization can be made unnecessary if we track the destabilizer generators. There are two data structures capable of that.","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"Destabilizer stores both the destabilizer and stabilizer states. project! called on it never requires a stabilizer canonicalization, hence it runs in mathcalO(n^2). However, project! will raise an exception if you try to project on a commuting state that is not in the stabilizer as that would be an expensive mathcalO(n^3) operation.","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"MixedDestabilizer tracks both the destabilizer operators and the logical operators in addition to the stabilizer generators. It does not require canonicalization for measurements and its project! operations always takes mathcalO(n^2).","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"For the operation _, anticom_index, result = project!(...) we have the following behavior:","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"projection Stabilizer MixedStabilizer Destabilizer MixedDestabilizer\non anticommuting operator anticom_index>0 result===nothing correct result in mathcalO(n^2) steps same as Stabilizer same as Stabilizer same as Stabilizer\non commuting operator in the stabilizer anticom_index==0 result!==nothing mathcalO(n^3); or mathcalO(n^2) if keep_result=false mathcalO(n^3) mathcalO(n^2) if the state is pure, throws exception otherwise mathcalO(n^2)\non commuting operator out of the stabilizer[1]  anticom_index==rank result===nothing mathcalO(n^3), but the user needs to manually include the new operator to the stabilizer; or mathcalO(n^2) if keep_result=false but then result indistinguishable from cell above and anticom_index==0 mathcalO(n^3) and rank goes up by one not applicable if the state is pure, throws exception otherwise mathcalO(n^2) and rank goes up by one","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"Notice the results when the projection operator commutes with the state but is not generated by the stabilizers of the state (the last row of the table). In that case we have _, anticom_index, result = project!(...) where both anticom_index==rank and result===nothing, with rank being the new rank after projection, one more than the number of rows in the tableau before the measurement. ","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"[1]: This can occur only if the state being projected is mixed. Both Stabilizer and Destabilizer can be used for mixed states by simply providing fewer stabilizer generators than qubits at initialization. This can be useful for low-level code that tries to avoid the extra memory cost of using MixedStabilizer and MixedDestabilizer but should be avoided otherwise. project! works correctly or raises an explicit warning on all 4 data structures.","category":"page"},{"location":"datastructures/#Bit-Packing-in-Integers-and-Array-Order","page":"Datastructure Choice","title":"Bit Packing in Integers and Array Order","text":"","category":"section"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"We do not use boolean arrays to store information about the qubits as this would be wasteful (7 out of 8 bits in the boolean would be unused). Instead, we use all 8 qubits in a byte and peform bitwise logical operations as necessary. Implementation details of the object in RAM can matter for performance. The library permits any of the standard UInt types to be used for packing the bits, and larger UInt types (like UInt64) are usually faster as they permit working on 64 qubits at a time (instead of 1 if we used a boolean, or 8 if we used a byte).","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"Moreover, how a tableau is stored in memory can affect performance, as a row-major storage usually permits more efficient use of the CPU cache (for the particular algorithms we use).","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"Both of these parameters are benchmarked (testing the application of a Pauli operator, which is an mathcalO(n^2) operation; and testing the canonicalization of a Stabilizer, which is an mathcalO(n^3) operation). Row-major UInt64 is the best performing and it is  used by default in this library.","category":"page"},{"location":"noisycircuits_ops/#noisycircuits_ops","page":"Circuit Operations","title":"Operators in Circuit Simulations","text":"","category":"section"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"DocTestSetup = quote\n    using QuantumClifford\n    using QuantumClifford.Experimental.NoisyCircuits\n    using Quantikz\nend\nCurrentModule = QuantumClifford.Experimental.NoisyCircuits","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"warning: Unstable\nThis is experimental functionality with an unstable API.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"Import with using QuantumClifford.Experimental.NoisyCircuits.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"Too see a condensed list of all operations check out the API docs.","category":"page"},{"location":"noisycircuits_ops/#Unitary-Gates","page":"Circuit Operations","title":"Unitary Gates","text":"","category":"section"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"We distinguish between symbolic gates like sCNOT that have specialized (fast) apply! methods (usually just for single and two qubit gates) and general tableau representation of gates like CliffordOperator that can represent any multi-qubit gate.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"Predefined unitary gates are available, like sCNOT, sHadamard, etc.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"using QuantumClifford # hide\nusing QuantumClifford.Experimental.NoisyCircuits # hide\nusing Quantikz # hide\n[sCNOT(2,4),sHadamard(2),sCPHASE(1,3),sSWAP(2,4)]","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"Any arbitrary tableaux can be used as a gate too. ","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"They can be specified by giving a Clifford operator tableaux and the indices on which it acts (particularly useful for gates acting on a small part of a circuit):","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"using QuantumClifford # hide\nusing QuantumClifford.Experimental.NoisyCircuits # hide\nusing Quantikz # hide\nSparseGate(tCNOT, [2,4])","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"The Clifford operator tableaux can be completely arbitrary.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"SparseGate(random_clifford(3), [2,4,5])","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"If the Clifford operator acts on all qubits, we do not need to specify indices, just use the operator.","category":"page"},{"location":"noisycircuits_ops/#Noisy-Gates","page":"Circuit Operations","title":"Noisy Gates","text":"","category":"section"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"Each gate can be followed by noise applied to the qubits on which it has acted. This is done by wrapping the given gate into a NoisyGate","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"ε = 0.03 # X/Y/Z error probability\nnoise = UnbiasedUncorrelatedNoise(ε)\nnoisy_gate = NoisyGate(SparseGate(tCNOT, [2,4]), noise)","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"In circuit diagrams the noise is not depicted, but after each application of the gate defined in noisy_gate, a noise operator will also be applied. The example above is of Pauli Depolarization implemented by UnbiasedUncorrelatedNoise.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"One can also apply only the noise operator by using NoiseOp which acts only on specified qubits. Or alternatively, one can use NoiseOpAll in order to apply noise to all qubits.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"[NoiseOp(noise, [4,5]), NoiseOpAll(noise)]","category":"page"},{"location":"noisycircuits_ops/#Coincidence-Measurements","page":"Circuit Operations","title":"Coincidence Measurements","text":"","category":"section"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"Global parity measurements involving single-qubit projections and classical communication are implemented with BellMeasurement. One needs to specify the axes of measurement and the qubits being measured. If the parity is trivial, the circuit continues, if the parity is non-trivial, the circuit ends and reports a detected failure. This operator is frequently used in the simulation of entanglement purification.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"BellMeasurement([sMX(1), sMY(3), sMZ(4)])","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"There is also NoisyBellMeasurement that takes the bit-flip probability of a single-qubit measurement as a third argument.","category":"page"},{"location":"noisycircuits_ops/#Stabilizer-Measurements","page":"Circuit Operations","title":"Stabilizer Measurements","text":"","category":"section"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"A measurement over one or more qubits can also be performed, e.g., a direct stabilizer measurement on multiple qubits without the use of ancillary qubits. When applied to multiple qubits, this differs from BellMeasurement as it performs a single projection, unlike BellMeasurement which performs a separate projection for every single qubit involved. This measurement is implemented in PauliMeasurement which requires a Pauli operator on which to project and the index of the classical bit in which to store the result. Alternatively, there are sMX, sMZ, sMY if you are measuring a single qubit.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"[PauliMeasurement(P\"XYZ\", 1), sMZ(2, 2)]","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"TODO: SparseMeasurement, NoisyMeasurement","category":"page"},{"location":"noisycircuits_ops/#Verification-Operations","page":"Circuit Operations","title":"Verification Operations","text":"","category":"section"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"At the end of many circuits one might want to check whether they performed correctly. The VerifyOp operation corresponds to an unphysical perfect tomographic operation, checking whether the state of the qubits at the given indices is indeed what is expected. If it is, the operation reports a success, otherwise it reports an undetected error.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"desired_state = random_stabilizer(5)\nqubit_indices = [1,2,3,4,7]\nVerifyOp(desired_state, qubit_indices)","category":"page"},{"location":"noisycircuits_ops/#Reset-Operations","page":"Circuit Operations","title":"Reset Operations","text":"","category":"section"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"The Reset operations lets you trace out the specified qubits and set their state to a specific tableau.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"new_state = random_stabilizer(3)\nqubit_indices = [1,2,3]\nReset(new_state, qubit_indices)","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"It can be done anywhere in a circuit, not just at the beginning.","category":"page"},{"location":"noisycircuits_ops/#Gates-Conditioned-on-Classical-Bits","page":"Circuit Operations","title":"Gates Conditioned on Classical Bits","text":"","category":"section"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"ConditionalGate is a conditional gate that performs one of two provided gates, depending on the value of a given classical bit.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"DecisionGate is a conditional gate that performs one of the supplied gates, depending on the output of decisionfunction applied to the entire classical bit register.","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"gate1 = SparseGate(tCNOT,   [1,2])\ngate2 = sCPHASE(1,2)\ngate3 = SparseGate(tSWAP,   [1,3])\ncg = ConditionalGate(gate1, gate2, 2)\ndg = DecisionGate([gate1,gate2,gate3], bit_register->1) # it will always perform gate1\n[sMX(4,1), sMZ(5,2), cg, dg]","category":"page"},{"location":"noisycircuits_ops/","page":"Circuit Operations","title":"Circuit Operations","text":"TODO: Split ConditionalGate into quantum conditional and classical conditional","category":"page"},{"location":"plotting/#Visualizations","page":"Visualizations","title":"Visualizations","text":"","category":"section"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"Stabilizers have a plot recipe that can be used with Plots.jl or Makie.jl. It simply displays the corresponding parity check matrix (extracted with stab_to_gf2) as a bitmap image. Circuits can be visualized with Quantikz.jl.","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"Importing the aforementioned packages together with QuantumClifford is necessary to enable the plotting functionality (implemented as package extensions).","category":"page"},{"location":"plotting/#Plots.jl","page":"Visualizations","title":"Plots.jl","text":"","category":"section"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"In Plots.jl we have a simple recipe plot(s::Stabilizer; xzcomponents=...) where xzcomponents=:split plots the tableau heatmap in a wide form, X bits on the left, Z bits on the right; or xzcomponents=:together plots them overlapping, with different colors for I, X, Z, and Y.","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"using QuantumClifford, Plots\nplot(random_stabilizer(20,30), xzcomponents=:split)","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"using QuantumClifford, Plots\nplot(canonicalize!(random_stabilizer(20,30)))","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"using QuantumClifford, Plots\nplot(canonicalize_gott!(random_stabilizer(30))[1], xzcomponents=:split)","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"using QuantumClifford, Plots\nplot(canonicalize_gott!(random_stabilizer(30))[1]; xzcomponents=:together)","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"using QuantumClifford, Plots\nplot(canonicalize_rref!(random_stabilizer(20,30),1:30)[1]; xzcomponents=:together)","category":"page"},{"location":"plotting/#Makie.jl","page":"Visualizations","title":"Makie.jl","text":"","category":"section"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"Makie's heatmap can be directly called on Stabilizer.","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"using QuantumClifford, CairoMakie\ns = S\"IIXZ\n      ZZIZ\n      YYIZ\n      IIIZ\n      ZZXZ\"\nf, ax, p = CairoMakie.heatmap(s)\nhidedecorations!(ax); hidespines!(ax); # remove ticks and spines\nax.aspect = DataAspect(); # set a one-to-one aspect ratio\nf","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"A full Makie recipe is available as well (supporting xzcomponents)","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"using QuantumClifford, CairoMakie\ns = S\"IIXZ\n      ZZIZ\n      YYIZ\n      IIIZ\n      ZZXZ\"\nf, ax, p = stabilizerplot(s, xzcomponents=:together)\nhidedecorations!(ax); hidespines!(ax)\nax.aspect = DataAspect()\nf","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"You can easily add colorbars (and change the colormap) as well:","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"using QuantumClifford, CairoMakie\nfig = Figure()\nax, p = stabilizerplot(fig[1, 1], s, colormap=cgrad(:heat, 4, categorical = true))\nhidedecorations!(ax)\nhidespines!(ax)\nxlims!(ax, 0.5, size(s,2)+0.5) # otherwise there is padding\nylims!(ax, 0.5, size(s,1)+0.5) # otherwise there is padding\n# set the aspect ratio of the plot\nax.aspect = DataAspect()\n# set the aspect ratio of the layout\ncolsize!(fig.layout, 1, Aspect(1, size(s,2)/size(s,1))) \nColorbar(fig[1, 2], p, ticks = (0:3, [\"I\", \"X\", \"Z\", \"Y\"]))\nfig","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"Or set a completely custom set of colors:","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"fig = Figure()\nax, p = stabilizerplot(fig[1, 1], s, colormap=cgrad([:lightgray,RGBf(1,0.4,0.4),RGBf(0.3,1,0.5),RGBf(0.4,0.4,1)], 4, categorical = true))\nhidedecorations!(ax)\nhidespines!(ax)\nxlims!(ax, 0.5, size(s,2)+0.5)\nylims!(ax, 0.5, size(s,1)+0.5)\nax.aspect = DataAspect()\ncolsize!(fig.layout, 1, Aspect(1, size(s,2)/size(s,1))) \nColorbar(fig[2, 1], p, ticks = (0:3, [\"I\", \"X\", \"Z\", \"Y\"]), vertical = false, flipaxis = false)\nfig","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"You might have noticed, Makie recipes do not let you edit the axes or figure, rather they only permit you to set the plot content. Which is why we use hidedecorations!, hidesplines!, and DataAspect to further modify the plot. However, these defaults are also available in stabilizerplot_axis.","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"using QuantumClifford, CairoMakie\nf=Figure()\nstabilizerplot_axis(f[1,1],random_stabilizer(100))\nf","category":"page"},{"location":"plotting/#Quantikz.jl","page":"Visualizations","title":"Quantikz.jl","text":"","category":"section"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"With the Quantikz library you can visualize gates or sequences of gates.","category":"page"},{"location":"plotting/","page":"Visualizations","title":"Visualizations","text":"using QuantumClifford, Quantikz\ncircuit = [sCNOT(1,2), SparseGate(random_clifford(4), [1,4,5,6]), sMZ(4)]","category":"page"},{"location":"#QuantumClifford.jl","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"","category":"section"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"DocTestSetup = quote\n    using QuantumClifford\nend","category":"page"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"QuantumClifford.jl is a Julia library for simulation of Clifford circuits, which are a subclass of quantum circuits that can be efficiently simulated on a classical computer.","category":"page"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"This library uses the tableaux formalism[1] with the destabilizer improvements[2]. Pauli frames are supported for faster repeated simulation of noisy circuits. Various symbolic and algebraic tools for manipulating, converting, and visualizing states and circuits are also implemented. ","category":"page"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"[1]: (Gottesman, 1998)","category":"page"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"[2]: (Aaronson and Gottesman, 2004)","category":"page"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"The library consists of two main parts: Tools for working with the algebra of Stabilizer Tableaux and tools specifically for efficient Circuit Simulation.","category":"page"},{"location":"#Stabilizer-Tableau-Algebra","page":"QuantumClifford.jl","title":"Stabilizer Tableau Algebra","text":"","category":"section"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"The Stabilizer Tableau Algebra component of QuantumClifford.jl efficiently handles pure and mixed stabilizer states of thousands of qubits, along with support for sparse or dense Clifford operations acting upon them. It provides operations such as canonicalization, projection, generation , and partial traces. The code is vectorized and multithreaded, offering fast, in-place, and allocation-free implementations. Tools for conversion to graph states and for visualization of tableaux are available.","category":"page"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"See the Stabilizer Tableau Algebra manual or the curated list of useful functions.","category":"page"},{"location":"#Example-Usage","page":"QuantumClifford.jl","title":"Example Usage","text":"","category":"section"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"julia> using QuantumClifford\n\njulia> P\"X\" * P\"Z\"\n-iY\n\njulia> P\"X\" ⊗ P\"Z\"\n+ XZ\n\njulia> S\"-XX\n         +ZZ\"\n- XX\n+ ZZ\n\njulia> tCNOT * S\"-XX\n                 +ZZ\"\n- X_\n+ _Z","category":"page"},{"location":"#Circuit-Simulation","page":"QuantumClifford.jl","title":"Circuit Simulation","text":"","category":"section"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"The circuit simulation component of QuantumClifford.jl enables Monte Carlo (or symbolic) simulations of noisy Clifford circuits. It provides three main simulation methods: mctrajectories, pftrajectories, and petrajectories. These methods offer varying levels of efficiency, accuracy, and insight.","category":"page"},{"location":"#Monte-Carlo-Simulations-with-Stabilizer-Tableaux-(mctrajectories)","page":"QuantumClifford.jl","title":"Monte Carlo Simulations with Stabilizer Tableaux (mctrajectories)","text":"","category":"section"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"The mctrajectories method runs Monte Carlo simulations using a Stabilizer tableau representation for the quantum states.","category":"page"},{"location":"#Monte-Carlo-Simulations-with-Pauli-Frames-(pftrajectories)","page":"QuantumClifford.jl","title":"Monte Carlo Simulations with Pauli Frames (pftrajectories)","text":"","category":"section"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"The pftrajectories method runs Monte Carlo simulations of Pauli frames over a single reference Stabilizer tableau simulation. This approach is much more efficient but supports a smaller class of circuits.","category":"page"},{"location":"#Symbolic-Depth-First-Traversal-of-Quantum-Trajectories-(petrajectories)","page":"QuantumClifford.jl","title":"Symbolic Depth-First Traversal of Quantum Trajectories (petrajectories)","text":"","category":"section"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"The petrajectories method performs a depth-first traversal of the most probable quantum trajectories, providing a fixed-order approximation of the circuit's behavior. This approach gives symbolic expressions for various figures of merit instead of just a numeric value.","category":"page"}]
}

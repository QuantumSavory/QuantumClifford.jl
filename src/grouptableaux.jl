using Graphs
using LinearAlgebra

"""
Return the full stabilizer group represented by the input generating set (a [`Stabilizer`](@ref)).

The returned object is exponentially long.

```jldoctest
julia> groupify(S"XZ ZX")
+ __
+ XZ
+ ZX
+ YY
```
"""
function groupify(s::Stabilizer)
    # Create a `Tableau` of 2ⁿ n-qubit identity Pauli operators(where n is the size of 
    # `Stabilizer` s), then multiply each one by a different subset of the elements in s to 
    # create all 2ⁿ unique elements in the group generated by s, then return the `Tableau`.
    n = length(s)::Int
    group = zero(Tableau, 2^n, nqubits(s))
    for i in 0:2^n-1
        for (digit_order, j) in enumerate(digits(i, base=2, pad=n))
            if j == 1
                group[i+1] *= s[digit_order]
            end
        end
    end
    return group 
end


"""
For a not-necessarily-minimal generating set,
return the minimal generating set.

The input has to have only real phases.

```jldoctest
julia> minimal_generating_set(S"__ XZ ZX YY")
+ XZ
+ ZX
```
"""
function minimal_generating_set(s::Stabilizer)
    # Canonicalize `Stabilizer` s, then return a `Stabilizer` with all non-identity Pauli operators 
    # in the result. If s consists of only identity operators, return the negative 
    # identity operator if one is contained in s, and the positive identity operator otherwise.
    s, _, r = canonicalize!(copy(s), ranks=true)
    if r == 0
        gs = zero(Stabilizer, 1, nqubits(s))
        if 0x02 in phases(s)
            gs[1] = -1 * gs[1]
        end
        return gs
    else
        return s[1:r, :]
    end
end

"""
Return the full Pauli group of a given length. Phases are ignored by default, 
but can be included by setting `phases=true`.

```jldoctest
julia> pauligroup(1)
+ _
+ X
+ Z
+ Y

julia> pauligroup(1, phases=true)
+ _
+ X
+ Z
+ Y
- _
- X
- Z
- Y
+i_
+iX
+iZ
+iY
-i_
-iX
-iZ
-iY
```
"""
function pauligroup(n::Int; phases=false)
    if phases
        s = zero(Tableau, 4^(n + 1), n)
        paulis = ((false, false), (true, false), (false, true), (true, true))
        for (i, P) in enumerate(Iterators.product(Iterators.repeated(paulis, n)...))
            for (j, p) in enumerate(P)
                s[i, j] = p
            end
        end
        for i in 1:4^n
            s[i+4^n] = -1 * s[i]
        end
        for i in 4^n+1:2*4^n
            s[i+4^n] = -1im * s[i]
        end
        for i in 2*4^n+1:3*4^n
            s[i+4^n] = -1 * s[i]
        end
    end
    if !phases
        s = zero(Tableau, 4^n, n)
        paulis = ((false, false), (true, false), (false, true), (true, true))
        for (i, P) in enumerate(Iterators.product(Iterators.repeated(paulis, n)...))
            for (j, p) in enumerate(P)
                s[i, j] = p
            end
        end
    end
    return s
end

"""
Return all Pauli operators with the same number of qubits as the given `Tableau` `t`
that commute with all operators in `t`.

```jldoctest
julia> normalizer(T"X")
+ _
+ X
```
"""
function normalizer(t::Tableau)
    # For each `PauliOperator` p in the with same number of qubits as the `Stabilizer` s, iterate through s and check each 
    # operator's commutivity with p. If they all commute, add p a vector of `PauliOperators`. Return the vector 
    # converted to `Tableau`.
    n = nqubits(t)
    pgroup = pauligroup(n, phases=false)
    ptype = typeof(t[1])
    normalizer = ptype[]
    for p in pgroup
        commutes = true
        for q in t
            if comm(p, q) == 0x01
                commutes = false
            end
        end
        if commutes
            push!(normalizer, p)
        end
    end

    return Tableau(normalizer)
end

"""
For a given set of Paulis (in the form of a `Tableau`), return the subset of Paulis that commute with all Paulis in set.

```jldoctest
julia> centralizer(T"XX ZZ _Z")
+ ZZ
```
"""
function centralizer(t::Tableau) 
    center = typeof(t[1])[]
    for P in t
        commutes = 0
        for Q in t
            if comm(P, Q) == 0x01
                commutes = 1
                break
            end
        end
        if commutes == 0
            push!(center, P)
        end
    end
    if length(center) == 0 
        return Tableau(zeros(Bool, 1,1))
    end
    c = Tableau(center)
    return c
end

"""
Return the subset of Paulis in a Stabilizer that have identity operators on all qubits corresponding to 
the given subset, without the entries corresponding to subset.

```jldoctest
julia> contractor(S"_X X_", [1])
+ X
```
"""
function contractor(s::Stabilizer, subset)
    result = typeof(s[1])[]
    for p in s
        contractable = true
        for i in subset
            if p[i] != (false, false) 
                contractable = false 
                break 
            end
        end
        if contractable push!(result, p[setdiff(1:length(p), subset)]) end
    end
    if length(result) > 0
        return Tableau(result)
    else
        return Tableau(zeros(Bool, 1,1))
    end
end